searchData={"items":[{"type":"task","title":"mix opal.gen.json_schema","doc":"Generates a JSON Schema file from the Opal RPC protocol specification.\n\nThe output is written to `priv/rpc_schema.json` by default, or to the\npath given as the first argument.","ref":"Mix.Tasks.Opal.Gen.JsonSchema.html"},{"type":"task","title":"Usage - mix opal.gen.json_schema","doc":"mix opal.gen.json_schema\n    mix opal.gen.json_schema ../sdk/src/rpc_schema.json","ref":"Mix.Tasks.Opal.Gen.JsonSchema.html#module-usage"},{"type":"module","title":"Opal.Agent.State","doc":"Internal state for `Opal.Agent`.\n\nTracks conversation history, streaming state, accumulated response text\nand tool calls, and the provider module used for LLM communication.","ref":"Opal.Agent.State.html"},{"type":"type","title":"Opal.Agent.State.t/0","doc":"","ref":"Opal.Agent.State.html#t:t/0"},{"type":"module","title":"Opal.Config.Copilot","doc":"Copilot-specific configuration: OAuth client ID and GitHub domain.","ref":"Opal.Config.Copilot.html"},{"type":"module","title":"Fields - Opal.Config.Copilot","doc":"* `:client_id` — OAuth App client ID for the Copilot device-code flow.\n    Default: `\"Iv1.b507a08c87ecfe98\"` (the VS Code Copilot Chat extension's ID).\n\n  * `:domain` — GitHub domain for authentication endpoints.\n    Default: `\"github.com\"`. Change for GitHub Enterprise Server instances.","ref":"Opal.Config.Copilot.html#module-fields"},{"type":"type","title":"Opal.Config.Copilot.t/0","doc":"","ref":"Opal.Config.Copilot.html#t:t/0"},{"type":"function","title":"Opal.Config.Copilot.new/1","doc":"Builds from a keyword list or map.","ref":"Opal.Config.Copilot.html#new/1"},{"type":"module","title":"Opal.Config.Features","doc":"Unified feature toggles for optional Opal subsystems.\n\nGroups all optional subsystem configuration under a single struct\nwith consistent `enabled` toggles and subsystem-specific options.","ref":"Opal.Config.Features.html"},{"type":"module","title":"Subsystems - Opal.Config.Features","doc":"* `:sub_agents` — child agent spawning via `Opal.SubAgent`\n  * `:context` — walk-up context file discovery (AGENTS.md, OPAL.md, etc.)\n  * `:skills` — skill directory discovery and progressive disclosure\n  * `:mcp` — MCP (Model Context Protocol) client integration","ref":"Opal.Config.Features.html#module-subsystems"},{"type":"module","title":"Usage - Opal.Config.Features","doc":"# Disable sub-agents and MCP, customize context filenames\n    features = Opal.Config.Features.new(%{\n      sub_agents: %{enabled: false},\n      mcp: %{enabled: false},\n      context: %{filenames: [\"AGENTS.md\", \"CUSTOM.md\"]}\n    })\n\n    # Or via application config\n    config :opal,\n      features: %{\n        sub_agents: %{enabled: true},\n        context: %{filenames: [\"AGENTS.md\"]},\n        skills: %{extra_dirs: [\"/opt/skills\"]},\n        mcp: %{enabled: true, servers: [], config_files: []}\n      }","ref":"Opal.Config.Features.html#module-usage"},{"type":"type","title":"Opal.Config.Features.context_config/0","doc":"Context file discovery configuration.\n\n  * `:enabled` — whether walk-up context discovery runs at startup. Default: `true`.\n  * `:filenames` — filenames to look for during walk-up discovery.\n    Default: `[\"AGENTS.md\", \"OPAL.md\"]`. Files found closer to the working\n    directory take higher priority.","ref":"Opal.Config.Features.html#t:context_config/0"},{"type":"type","title":"Opal.Config.Features.mcp_config/0","doc":"MCP (Model Context Protocol) client configuration.\n\n  * `:enabled` — whether MCP client integration is active. When `false`,\n    no MCP servers are started and no `mcp.json` files are read. Default: `true`.\n  * `:servers` — explicit list of MCP server configurations, each a map\n    with `:name` (string) and `:transport` (tuple) keys. Default: `[]`.\n  * `:config_files` — additional file paths to search for `mcp.json`\n    configuration files (absolute or relative to the working directory).\n    Searched in addition to standard locations (`.vscode/mcp.json`,\n    `.github/mcp.json`, `.opal/mcp.json`, `.mcp.json`, `~/.opal/mcp.json`).\n    Default: `[]`.","ref":"Opal.Config.Features.html#t:mcp_config/0"},{"type":"type","title":"Opal.Config.Features.skills_config/0","doc":"Skill directory discovery configuration.\n\n  * `:enabled` — whether skill discovery runs at startup. Default: `true`.\n  * `:extra_dirs` — additional directories to scan for skill subdirectories\n    (each containing a `SKILL.md`). Searched in addition to the standard\n    locations (`.agents/skills/`, `.github/skills/` in the project and\n    `~/.agents/skills/`, `~/.opal/skills/` globally). Default: `[]`.","ref":"Opal.Config.Features.html#t:skills_config/0"},{"type":"type","title":"Opal.Config.Features.sub_agents_config/0","doc":"Sub-agent subsystem configuration.\n\n  * `:enabled` — whether sub-agent spawning is allowed. Default: `true`.","ref":"Opal.Config.Features.html#t:sub_agents_config/0"},{"type":"type","title":"Opal.Config.Features.t/0","doc":"","ref":"Opal.Config.Features.html#t:t/0"},{"type":"function","title":"Opal.Config.Features.new/1","doc":"Builds a Features struct from a map or keyword list.\n\nEach subsystem key accepts either a map of options or a boolean shorthand.\nBoolean shorthand sets only the `:enabled` flag, keeping other defaults.","ref":"Opal.Config.Features.html#new/1"},{"type":"function","title":"Examples - Opal.Config.Features.new/1","doc":"# Full config\n    Opal.Config.Features.new(%{\n      sub_agents: %{enabled: false},\n      mcp: %{enabled: true, servers: [%{name: :fs, transport: {:stdio, command: \"npx\"}}]}\n    })\n\n    # Boolean shorthand\n    Opal.Config.Features.new(%{sub_agents: false, mcp: false})","ref":"Opal.Config.Features.html#new/1-examples"},{"type":"module","title":"Opal.MCP.Servers.Weather","doc":"Example MCP server that provides weather information via stdio JSON-RPC.\n\nImplements the MCP protocol directly over stdin/stdout without depending\non Anubis server (which has a bug in its stdio transport message parsing).\n\nUses the free wttr.in API to fetch current weather for a given location.\nDefaults to Seattle if no location is specified.","ref":"Opal.MCP.Servers.Weather.html"},{"type":"module","title":"Usage - Opal.MCP.Servers.Weather","doc":"Started as a stdio MCP server via `mix opal.mcp.weather`:\n\n    mix opal.mcp.weather\n\nOr reference it in `.mcp.json`:\n\n    {\n      \"servers\": {\n        \"weather\": {\n          \"command\": \"mix\",\n          \"args\": [\"opal.mcp.weather\"]\n        }\n      }\n    }","ref":"Opal.MCP.Servers.Weather.html#module-usage"},{"type":"function","title":"Opal.MCP.Servers.Weather.run/0","doc":"Starts the stdio MCP server loop.","ref":"Opal.MCP.Servers.Weather.html#run/0"},{"type":"module","title":"Opal.Tool.Tasks","doc":"Project-scoped task tracker backed by DETS (built into Erlang).\n\nUses structured JSON parameters — no SQL parsing needed. The LLM\npasses action + fields directly. Database stored at `.opal/tasks.dets`.","ref":"Opal.Tool.Tasks.html"},{"type":"module","title":"Actions - Opal.Tool.Tasks","doc":"insert  — create a task (requires label)\n    list    — list tasks with optional filters or a named view\n    update  — update a task by id\n    delete  — delete a task by id","ref":"Opal.Tool.Tasks.html#module-actions"},{"type":"module","title":"Fields - Opal.Tool.Tasks","doc":"id, label, status (open|done|blocked|in_progress),\n    priority (low|medium|high|critical), group_name, tags,\n    due (ISO date), notes, blocked_by","ref":"Opal.Tool.Tasks.html#module-fields"},{"type":"function","title":"Opal.Tool.Tasks.clear/1","doc":"Clear all tasks. Called at session start to reset the scratchpad.","ref":"Opal.Tool.Tasks.html#clear/1"},{"type":"function","title":"Opal.Tool.Tasks.query_raw/2","doc":"Return active tasks as a list of maps. Used by the RPC layer.","ref":"Opal.Tool.Tasks.html#query_raw/2"},{"type":"module","title":"Opal.Tool.UseSkill","doc":"Loads an agent skill's full instructions into the active context.\n\nSkills use progressive disclosure: only name/description are visible\ninitially. This tool loads the full instructions when the agent decides\na skill is relevant to the current task.","ref":"Opal.Tool.UseSkill.html"},{"type":"module","title":"Opal","doc":"Public API for the Opal coding agent SDK.\n\nProvides functions to start agent sessions, send prompts (async and sync),\nsteer agents mid-run, and manage session lifecycle. All agent events are\nbroadcast via `Opal.Events` for real-time observability.\n\nSession defaults (model, tools, shell, data_dir) come from `Opal.Config`\nand can be overridden per-session.","ref":"Opal.html"},{"type":"module","title":"Quick Start - Opal","doc":"{:ok, agent} = Opal.start_session(%{\n      system_prompt: \"You are a helpful coding assistant.\",\n      working_dir: \"/path/to/project\"\n    })\n\n    :ok = Opal.prompt(agent, \"List all Elixir files\")\n\n    # Or synchronously:\n    {:ok, response} = Opal.prompt_sync(agent, \"What is 2 + 2?\")","ref":"Opal.html#module-quick-start"},{"type":"function","title":"Opal.abort/1","doc":"Aborts the current agent run.","ref":"Opal.html#abort/1"},{"type":"function","title":"Opal.follow_up/2","doc":"Sends a follow-up prompt to the agent. Convenience wrapper for `prompt/2`.","ref":"Opal.html#follow_up/2"},{"type":"function","title":"Opal.get_context/1","doc":"Returns the full context window (system prompt + all messages) for a session.","ref":"Opal.html#get_context/1"},{"type":"function","title":"Opal.prompt/2","doc":"Sends an asynchronous prompt to the agent.\n\nSubscribe to `Opal.Events` with the session ID to receive streaming output.\nReturns `:ok` immediately.","ref":"Opal.html#prompt/2"},{"type":"function","title":"Opal.prompt_sync/3","doc":"Sends a prompt and waits synchronously for the final response.\n\nSubscribes to the agent's events, sends the prompt, and collects text\ndeltas until `:agent_end` is received. Returns the accumulated text.","ref":"Opal.html#prompt_sync/3"},{"type":"function","title":"Options - Opal.prompt_sync/3","doc":"* `timeout` — maximum wait time in milliseconds (default: `60_000`)","ref":"Opal.html#prompt_sync/3-options"},{"type":"function","title":"Opal.set_model/4","doc":"Changes the model on a running agent session.\n\nThe new model takes effect on the next prompt. Conversation history is preserved.\n\n    Opal.set_model(agent, :copilot, \"gpt-5\")","ref":"Opal.html#set_model/4"},{"type":"function","title":"Opal.start_session/1","doc":"Starts a new agent session with the given configuration.\n\nAll keys are optional — defaults come from `config :opal` via `Opal.Config`.","ref":"Opal.html#start_session/1"},{"type":"function","title":"Config Keys - Opal.start_session/1","doc":"* `:model` — a `{provider_atom, model_id_string}` tuple\n  * `:tools` — list of modules implementing `Opal.Tool`\n  * `:system_prompt` — the system prompt string (default: `\"\"`)\n  * `:working_dir` — base directory for tool execution (default: current dir)\n  * `:provider` — module implementing `Opal.Provider` (default: `Opal.Provider.Copilot`)\n  * `:session` — if `true`, starts an `Opal.Session` process for persistence/branching\n  * `:shell` — shell type for `Opal.Tool.Shell` (default: platform auto-detect)\n  * `:data_dir` — override data directory (default: `~/.opal`)","ref":"Opal.html#start_session/1-config-keys"},{"type":"function","title":"Examples - Opal.start_session/1","doc":"# Minimal — everything from config :opal\n    {:ok, agent} = Opal.start_session(%{working_dir: \"/project\"})\n\n    # Override model for this session\n    {:ok, agent} = Opal.start_session(%{\n      model: {:copilot, \"gpt-5\"},\n      working_dir: \"/project\"\n    })","ref":"Opal.html#start_session/1-examples"},{"type":"function","title":"Opal.steer/2","doc":"Steers the agent mid-run.\n\nIf idle, acts like `prompt/2`. If running, the message is picked up\nbetween tool executions.","ref":"Opal.html#steer/2"},{"type":"function","title":"Opal.stop_session/1","doc":"Stops a session and cleans up.\n\nTerminates the entire session supervision tree (agent, tools, sub-agents).","ref":"Opal.html#stop_session/1"},{"type":"module","title":"Opal.Agent","doc":"GenServer implementing the core agent loop.\n\nManages the lifecycle of an agent session: receiving user prompts, streaming\nLLM responses via a provider, executing tool calls concurrently, and looping\nuntil the model produces a final text response with no tool calls.","ref":"Opal.Agent.html"},{"type":"module","title":"Usage - Opal.Agent","doc":"{:ok, pid} = Opal.Agent.start_link(\n      session_id: \"session-abc\",\n      system_prompt: \"You are a coding assistant.\",\n      model: %Opal.Model{provider: :copilot, id: \"claude-sonnet-4-5\"},\n      tools: [Opal.Tool.Read, Opal.Tool.Write],\n      working_dir: \"/path/to/project\"\n    )\n\n    :ok = Opal.Agent.prompt(pid, \"List all files\")\n\nEvents are broadcast via `Opal.Events` using the session ID, so any\nsubscriber can observe the full lifecycle in real time.","ref":"Opal.Agent.html#module-usage"},{"type":"function","title":"Opal.Agent.abort/1","doc":"Aborts the current agent run.\n\nIf streaming, cancels the response. Sets status to `:idle`.","ref":"Opal.Agent.html#abort/1"},{"type":"function","title":"Opal.Agent.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Opal.Agent.html#child_spec/1"},{"type":"function","title":"Opal.Agent.follow_up/2","doc":"Sends a follow-up prompt to the agent. Convenience alias for `prompt/2`.","ref":"Opal.Agent.html#follow_up/2"},{"type":"function","title":"Opal.Agent.get_state/1","doc":"Returns the current agent state synchronously.","ref":"Opal.Agent.html#get_state/1"},{"type":"function","title":"Opal.Agent.load_skill/2","doc":"Loads a skill by name into the agent's active context.\n\nReturns `{:ok, skill_name}` if loaded, `{:already_loaded, skill_name}` if\nalready active, or `{:error, reason}` if the skill is not found.","ref":"Opal.Agent.html#load_skill/2"},{"type":"function","title":"Opal.Agent.platform/1","doc":"Returns the current platform as `:linux`, `:macos`, or `:windows`.","ref":"Opal.Agent.html#platform/1"},{"type":"function","title":"Opal.Agent.prompt/2","doc":"Sends an asynchronous user prompt to the agent.\n\nAppends a user message, sets status to `:running`, and begins a new LLM turn.\nReturns `:ok` immediately.","ref":"Opal.Agent.html#prompt/2"},{"type":"function","title":"Opal.Agent.start_link/1","doc":"Starts the agent GenServer.","ref":"Opal.Agent.html#start_link/1"},{"type":"function","title":"Options - Opal.Agent.start_link/1","doc":"* `:session_id` — unique string identifier for this session (required)\n  * `:system_prompt` — the system prompt string (default: `\"\"`)\n  * `:model` — an `Opal.Model.t()` struct (required)\n  * `:tools` — list of modules implementing `Opal.Tool` (default: `[]`)\n  * `:working_dir` — base directory for tool execution (required)\n  * `:provider` — module implementing `Opal.Provider` (default: `Opal.Provider.Copilot`)","ref":"Opal.Agent.html#start_link/1-options"},{"type":"function","title":"Opal.Agent.steer/2","doc":"Injects a steering message into the agent.\n\nIf the agent is idle, this behaves like `prompt/2`. If the agent is running\nor streaming, the steering message is queued in the GenServer mailbox and\npicked up between tool executions.","ref":"Opal.Agent.html#steer/2"},{"type":"module","title":"Opal.Config","doc":"Typed configuration struct for Opal sessions.\n\nBuilt once via `Opal.Config.new/1`, then threaded through the system.\nEvery config key has a known type and a sensible default.","ref":"Opal.Config.html"},{"type":"module","title":"Priority (highest wins) - Opal.Config","doc":"1. Session overrides — keys passed to `Opal.Config.new/1` or `Opal.start_session/1`\n2. Application config — `config :opal, ...` in your `config.exs`\n3. Environment variables — via `config/runtime.exs`\n4. Built-in defaults in this struct","ref":"Opal.Config.html#module-priority-highest-wins"},{"type":"module","title":"Fields - Opal.Config","doc":"* `:data_dir` — root directory for Opal data (sessions, logs, auth token).\n    Defaults to `~/.opal` on Unix or `%APPDATA%/opal` on Windows.\n\n  * `:shell` — shell used by `Opal.Tool.Shell` for command execution.\n    Accepts `:bash`, `:zsh`, `:sh`, `:fish`, `:powershell`, or `:cmd`.\n    Defaults to auto-detection based on the current platform.\n\n  * `:default_model` — a `{provider_atom, model_id}` tuple specifying the\n    LLM to use. Default: `{\"copilot\", \"claude-sonnet-4-5\"}`.\n\n  * `:default_tools` — list of modules implementing `Opal.Tool` available\n    to the agent. Default: `[Opal.Tool.Read, Opal.Tool.Write, Opal.Tool.Edit, Opal.Tool.Shell]`.\n\n  * `:provider` — module implementing `Opal.Provider` for LLM communication.\n    Default: `Opal.Provider.Copilot`.\n\n  * `:auto_save` — when `true`, automatically persists the session to disk\n    after the agent goes idle. Requires a `Session` process to be attached.\n    Default: `false`.\n\n  * `:auto_title` — when `true`, automatically generates a short session title\n    from the first user message using the LLM. Default: `true`.\n\n  * `:copilot` — an `Opal.Config.Copilot` struct with Copilot-specific\n    settings (`:client_id` and `:domain`). Can be passed as a keyword list.\n\n  * `:features` — an `Opal.Config.Features` struct controlling optional\n    subsystems. Each subsystem has an `:enabled` toggle and subsystem-specific\n    options. See `Opal.Config.Features` for full documentation.\n\n    Subsystems: `:sub_agents`, `:context`, `:skills`, `:mcp`.","ref":"Opal.Config.html#module-fields"},{"type":"module","title":"Application config example - Opal.Config","doc":"config :opal,\n      data_dir: \"~/.opal\",\n      shell: :zsh,\n      default_model: {\"copilot\", \"claude-sonnet-4-5\"},\n      default_tools: [Opal.Tool.Read, Opal.Tool.Write, Opal.Tool.Edit, Opal.Tool.Shell],\n      copilot: [\n        client_id: \"Iv1.b507a08c87ecfe98\",\n        domain: \"github.com\"\n      ],\n      features: %{\n        sub_agents: %{enabled: true},\n        context: %{filenames: [\"AGENTS.md\", \"OPAL.md\"]},\n        skills: %{extra_dirs: []},\n        mcp: %{enabled: true, servers: [], config_files: []}\n      }","ref":"Opal.Config.html#module-application-config-example"},{"type":"type","title":"Opal.Config.t/0","doc":"","ref":"Opal.Config.html#t:t/0"},{"type":"function","title":"Opal.Config.auth_file/1","doc":"Path to the auth token file.","ref":"Opal.Config.html#auth_file/1"},{"type":"function","title":"Opal.Config.data_dir/1","doc":"Absolute path to the data directory.","ref":"Opal.Config.html#data_dir/1"},{"type":"function","title":"Opal.Config.default_data_dir/0","doc":"Returns the default data directory for the current platform.\n\n  - Linux:   `~/.opal`\n  - macOS:   `~/.opal`\n  - Windows: `%APPDATA%/opal` (e.g. `C:/Users/ /AppData/Roaming/opal`)\n\nUses `System.user_home!/0` on Unix and Erlang's `:filename.basedir/2`\non Windows to follow platform conventions.","ref":"Opal.Config.html#default_data_dir/0"},{"type":"function","title":"Opal.Config.ensure_dirs!/1","doc":"Ensures the data directory tree exists.","ref":"Opal.Config.html#ensure_dirs!/1"},{"type":"function","title":"Opal.Config.logs_dir/1","doc":"Path to the logs directory.","ref":"Opal.Config.html#logs_dir/1"},{"type":"function","title":"Opal.Config.new/1","doc":"Builds a config struct from Application env + optional session overrides.\n\nSession overrides are a map (or keyword list) whose keys match the struct\nfields. Unknown keys are ignored.\n\n    iex> Opal.Config.new(%{shell: :zsh, data_dir: \"/tmp/opal\"})\n    %Opal.Config{shell: :zsh, data_dir: \"/tmp/opal\", ...}","ref":"Opal.Config.html#new/1"},{"type":"function","title":"Opal.Config.sessions_dir/1","doc":"Path to sessions storage directory.","ref":"Opal.Config.html#sessions_dir/1"},{"type":"module","title":"Opal.Events","doc":"Registry-based publish/subscribe for session events.\n\nProvides a lightweight pubsub mechanism built on `Registry` with `:duplicate`\nkeys, allowing multiple processes to subscribe to events from the same session.\n\nThe backing registry (`Opal.Events.Registry`) must be started as part of the\napplication supervision tree.","ref":"Opal.Events.html"},{"type":"module","title":"Usage - Opal.Events","doc":"# In a subscriber process:\n    Opal.Events.subscribe(\"session-123\")\n\n    # Receive events:\n    receive do\n      {:opal_event, \"session-123\", event} -> handle(event)\n    end\n\n    # In the session process:\n    Opal.Events.broadcast(\"session-123\", {:token, \"hello\"})","ref":"Opal.Events.html#module-usage"},{"type":"function","title":"Opal.Events.broadcast/2","doc":"Broadcasts an event to all processes subscribed to the given session ID,\nplus any processes subscribed to the `:all` wildcard.\n\nEach subscriber receives `{:opal_event, session_id, event}`.","ref":"Opal.Events.html#broadcast/2"},{"type":"function","title":"Opal.Events.subscribe/1","doc":"Subscribes the calling process to events for the given session ID.\n\nThe process will receive messages in the form `{:opal_event, session_id, event}`.\nMultiple processes can subscribe to the same session ID.","ref":"Opal.Events.html#subscribe/1"},{"type":"function","title":"Opal.Events.subscribe_all/0","doc":"Subscribes the calling process to events from **all** sessions.\n\nThe process receives the same `{:opal_event, session_id, event}` tuples\nregardless of which session emitted them. Useful for inspectors and\ndebugging tools.","ref":"Opal.Events.html#subscribe_all/0"},{"type":"function","title":"Opal.Events.unsubscribe/1","doc":"Unsubscribes the calling process from events for the given session ID.","ref":"Opal.Events.html#unsubscribe/1"},{"type":"function","title":"Opal.Events.unsubscribe_all/0","doc":"Unsubscribes the calling process from the wildcard subscription.","ref":"Opal.Events.html#unsubscribe_all/0"},{"type":"module","title":"Opal.Model","doc":"A struct representing model configuration for an agent session.\n\nEncapsulates the provider, model identifier, and optional thinking level\nused when making requests to a language model API.","ref":"Opal.Model.html"},{"type":"module","title":"Examples - Opal.Model","doc":"iex> Opal.Model.new(:copilot, \"claude-sonnet-4-5\")\n    %Opal.Model{provider: :copilot, id: \"claude-sonnet-4-5\", thinking_level: :off}\n\n    iex> Opal.Model.new(:copilot, \"claude-sonnet-4-5\", thinking_level: :high)\n    %Opal.Model{provider: :copilot, id: \"claude-sonnet-4-5\", thinking_level: :high}","ref":"Opal.Model.html#module-examples"},{"type":"type","title":"Opal.Model.t/0","doc":"","ref":"Opal.Model.html#t:t/0"},{"type":"type","title":"Opal.Model.thinking_level/0","doc":"","ref":"Opal.Model.html#t:thinking_level/0"},{"type":"function","title":"Opal.Model.new/3","doc":"Creates a new model configuration.","ref":"Opal.Model.html#new/3"},{"type":"function","title":"Parameters - Opal.Model.new/3","doc":"* `provider` — the provider atom (e.g. `:copilot`)\n  * `id` — the model identifier string (e.g. `\"claude-sonnet-4-5\"`)\n  * `opts` — optional keyword list:\n    * `:thinking_level` — one of `:off`, `:low`, `:medium`, `:high` (default: `:off`)","ref":"Opal.Model.html#new/3-parameters"},{"type":"function","title":"Examples - Opal.Model.new/3","doc":"iex> Opal.Model.new(:copilot, \"claude-sonnet-4-5\")\n    %Opal.Model{provider: :copilot, id: \"claude-sonnet-4-5\", thinking_level: :off}","ref":"Opal.Model.html#new/3-examples"},{"type":"module","title":"Opal.Session","doc":"GenServer managing a conversation tree with branching and persistence.\n\nEach message is stored in an ETS table keyed by its ID, with a parent_id\nforming a tree structure. A `current_id` pointer tracks the active leaf,\nenabling branching by rewinding to any past message.","ref":"Opal.Session.html"},{"type":"module","title":"Usage - Opal.Session","doc":"{:ok, session} = Opal.Session.start_link(session_id: \"abc\")\n    :ok = Opal.Session.append(session, message)\n    path = Opal.Session.get_path(session)\n    tree = Opal.Session.get_tree(session)\n    :ok = Opal.Session.branch(session, some_message_id)\n    :ok = Opal.Session.save(session, \"/path/to/sessions\")","ref":"Opal.Session.html#module-usage"},{"type":"function","title":"Opal.Session.all_messages/1","doc":"Returns all messages in the session (unordered).","ref":"Opal.Session.html#all_messages/1"},{"type":"function","title":"Opal.Session.append/2","doc":"Appends a message to the session tree.\n\nThe message's `parent_id` is set to the current leaf. After appending,\n`current_id` advances to this new message.","ref":"Opal.Session.html#append/2"},{"type":"function","title":"Opal.Session.append_many/2","doc":"Appends multiple messages to the session tree in order.\n\nEach message's parent_id is set to the previous message's id\n(or the current leaf for the first one).","ref":"Opal.Session.html#append_many/2"},{"type":"function","title":"Opal.Session.branch/2","doc":"Branches the conversation by setting the current pointer to the given message ID.\n\nAll subsequent `append/2` calls will build from this point, creating a new branch.\nReturns `:ok` if the message exists, `{:error, :not_found}` otherwise.","ref":"Opal.Session.html#branch/2"},{"type":"function","title":"Opal.Session.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Opal.Session.html#child_spec/1"},{"type":"function","title":"Opal.Session.current_id/1","doc":"Returns the current leaf message ID, or nil if empty.","ref":"Opal.Session.html#current_id/1"},{"type":"function","title":"Opal.Session.get_message/2","doc":"Returns the message with the given ID, or nil.","ref":"Opal.Session.html#get_message/2"},{"type":"function","title":"Opal.Session.get_metadata/2","doc":"Gets a metadata value by key.","ref":"Opal.Session.html#get_metadata/2"},{"type":"function","title":"Opal.Session.get_path/1","doc":"Returns the path from root to the current leaf as a list of messages.","ref":"Opal.Session.html#get_path/1"},{"type":"function","title":"Opal.Session.get_tree/1","doc":"Returns the full conversation tree as a nested structure.\n\nEach node is `%{message: msg, children: [nodes...]}`.","ref":"Opal.Session.html#get_tree/1"},{"type":"function","title":"Opal.Session.list_sessions/1","doc":"Lists saved session files in a directory.\n\nReturns a list of `%{id: session_id, path: file_path, modified: DateTime.t()}`.","ref":"Opal.Session.html#list_sessions/1"},{"type":"function","title":"Opal.Session.load/2","doc":"Loads a saved session from a JSONL file into a running Session process.","ref":"Opal.Session.html#load/2"},{"type":"function","title":"Opal.Session.replace_path_segment/3","doc":"Replaces a range of messages in the path with a summary message.\n\nUsed by compaction to collapse older messages while preserving the tree.","ref":"Opal.Session.html#replace_path_segment/3"},{"type":"function","title":"Opal.Session.save/2","doc":"Persists the session to disk as an ETF file.","ref":"Opal.Session.html#save/2"},{"type":"function","title":"Opal.Session.session_id/1","doc":"Returns the session ID.","ref":"Opal.Session.html#session_id/1"},{"type":"function","title":"Opal.Session.set_metadata/3","doc":"Sets a metadata key-value pair.","ref":"Opal.Session.html#set_metadata/3"},{"type":"function","title":"Opal.Session.start_link/1","doc":"Starts the session GenServer.","ref":"Opal.Session.html#start_link/1"},{"type":"module","title":"Opal.RPC","doc":"JSON-RPC 2.0 encoding/decoding. Transport-agnostic.\n\nUsed by `Opal.RPC.Stdio` today; could be used by a WebSocket or HTTP\ntransport later. All functions are stateless — pure encode/decode.","ref":"Opal.RPC.html"},{"type":"module","title":"Wire Format - Opal.RPC","doc":"Messages are JSON objects conforming to the\n[JSON-RPC 2.0 spec](https://www.jsonrpc.org/specification).","ref":"Opal.RPC.html#module-wire-format"},{"type":"module","title":"Message Types - Opal.RPC","doc":"* **Request** — `{jsonrpc, id, method, params}` — expects a response\n  * **Response** — `{jsonrpc, id, result}` — success reply\n  * **Error Response** — `{jsonrpc, id, error}` — failure reply\n  * **Notification** — `{jsonrpc, method, params}` — fire-and-forget (no `id`)","ref":"Opal.RPC.html#module-message-types"},{"type":"module","title":"Error Codes - Opal.RPC","doc":"Standard JSON-RPC 2.0 error codes:\n\n  | Code    | Constant           | Meaning                |\n  | ------- | ------------------ | ---------------------- |\n  | -32700  | `parse_error`      | Invalid JSON           |\n  | -32600  | `invalid_request`  | Not a valid request    |\n  | -32601  | `method_not_found` | Method does not exist  |\n  | -32602  | `invalid_params`   | Invalid method params  |\n  | -32603  | `internal_error`   | Internal server error  |","ref":"Opal.RPC.html#module-error-codes"},{"type":"type","title":"Opal.RPC.decoded/0","doc":"","ref":"Opal.RPC.html#t:decoded/0"},{"type":"type","title":"Opal.RPC.error/0","doc":"","ref":"Opal.RPC.html#t:error/0"},{"type":"type","title":"Opal.RPC.error_response/0","doc":"","ref":"Opal.RPC.html#t:error_response/0"},{"type":"type","title":"Opal.RPC.id/0","doc":"","ref":"Opal.RPC.html#t:id/0"},{"type":"type","title":"Opal.RPC.message/0","doc":"","ref":"Opal.RPC.html#t:message/0"},{"type":"type","title":"Opal.RPC.notification/0","doc":"","ref":"Opal.RPC.html#t:notification/0"},{"type":"type","title":"Opal.RPC.params/0","doc":"","ref":"Opal.RPC.html#t:params/0"},{"type":"type","title":"Opal.RPC.request/0","doc":"","ref":"Opal.RPC.html#t:request/0"},{"type":"type","title":"Opal.RPC.response/0","doc":"","ref":"Opal.RPC.html#t:response/0"},{"type":"function","title":"Opal.RPC.decode/1","doc":"Decodes a JSON string into a tagged message tuple.\n\nReturns one of:\n\n  * `{:request, id, method, params}` — client or server request\n  * `{:response, id, result}` — success response\n  * `{:error_response, id, error_map}` — error response\n  * `{:notification, method, params}` — fire-and-forget\n  * `{:error, :parse_error}` — invalid JSON\n  * `{:error, :invalid_request}` — valid JSON but not JSON-RPC 2.0","ref":"Opal.RPC.html#decode/1"},{"type":"function","title":"Examples - Opal.RPC.decode/1","doc":"iex> Opal.RPC.decode(~s({\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"ping\",\"params\":{}}))\n    {:request, 1, \"ping\", %{}}\n\n    iex> Opal.RPC.decode(~s({\"jsonrpc\":\"2.0\",\"method\":\"notify\",\"params\":{}}))\n    {:notification, \"notify\", %{}}\n\n    iex> Opal.RPC.decode(\"not json\")\n    {:error, :parse_error}","ref":"Opal.RPC.html#decode/1-examples"},{"type":"function","title":"Opal.RPC.encode_error/4","doc":"Encodes a JSON-RPC 2.0 error response.","ref":"Opal.RPC.html#encode_error/4"},{"type":"function","title":"Examples - Opal.RPC.encode_error/4","doc":"iex> Opal.RPC.encode_error(1, -32601, \"Method not found\")\n    ~s({\"error\":{\"code\":-32601,\"message\":\"Method not found\"},\"id\":1,\"jsonrpc\":\"2.0\"})","ref":"Opal.RPC.html#encode_error/4-examples"},{"type":"function","title":"Opal.RPC.encode_notification/2","doc":"Encodes a JSON-RPC 2.0 notification (no `id`).","ref":"Opal.RPC.html#encode_notification/2"},{"type":"function","title":"Examples - Opal.RPC.encode_notification/2","doc":"iex> Opal.RPC.encode_notification(\"agent/event\", %{type: \"token\"})\n    ~s({\"jsonrpc\":\"2.0\",\"method\":\"agent/event\",\"params\":{\"type\":\"token\"}})","ref":"Opal.RPC.html#encode_notification/2-examples"},{"type":"function","title":"Opal.RPC.encode_request/3","doc":"Encodes a JSON-RPC 2.0 request.","ref":"Opal.RPC.html#encode_request/3"},{"type":"function","title":"Examples - Opal.RPC.encode_request/3","doc":"iex> Opal.RPC.encode_request(1, \"agent/prompt\", %{text: \"hello\"})\n    ~s({\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"agent/prompt\",\"params\":{\"text\":\"hello\"}})","ref":"Opal.RPC.html#encode_request/3-examples"},{"type":"function","title":"Opal.RPC.encode_response/2","doc":"Encodes a JSON-RPC 2.0 success response.","ref":"Opal.RPC.html#encode_response/2"},{"type":"function","title":"Examples - Opal.RPC.encode_response/2","doc":"iex> Opal.RPC.encode_response(1, %{ok: true})\n    ~s({\"id\":1,\"jsonrpc\":\"2.0\",\"result\":{\"ok\":true}})","ref":"Opal.RPC.html#encode_response/2-examples"},{"type":"function","title":"Opal.RPC.internal_error/0","doc":"Internal error code (-32603).","ref":"Opal.RPC.html#internal_error/0"},{"type":"function","title":"Opal.RPC.invalid_params/0","doc":"Invalid params code (-32602).","ref":"Opal.RPC.html#invalid_params/0"},{"type":"function","title":"Opal.RPC.invalid_request/0","doc":"Invalid request code (-32600).","ref":"Opal.RPC.html#invalid_request/0"},{"type":"function","title":"Opal.RPC.method_not_found/0","doc":"Method not found code (-32601).","ref":"Opal.RPC.html#method_not_found/0"},{"type":"function","title":"Opal.RPC.parse_error/0","doc":"Parse error code (-32700).","ref":"Opal.RPC.html#parse_error/0"},{"type":"module","title":"Opal.RPC.Handler","doc":"Dispatches JSON-RPC methods to Opal library functions.\n\nPure dispatch layer — receives a method name and params map, calls into\nthe Opal public API, and returns a result tuple. Has no transport awareness\nand no side effects beyond the Opal calls themselves.\n\nThe set of supported methods, their params, and result shapes are\ndeclared in `Opal.RPC.Protocol` — the single source of truth for\nthe Opal RPC specification.","ref":"Opal.RPC.Handler.html"},{"type":"module","title":"Return Values - Opal.RPC.Handler","doc":"* `{:ok, result}` — success, `result` is serialized as `\"result\"` in the response\n  * `{:error, code, message, data}` — failure, serialized as a JSON-RPC error","ref":"Opal.RPC.Handler.html#module-return-values"},{"type":"type","title":"Opal.RPC.Handler.result/0","doc":"","ref":"Opal.RPC.Handler.html#t:result/0"},{"type":"function","title":"Opal.RPC.Handler.handle/2","doc":"Dispatches a JSON-RPC method call to the appropriate Opal API function.\n\nOnly methods declared in `Opal.RPC.Protocol.methods/0` are handled.\nSee `Opal.RPC.Protocol` for the full protocol specification.","ref":"Opal.RPC.Handler.html#handle/2"},{"type":"module","title":"Opal.RPC.Protocol","doc":"Declarative protocol specification for the Opal JSON-RPC 2.0 API.\n\nThis module is the **single source of truth** for the Opal RPC protocol.\nEvery method, notification, event type, and server→client request is\ndefined here as structured data. The handler dispatches only methods\nlisted here; the stdio transport serializes only event types listed here.","ref":"Opal.RPC.Protocol.html"},{"type":"module","title":"Design Goals - Opal.RPC.Protocol","doc":"* **Machine-readable** — the definitions are plain Elixir data structures\n    that a code generator can traverse to produce TypeScript types, JSON\n    Schema, or documentation.\n  * **Self-documenting** — each definition carries its own description,\n    required/optional params, and result shape.\n  * **Single source of truth** — `Opal.RPC.Handler` and `Opal.RPC.Stdio`\n    reference these definitions rather than embedding protocol knowledge.","ref":"Opal.RPC.Protocol.html#module-design-goals"},{"type":"module","title":"Usage - Opal.RPC.Protocol","doc":"# List all method names\n    Opal.RPC.Protocol.method_names()\n\n    # Get a specific method definition\n    Opal.RPC.Protocol.method(\"agent/prompt\")\n\n    # List all event types\n    Opal.RPC.Protocol.event_types()\n\n    # List server→client request methods\n    Opal.RPC.Protocol.server_request_names()\n\n    # Full spec for export/codegen\n    Opal.RPC.Protocol.spec()","ref":"Opal.RPC.Protocol.html#module-usage"},{"type":"type","title":"Opal.RPC.Protocol.event_type_def/0","doc":"A server→client notification event type.","ref":"Opal.RPC.Protocol.html#t:event_type_def/0"},{"type":"type","title":"Opal.RPC.Protocol.method_def/0","doc":"A client→server method definition.","ref":"Opal.RPC.Protocol.html#t:method_def/0"},{"type":"type","title":"Opal.RPC.Protocol.param/0","doc":"A parameter field definition.","ref":"Opal.RPC.Protocol.html#t:param/0"},{"type":"type","title":"Opal.RPC.Protocol.result_field/0","doc":"A result field definition.","ref":"Opal.RPC.Protocol.html#t:result_field/0"},{"type":"type","title":"Opal.RPC.Protocol.server_request_def/0","doc":"A server→client request definition.","ref":"Opal.RPC.Protocol.html#t:server_request_def/0"},{"type":"function","title":"Opal.RPC.Protocol.event_type/1","doc":"Returns the definition for a specific event type, or nil.","ref":"Opal.RPC.Protocol.html#event_type/1"},{"type":"function","title":"Opal.RPC.Protocol.event_type_names/0","doc":"Returns all event type name strings.","ref":"Opal.RPC.Protocol.html#event_type_names/0"},{"type":"function","title":"Opal.RPC.Protocol.event_types/0","doc":"Returns all event type definitions.","ref":"Opal.RPC.Protocol.html#event_types/0"},{"type":"function","title":"Opal.RPC.Protocol.known_event_type?/1","doc":"Returns true if the given event type is a known event.","ref":"Opal.RPC.Protocol.html#known_event_type?/1"},{"type":"function","title":"Opal.RPC.Protocol.known_method?/1","doc":"Returns true if the given method name is a known client→server method.","ref":"Opal.RPC.Protocol.html#known_method?/1"},{"type":"function","title":"Opal.RPC.Protocol.method/1","doc":"Returns the definition for a specific method, or nil.","ref":"Opal.RPC.Protocol.html#method/1"},{"type":"function","title":"Opal.RPC.Protocol.method_names/0","doc":"Returns all client→server method name strings.","ref":"Opal.RPC.Protocol.html#method_names/0"},{"type":"function","title":"Opal.RPC.Protocol.methods/0","doc":"Returns all client→server method definitions.","ref":"Opal.RPC.Protocol.html#methods/0"},{"type":"function","title":"Opal.RPC.Protocol.notification_method/0","doc":"The JSON-RPC method name used for all streaming event notifications.","ref":"Opal.RPC.Protocol.html#notification_method/0"},{"type":"function","title":"Opal.RPC.Protocol.required_params/1","doc":"Returns the required param names for a given method.","ref":"Opal.RPC.Protocol.html#required_params/1"},{"type":"function","title":"Opal.RPC.Protocol.server_request/1","doc":"Returns the definition for a specific server request, or nil.","ref":"Opal.RPC.Protocol.html#server_request/1"},{"type":"function","title":"Opal.RPC.Protocol.server_request_names/0","doc":"Returns all server→client request method name strings.","ref":"Opal.RPC.Protocol.html#server_request_names/0"},{"type":"function","title":"Opal.RPC.Protocol.server_requests/0","doc":"Returns all server→client request definitions.","ref":"Opal.RPC.Protocol.html#server_requests/0"},{"type":"function","title":"Opal.RPC.Protocol.spec/0","doc":"Returns the complete protocol specification as a single map.\n\nUseful for serialization, export, or code generation.","ref":"Opal.RPC.Protocol.html#spec/0"},{"type":"function","title":"Structure - Opal.RPC.Protocol.spec/0","doc":"%{\n      version: \"0.1.0\",\n      transport: \"stdio\",\n      framing: \"newline-delimited JSON\",\n      methods: [...],\n      server_requests: [...],\n      event_types: [...],\n      notification_method: \"agent/event\"\n    }","ref":"Opal.RPC.Protocol.html#spec/0-structure"},{"type":"module","title":"Opal.RPC.Stdio","doc":"JSON-RPC 2.0 transport over stdin/stdout.\n\nReads newline-delimited JSON from stdin, dispatches via `Opal.RPC.Handler`,\nwrites responses to stdout. Subscribes to `Opal.Events` and emits\nnotifications for streaming events.\n\nThe set of supported methods, event types, and server→client requests\nare declared in `Opal.RPC.Protocol` — the single source of truth for\nthe Opal RPC specification.","ref":"Opal.RPC.Stdio.html"},{"type":"module","title":"Server → Client Requests - Opal.RPC.Stdio","doc":"The server can send requests to the client (e.g., for user confirmations)\nvia `request_client/3`. The response is delivered asynchronously when the\nclient sends back a JSON-RPC response with the matching `id`.","ref":"Opal.RPC.Stdio.html#module-server-client-requests"},{"type":"module","title":"Wire Format - Opal.RPC.Stdio","doc":"Each message is a single JSON object followed by `\\n` on stdin/stdout.\nThis matches the MCP stdio transport convention. All logging goes to stderr.","ref":"Opal.RPC.Stdio.html#module-wire-format"},{"type":"function","title":"Opal.RPC.Stdio.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Opal.RPC.Stdio.html#child_spec/1"},{"type":"function","title":"Opal.RPC.Stdio.notify/2","doc":"Sends a notification to the connected client.\n\nFire-and-forget — no response expected.","ref":"Opal.RPC.Stdio.html#notify/2"},{"type":"function","title":"Opal.RPC.Stdio.request_client/3","doc":"Sends a request to the connected client and waits for a response.\n\nUsed for server→client requests like user confirmations and input prompts.\nThe request ID is auto-generated with the `s2c-` prefix.","ref":"Opal.RPC.Stdio.html#request_client/3"},{"type":"function","title":"Examples - Opal.RPC.Stdio.request_client/3","doc":"{:ok, result} = Opal.RPC.Stdio.request_client(\"client/confirm\", %{\n      session_id: \"abc123\",\n      title: \"Execute shell command?\",\n      message: \"rm -rf node_modules/\",\n      actions: [\"allow\", \"deny\", \"allow_session\"]\n    })","ref":"Opal.RPC.Stdio.html#request_client/3-examples"},{"type":"function","title":"Opal.RPC.Stdio.start_link/1","doc":"Starts the stdio transport GenServer.","ref":"Opal.RPC.Stdio.html#start_link/1"},{"type":"module","title":"Opal.Auth","doc":"Manages GitHub Copilot OAuth credentials.\n\nImplements the device-code OAuth flow for GitHub Copilot:\n\n1. Start device flow → get `device_code`, `user_code`, `verification_uri`\n2. User visits URL and enters code\n3. Poll until token is granted\n4. Exchange GitHub access token for Copilot API token\n5. Persist tokens to disk for reuse across sessions\n\nConfiguration (client ID, domain) comes from `Opal.Config`.\nTokens are stored at `Opal.Config.auth_file/0` (default: `~/.opal/auth.json`).","ref":"Opal.Auth.html"},{"type":"function","title":"Opal.Auth.base_url/1","doc":"Extracts the API base URL from a Copilot token response.\n\nParses the `endpoints.api` field or falls back to constructing\nthe URL from the token's `proxy-ep` annotation.","ref":"Opal.Auth.html#base_url/1"},{"type":"function","title":"Opal.Auth.exchange_copilot_token/2","doc":"Exchanges a GitHub access token for a Copilot API token.\n\nCalls `https://api.{domain}/copilot_internal/v2/token` and returns\nthe Copilot token response containing `token`, `expires_at`, and\nendpoint information.","ref":"Opal.Auth.html#exchange_copilot_token/2"},{"type":"function","title":"Opal.Auth.get_token/0","doc":"Gets a valid Copilot token, refreshing if expired.\n\nLoads the token from disk, checks expiry, and re-exchanges the GitHub\ntoken for a fresh Copilot token if needed. Returns `{:error, :not_authenticated}`\nif no token is stored on disk.","ref":"Opal.Auth.html#get_token/0"},{"type":"function","title":"Opal.Auth.list_models/0","doc":"Returns the list of known models available via GitHub Copilot.\n\nThis is a curated list since the Copilot API does not expose\na model listing endpoint.","ref":"Opal.Auth.html#list_models/0"},{"type":"function","title":"Opal.Auth.load_token/0","doc":"Loads token data from disk.\n\nReturns `{:ok, token_data}` or `{:error, reason}` if the file\ndoesn't exist or can't be parsed.","ref":"Opal.Auth.html#load_token/0"},{"type":"function","title":"Opal.Auth.poll_for_token/3","doc":"Polls GitHub for an access token after the user authorizes the device.\n\nHandles `\"authorization_pending\"` by retrying after `interval_ms` and\n`\"slow_down\"` by increasing the interval by 5 seconds.","ref":"Opal.Auth.html#poll_for_token/3"},{"type":"function","title":"Parameters - Opal.Auth.poll_for_token/3","doc":"* `domain` — GitHub domain\n  * `device_code` — the device code from `start_device_flow/1`\n  * `interval_ms` — polling interval in milliseconds","ref":"Opal.Auth.html#poll_for_token/3-parameters"},{"type":"function","title":"Opal.Auth.save_token/1","doc":"Persists token data to disk as JSON.\n\nStores in the OS user-data directory under `opal/token.json`.","ref":"Opal.Auth.html#save_token/1"},{"type":"function","title":"Opal.Auth.start_device_flow/1","doc":"Starts the GitHub device-code OAuth flow.\n\nPOSTs to `https://{domain}/login/device/code` and returns the response body\ncontaining `device_code`, `user_code`, and `verification_uri`.","ref":"Opal.Auth.html#start_device_flow/1"},{"type":"function","title":"Parameters - Opal.Auth.start_device_flow/1","doc":"* `domain` — GitHub domain (default: `\"github.com\"`)","ref":"Opal.Auth.html#start_device_flow/1-parameters"},{"type":"function","title":"Opal.Auth.token_expired?/1","doc":"Checks whether a token has expired based on its `expires_at` field.\n\nReturns `true` if the token is expired or will expire within 5 minutes.","ref":"Opal.Auth.html#token_expired?/1"},{"type":"behaviour","title":"Opal.Provider","doc":"Behaviour for LLM provider implementations.\n\nEach provider must implement streaming, SSE event parsing, and conversion\nof internal message/tool representations to the provider's wire format.","ref":"Opal.Provider.html"},{"type":"type","title":"Opal.Provider.stream_event/0","doc":"","ref":"Opal.Provider.html#t:stream_event/0"},{"type":"callback","title":"Opal.Provider.convert_messages/2","doc":"Converts internal `Opal.Message` structs to the provider's wire format.","ref":"Opal.Provider.html#c:convert_messages/2"},{"type":"callback","title":"Opal.Provider.convert_tools/1","doc":"Converts tool modules implementing `Opal.Tool` to the provider's wire format.","ref":"Opal.Provider.html#c:convert_tools/1"},{"type":"callback","title":"Opal.Provider.parse_stream_event/1","doc":"Parses a raw SSE data line into a list of stream events.\n\nReturns an empty list for events that should be ignored.","ref":"Opal.Provider.html#c:parse_stream_event/1"},{"type":"callback","title":"Opal.Provider.stream/4","doc":"Initiates a streaming request to the LLM provider.\n\nReturns `{:ok, resp}` where `resp` can be used with `Req.parse_message/2`\nto iterate over SSE chunks arriving in the calling process's mailbox.","ref":"Opal.Provider.html#c:stream/4"},{"type":"module","title":"Opal.Provider.Copilot","doc":"GitHub Copilot provider implementation.\n\nSupports two OpenAI API variants based on the model:\n\n- **Chat Completions** (`/v1/chat/completions`) — used by most models\n  (Claude, GPT-4o, Gemini, o3/o4, etc.)\n- **Responses API** (`/v1/responses`) — used by GPT-5 family models\n\nStreams responses via SSE into the calling process's mailbox using\n`Req.post/2` with `into: :self`. The caller (typically `Opal.Agent`)\niterates chunks with `Req.parse_message/2`.","ref":"Opal.Provider.Copilot.html"},{"type":"function","title":"Opal.Provider.Copilot.convert_tools/1","doc":"Converts tool modules to the OpenAI function-calling format.\nWorks for both Chat Completions and Responses API.","ref":"Opal.Provider.Copilot.html#convert_tools/1"},{"type":"function","title":"Opal.Provider.Copilot.parse_stream_event/1","doc":"Parses a raw SSE JSON line into stream event tuples.\n\nHandles both Chat Completions format (`choices[0].delta`) and\nResponses API format (`response.output_text.delta`, etc.).","ref":"Opal.Provider.Copilot.html#parse_stream_event/1"},{"type":"module","title":"Opal.Skill","doc":"Parses and validates Agent Skills following the [agentskills.io specification](https://agentskills.io/specification).\n\nA skill is a directory containing a `SKILL.md` file with YAML frontmatter\n(metadata) and a Markdown body (instructions). Skills support progressive\ndisclosure: metadata is loaded at discovery time, and full instructions are\nloaded on demand when the agent activates the skill.","ref":"Opal.Skill.html"},{"type":"module","title":"SKILL.md Format - Opal.Skill","doc":"---\n    name: my-skill\n    description: What this skill does and when to use it.\n    ---\n\n    # Instructions\n\n    Step-by-step instructions for the agent...","ref":"Opal.Skill.html#module-skill-md-format"},{"type":"module","title":"Required Fields - Opal.Skill","doc":"* `name` — 1–64 characters, lowercase alphanumeric and hyphens only.\n    Must not start/end with `-` or contain `--`. Must match the parent\n    directory name.\n\n  * `description` — 1–1024 characters describing what the skill does\n    and when to use it.","ref":"Opal.Skill.html#module-required-fields"},{"type":"module","title":"Optional Fields - Opal.Skill","doc":"* `license` — License name or reference to a bundled file.\n  * `compatibility` — 1–500 characters indicating environment requirements.\n  * `metadata` — Arbitrary key-value map for additional properties.\n  * `allowed-tools` — Space-delimited list of pre-approved tools (experimental).","ref":"Opal.Skill.html#module-optional-fields"},{"type":"module","title":"Usage - Opal.Skill","doc":"# Parse a single SKILL.md file\n    {:ok, skill} = Opal.Skill.parse_file(\"/path/to/my-skill/SKILL.md\")\n\n    # Parse raw markdown content\n    {:ok, skill} = Opal.Skill.parse(\"---\\nname: my-skill\\n...\")\n\n    # Validate a parsed skill against its directory\n    :ok = Opal.Skill.validate(skill, dir_name: \"my-skill\")","ref":"Opal.Skill.html#module-usage"},{"type":"type","title":"Opal.Skill.t/0","doc":"","ref":"Opal.Skill.html#t:t/0"},{"type":"function","title":"Opal.Skill.parse/1","doc":"Parses raw SKILL.md content (YAML frontmatter + Markdown body).\n\nThe content must begin with `---` followed by YAML frontmatter and\na closing `---`. Everything after the closing delimiter is treated\nas the Markdown instructions body.\n\nReturns `{:ok, skill}` or `{:error, reason}`.","ref":"Opal.Skill.html#parse/1"},{"type":"function","title":"Examples - Opal.Skill.parse/1","doc":"iex> Opal.Skill.parse(\"---\\nname: test\\ndescription: A test skill.\\n---\\n# Hello\")\n    {:ok, %Opal.Skill{name: \"test\", description: \"A test skill.\", instructions: \"# Hello\"}}","ref":"Opal.Skill.html#parse/1-examples"},{"type":"function","title":"Opal.Skill.parse_file/1","doc":"Parses a `SKILL.md` file from disk.\n\nReturns `{:ok, skill}` with the full struct including `:path`, or\n`{:error, reason}` if the file cannot be read or parsed.","ref":"Opal.Skill.html#parse_file/1"},{"type":"function","title":"Opal.Skill.summary/1","doc":"Returns a short summary string for progressive disclosure.\n\nOnly includes `name` and `description` — suitable for injecting into\nthe agent's context at startup without loading full instructions.","ref":"Opal.Skill.html#summary/1"},{"type":"function","title":"Opal.Skill.validate/2","doc":"Validates a parsed skill struct.\n\nChecks all field constraints from the agentskills.io spec. Returns\n`:ok` or `{:error, reasons}` where `reasons` is a list of validation\nerror strings.","ref":"Opal.Skill.html#validate/2"},{"type":"function","title":"Options - Opal.Skill.validate/2","doc":"* `:dir_name` — if provided, validates that `skill.name` matches\n    the parent directory name.","ref":"Opal.Skill.html#validate/2-options"},{"type":"behaviour","title":"Opal.Tool","doc":"Behaviour defining the interface for agent tools.\n\nAny module implementing this behaviour can be registered as a tool\navailable to the agent during a session. Tools are invoked by the\nassistant via tool calls and must return their output as a string.","ref":"Opal.Tool.html"},{"type":"behaviour","title":"Implementing a tool - Opal.Tool","doc":"defmodule MyTool do\n      @behaviour Opal.Tool\n\n      @impl true\n      def name, do: \"my_tool\"\n\n      @impl true\n      def description, do: \"Does something useful\"\n\n      @impl true\n      def parameters do\n        %{\n          \"type\" => \"object\",\n          \"properties\" => %{\n            \"input\" => %{\"type\" => \"string\", \"description\" => \"The input value\"}\n          },\n          \"required\" => [\"input\"]\n        }\n      end\n\n      @impl true\n      def execute(%{\"input\" => input}, _context) do\n        {:ok, \"Processed: #{input}\"}\n      end\n    end","ref":"Opal.Tool.html#module-implementing-a-tool"},{"type":"callback","title":"Opal.Tool.description/0","doc":"Returns a human-readable description of what the tool does.","ref":"Opal.Tool.html#c:description/0"},{"type":"callback","title":"Opal.Tool.execute/2","doc":"Executes the tool with the given arguments and session context.","ref":"Opal.Tool.html#c:execute/2"},{"type":"callback","title":"Opal.Tool.meta/1","doc":"Returns a short, human-readable summary of a specific tool invocation.\n\nUsed by UIs to show what a tool call is doing, e.g. `\"Reading lib/opal.ex\"`.\nReceives the parsed arguments map. Falls back to the tool name if not implemented.","ref":"Opal.Tool.html#c:meta/1"},{"type":"callback","title":"Opal.Tool.name/0","doc":"Returns the tool name used in tool call messages.","ref":"Opal.Tool.html#c:name/0"},{"type":"callback","title":"Opal.Tool.parameters/0","doc":"Returns a JSON Schema map describing the tool's accepted parameters.","ref":"Opal.Tool.html#c:parameters/0"},{"type":"function","title":"Opal.Tool.meta/2","doc":"Returns the meta description for a tool invocation.\n\nCalls `tool_module.meta(args)` if defined, otherwise returns `tool_module.name()`.","ref":"Opal.Tool.html#meta/2"},{"type":"module","title":"Opal.Tool.Edit","doc":"Applies a search-and-replace edit to a file.\n\nThe old string must match exactly one location in the file. Implements\nthe `Opal.Tool` behaviour and resolves paths relative to the session's\nworking directory using `Opal.Path.safe_relative/2`.","ref":"Opal.Tool.Edit.html"},{"type":"module","title":"Opal.Tool.Read","doc":"Reads file contents, optionally returning a slice of lines.\n\nImplements the `Opal.Tool` behaviour. Resolves paths relative to the\nsession's working directory using `Opal.Path.safe_relative/2`.","ref":"Opal.Tool.Read.html"},{"type":"module","title":"Opal.Tool.Shell","doc":"Runs shell commands cross-platform with timeout support.\n\nThe shell type is configurable per session via `context.shell`:\n\n  - `:sh`         — POSIX sh (default on Unix)\n  - `:bash`       — GNU Bash\n  - `:zsh`        — Zsh\n  - `:cmd`        — cmd.exe (default on Windows)\n  - `:powershell` — PowerShell (cross-platform)\n\nThe tool name and description exposed to the LLM change to match\nthe configured shell, so the model generates appropriate commands.","ref":"Opal.Tool.Shell.html"},{"type":"type","title":"Opal.Tool.Shell.shell/0","doc":"","ref":"Opal.Tool.Shell.html#t:shell/0"},{"type":"function","title":"Opal.Tool.Shell.default_shell/0","doc":"Returns the default shell for the current platform.","ref":"Opal.Tool.Shell.html#default_shell/0"},{"type":"function","title":"Opal.Tool.Shell.description/1","doc":"Returns the tool description for the given shell type.","ref":"Opal.Tool.Shell.html#description/1"},{"type":"function","title":"Opal.Tool.Shell.name/1","doc":"Returns the tool name for the given shell type.","ref":"Opal.Tool.Shell.html#name/1"},{"type":"module","title":"Opal.Tool.SubAgent","doc":"Tool that allows an agent to spawn a sub-agent for delegated tasks.\n\nThe sub-agent runs with its own conversation loop, executes tools, and\nreturns a structured result containing the final response and a log of\nall tool calls made. Sub-agent events are forwarded to the parent session\nfor real-time observability.","ref":"Opal.Tool.SubAgent.html"},{"type":"module","title":"Depth Enforcement - Opal.Tool.SubAgent","doc":"Sub-agents are limited to one level — this tool is never included in the\nsub-agent's tool list, preventing recursive spawning.","ref":"Opal.Tool.SubAgent.html#module-depth-enforcement"},{"type":"module","title":"Tool Selection - Opal.Tool.SubAgent","doc":"The parent agent can specify a subset of its own tools by name. If omitted,\nthe sub-agent inherits all of the parent's tools (minus this one).","ref":"Opal.Tool.SubAgent.html#module-tool-selection"},{"type":"module","title":"Opal.Tool.Write","doc":"Writes content to a file, creating parent directories as needed.\n\nImplements the `Opal.Tool` behaviour. Resolves paths relative to the\nsession's working directory using `Opal.Path.safe_relative/2`.","ref":"Opal.Tool.Write.html"},{"type":"module","title":"Opal.MCP.Bridge","doc":"Bridges MCP tools into the Opal tool system.\n\nAfter Anubis clients connect and negotiate, `Bridge` queries each client\nfor its available tools and wraps them as anonymous modules that implement\nthe `Opal.Tool` behaviour interface. This lets the agent call MCP tools\nexactly like native tools — no special dispatch needed.","ref":"Opal.MCP.Bridge.html"},{"type":"module","title":"Tool naming - Opal.MCP.Bridge","doc":"MCP tools keep their original names (e.g. `get_weather`, `search_issues`).\nWhen two servers expose tools with the same name, the tool is prefixed\nwith the server name: `weather_get_weather`, `backup_get_weather`.","ref":"Opal.MCP.Bridge.html#module-tool-naming"},{"type":"function","title":"Opal.MCP.Bridge.create_tool_module/3","doc":"Creates an Opal.Tool-compatible module for an MCP tool at runtime.\n\nThe generated module implements the `Opal.Tool` behaviour callbacks\n(`name/0`, `description/0`, `parameters/0`, `execute/2`) and routes\nexecution through the Anubis client.","ref":"Opal.MCP.Bridge.html#create_tool_module/3"},{"type":"function","title":"Opal.MCP.Bridge.discover_all_tools/1","doc":"Discovers tools from all configured MCP servers.\n\nTakes a list of server config maps (each with a `:name` key) and returns\na flat list of all discovered tools across all servers.","ref":"Opal.MCP.Bridge.html#discover_all_tools/1"},{"type":"function","title":"Opal.MCP.Bridge.discover_tool_modules/2","doc":"Discovers tools from all MCP servers and returns them as runtime modules\nimplementing `Opal.Tool`.\n\nUses original tool names by default. When two servers expose tools with\nthe same name, both get prefixed with their server name to disambiguate.\n\nThe `existing_names` parameter is a `MapSet` of tool names already\nregistered (e.g. native tools), which also trigger prefixing.","ref":"Opal.MCP.Bridge.html#discover_tool_modules/2"},{"type":"function","title":"Opal.MCP.Bridge.discover_tools/1","doc":"Discovers tools from a single named MCP client and returns them as\nOpal-compatible tool maps.\n\nEach returned map has:\n  * `:name` — tool name (original, or ` _ ` on collision)\n  * `:description` — tool description from the MCP server\n  * `:parameters` — JSON Schema input schema\n  * `:server` — the MCP server name (atom)\n  * `:original_name` — the tool's original name on the MCP server\n\nReturns `[]` if the client is not connected or tool discovery fails.","ref":"Opal.MCP.Bridge.html#discover_tools/1"},{"type":"module","title":"Opal.MCP.Client","doc":"Anubis MCP client for connecting to external MCP servers.\n\nEach configured MCP server gets its own `Opal.MCP.Client` process,\nmanaged by Anubis internally. The client handles transport management,\nprotocol negotiation, and provides a clean API for tool/resource operations.","ref":"Opal.MCP.Client.html"},{"type":"module","title":"Naming - Opal.MCP.Client","doc":"Each server gets a unique client process name via `client_name/1`:\n\n    Opal.MCP.Client.client_name(:weather)\n    #=> :opal_mcp_client_weather\n\nAll API functions (`server_list_tools/1`, `server_call_tool/3`, etc.) accept\nthe server name atom and resolve the process name internally.","ref":"Opal.MCP.Client.html#module-naming"},{"type":"module","title":"Usage - Opal.MCP.Client","doc":"Typically started via `Opal.MCP.Supervisor`, not directly:\n\n    child_spec = Opal.MCP.Client.child_spec(%{\n      name: :filesystem,\n      transport: {:stdio, command: \"npx\", args: [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path\"]}\n    })","ref":"Opal.MCP.Client.html#module-usage"},{"type":"module","title":"Supported transports - Opal.MCP.Client","doc":"* `{:stdio, command: \"cmd\", args: [\"arg1\"]}` — local process via stdin/stdout\n  * `{:streamable_http, url: \"http://...\"}` — HTTP Stream transport\n  * `{:sse, url: \"http://...\"}` — Server-Sent Events (legacy)","ref":"Opal.MCP.Client.html#module-supported-transports"},{"type":"function","title":"Opal.MCP.Client.add_root/3","doc":"Adds a root directory or resource.","ref":"Opal.MCP.Client.html#add_root/3"},{"type":"function","title":"Examples - Opal.MCP.Client.add_root/3","doc":":ok = MyClient.add_root(\"file:///project\", \"My Project\")","ref":"Opal.MCP.Client.html#add_root/3-examples"},{"type":"function","title":"Opal.MCP.Client.await_ready/2","doc":"Waits for the named MCP server to complete initialization.\n\nPolls `get_server_capabilities` until non-nil or the timeout expires.\nReturns `:ok` when ready, `{:error, :timeout}` if the server doesn't\ninitialize in time.","ref":"Opal.MCP.Client.html#await_ready/2"},{"type":"function","title":"Opal.MCP.Client.call_tool/3","doc":"Calls a specific tool by name with optional arguments.","ref":"Opal.MCP.Client.html#call_tool/3"},{"type":"function","title":"Examples - Opal.MCP.Client.call_tool/3","doc":"{:ok, result} = MyClient.call_tool(\"search\", %{query: \"elixir\"})","ref":"Opal.MCP.Client.html#call_tool/3-examples"},{"type":"function","title":"Opal.MCP.Client.cancel_all_requests/2","doc":"Cancels all pending requests.","ref":"Opal.MCP.Client.html#cancel_all_requests/2"},{"type":"function","title":"Examples - Opal.MCP.Client.cancel_all_requests/2","doc":":ok = MyClient.cancel_all_requests(\"shutting_down\")","ref":"Opal.MCP.Client.html#cancel_all_requests/2-examples"},{"type":"function","title":"Opal.MCP.Client.cancel_request/3","doc":"Cancels a specific request by ID.","ref":"Opal.MCP.Client.html#cancel_request/3"},{"type":"function","title":"Examples - Opal.MCP.Client.cancel_request/3","doc":":ok = MyClient.cancel_request(\"req-123\")","ref":"Opal.MCP.Client.html#cancel_request/3-examples"},{"type":"function","title":"Opal.MCP.Client.child_spec/1","doc":"Builds a child spec for a named MCP server connection.","ref":"Opal.MCP.Client.html#child_spec/1"},{"type":"function","title":"Parameters - Opal.MCP.Client.child_spec/1","doc":"* `server_config` — a map with `:name` (atom) and `:transport` (tuple) keys\n\nThe child spec uses `{:mcp, server_name}` as its id for supervisor\ndeduplication and introspection. Each server's client GenServer is\nregistered under `{:opal_mcp, server_name}` for unique addressing.","ref":"Opal.MCP.Client.html#child_spec/1-parameters"},{"type":"function","title":"Opal.MCP.Client.clear_roots/1","doc":"Clears all registered roots.","ref":"Opal.MCP.Client.html#clear_roots/1"},{"type":"function","title":"Examples - Opal.MCP.Client.clear_roots/1","doc":":ok = MyClient.clear_roots()","ref":"Opal.MCP.Client.html#clear_roots/1-examples"},{"type":"function","title":"Opal.MCP.Client.client_name/1","doc":"Returns the registered process name for an MCP server's client GenServer.\n\nUses a `{:via, Registry, ...}` tuple to avoid dynamic atom generation.","ref":"Opal.MCP.Client.html#client_name/1"},{"type":"function","title":"Opal.MCP.Client.close/0","doc":"Closes the client connection gracefully.","ref":"Opal.MCP.Client.html#close/0"},{"type":"function","title":"Examples - Opal.MCP.Client.close/0","doc":":ok = MyClient.close()","ref":"Opal.MCP.Client.html#close/0-examples"},{"type":"function","title":"Opal.MCP.Client.complete/3","doc":"Completes a partial result reference.","ref":"Opal.MCP.Client.html#complete/3"},{"type":"function","title":"Examples - Opal.MCP.Client.complete/3","doc":"{:ok, result} = MyClient.complete(ref, \"completed\")","ref":"Opal.MCP.Client.html#complete/3-examples"},{"type":"function","title":"Opal.MCP.Client.get_prompt/3","doc":"Gets a specific prompt by name with optional arguments.","ref":"Opal.MCP.Client.html#get_prompt/3"},{"type":"function","title":"Examples - Opal.MCP.Client.get_prompt/3","doc":"{:ok, prompt} = MyClient.get_prompt(\"greeting\", %{name: \"Alice\"})","ref":"Opal.MCP.Client.html#get_prompt/3-examples"},{"type":"function","title":"Opal.MCP.Client.get_server_capabilities/1","doc":"Gets the server's declared capabilities.","ref":"Opal.MCP.Client.html#get_server_capabilities/1"},{"type":"function","title":"Examples - Opal.MCP.Client.get_server_capabilities/1","doc":"{:ok, capabilities} = MyClient.get_server_capabilities()","ref":"Opal.MCP.Client.html#get_server_capabilities/1-examples"},{"type":"function","title":"Opal.MCP.Client.get_server_info/1","doc":"Gets the server information including name and version.","ref":"Opal.MCP.Client.html#get_server_info/1"},{"type":"function","title":"Examples - Opal.MCP.Client.get_server_info/1","doc":"{:ok, info} = MyClient.get_server_info()","ref":"Opal.MCP.Client.html#get_server_info/1-examples"},{"type":"function","title":"Opal.MCP.Client.list_prompts/1","doc":"Lists all available prompts from the server.","ref":"Opal.MCP.Client.html#list_prompts/1"},{"type":"function","title":"Options - Opal.MCP.Client.list_prompts/1","doc":"* `:cursor` - Pagination cursor\n  * `:timeout` - Request timeout in milliseconds","ref":"Opal.MCP.Client.html#list_prompts/1-options"},{"type":"function","title":"Examples - Opal.MCP.Client.list_prompts/1","doc":"{:ok, prompts} = MyClient.list_prompts()","ref":"Opal.MCP.Client.html#list_prompts/1-examples"},{"type":"function","title":"Opal.MCP.Client.list_resource_templates/1","doc":"Lists all available resource templates from the server.","ref":"Opal.MCP.Client.html#list_resource_templates/1"},{"type":"function","title":"Options - Opal.MCP.Client.list_resource_templates/1","doc":"* `:cursor` - Pagination cursor\n  * `:timeout` - Request timeout in milliseconds","ref":"Opal.MCP.Client.html#list_resource_templates/1-options"},{"type":"function","title":"Examples - Opal.MCP.Client.list_resource_templates/1","doc":"{:ok, resources} = MyClient.list_resources_templates()","ref":"Opal.MCP.Client.html#list_resource_templates/1-examples"},{"type":"function","title":"Opal.MCP.Client.list_resources/1","doc":"Lists all available resources from the server.","ref":"Opal.MCP.Client.html#list_resources/1"},{"type":"function","title":"Options - Opal.MCP.Client.list_resources/1","doc":"* `:cursor` - Pagination cursor\n  * `:timeout` - Request timeout in milliseconds","ref":"Opal.MCP.Client.html#list_resources/1-options"},{"type":"function","title":"Examples - Opal.MCP.Client.list_resources/1","doc":"{:ok, resources} = MyClient.list_resources()","ref":"Opal.MCP.Client.html#list_resources/1-examples"},{"type":"function","title":"Opal.MCP.Client.list_roots/1","doc":"Lists all registered roots.","ref":"Opal.MCP.Client.html#list_roots/1"},{"type":"function","title":"Examples - Opal.MCP.Client.list_roots/1","doc":"{:ok, roots} = MyClient.list_roots()","ref":"Opal.MCP.Client.html#list_roots/1-examples"},{"type":"function","title":"Opal.MCP.Client.list_tools/1","doc":"Lists all available tools from the server.","ref":"Opal.MCP.Client.html#list_tools/1"},{"type":"function","title":"Options - Opal.MCP.Client.list_tools/1","doc":"* `:cursor` - Pagination cursor\n  * `:timeout` - Request timeout in milliseconds","ref":"Opal.MCP.Client.html#list_tools/1-options"},{"type":"function","title":"Examples - Opal.MCP.Client.list_tools/1","doc":"{:ok, tools} = MyClient.list_tools()","ref":"Opal.MCP.Client.html#list_tools/1-examples"},{"type":"function","title":"Opal.MCP.Client.merge_capabilities/2","doc":"Merges additional capabilities into the client.","ref":"Opal.MCP.Client.html#merge_capabilities/2"},{"type":"function","title":"Examples - Opal.MCP.Client.merge_capabilities/2","doc":":ok = MyClient.merge_capabilities(%{\"experimental\" => %{}})","ref":"Opal.MCP.Client.html#merge_capabilities/2-examples"},{"type":"function","title":"Opal.MCP.Client.ping/1","doc":"Sends a ping request to the MCP server.","ref":"Opal.MCP.Client.html#ping/1"},{"type":"function","title":"Options - Opal.MCP.Client.ping/1","doc":"* `:timeout` - Request timeout in milliseconds (default: 5000)","ref":"Opal.MCP.Client.html#ping/1-options"},{"type":"function","title":"Examples - Opal.MCP.Client.ping/1","doc":"{:ok, :pong} = MyClient.ping()","ref":"Opal.MCP.Client.html#ping/1-examples"},{"type":"function","title":"Opal.MCP.Client.read_resource/2","doc":"Reads a specific resource by URI.","ref":"Opal.MCP.Client.html#read_resource/2"},{"type":"function","title":"Examples - Opal.MCP.Client.read_resource/2","doc":"{:ok, content} = MyClient.read_resource(\"file:///path/to/file\")","ref":"Opal.MCP.Client.html#read_resource/2-examples"},{"type":"function","title":"Opal.MCP.Client.register_log_callback/2","doc":"Registers a callback for log messages.","ref":"Opal.MCP.Client.html#register_log_callback/2"},{"type":"function","title":"Examples - Opal.MCP.Client.register_log_callback/2","doc":":ok = MyClient.register_log_callback(fn log -> IO.puts(log) end)","ref":"Opal.MCP.Client.html#register_log_callback/2-examples"},{"type":"function","title":"Opal.MCP.Client.register_progress_callback/3","doc":"Registers a callback for progress updates.","ref":"Opal.MCP.Client.html#register_progress_callback/3"},{"type":"function","title":"Examples - Opal.MCP.Client.register_progress_callback/3","doc":":ok = MyClient.register_progress_callback(\"task-1\", fn progress -> \n      IO.puts(\"Progress: #{progress}\")\n    end)","ref":"Opal.MCP.Client.html#register_progress_callback/3-examples"},{"type":"function","title":"Opal.MCP.Client.remove_root/2","doc":"Removes a root directory or resource.","ref":"Opal.MCP.Client.html#remove_root/2"},{"type":"function","title":"Examples - Opal.MCP.Client.remove_root/2","doc":":ok = MyClient.remove_root(\"file:///project\")","ref":"Opal.MCP.Client.html#remove_root/2-examples"},{"type":"function","title":"Opal.MCP.Client.send_progress/4","doc":"Sends a progress update for a token.","ref":"Opal.MCP.Client.html#send_progress/4"},{"type":"function","title":"Examples - Opal.MCP.Client.send_progress/4","doc":":ok = MyClient.send_progress(\"task-1\", 50, 100)","ref":"Opal.MCP.Client.html#send_progress/4-examples"},{"type":"function","title":"Opal.MCP.Client.server_call_tool/4","doc":"Calls a tool on the named MCP server.","ref":"Opal.MCP.Client.html#server_call_tool/4"},{"type":"function","title":"Opal.MCP.Client.server_list_resources/2","doc":"Lists resources on the named MCP server.","ref":"Opal.MCP.Client.html#server_list_resources/2"},{"type":"function","title":"Opal.MCP.Client.server_list_tools/2","doc":"Lists tools on the named MCP server.","ref":"Opal.MCP.Client.html#server_list_tools/2"},{"type":"function","title":"Opal.MCP.Client.server_read_resource/3","doc":"Reads a resource from the named MCP server.","ref":"Opal.MCP.Client.html#server_read_resource/3"},{"type":"function","title":"Opal.MCP.Client.set_log_level/1","doc":"Sets the server's log level.","ref":"Opal.MCP.Client.html#set_log_level/1"},{"type":"function","title":"Examples - Opal.MCP.Client.set_log_level/1","doc":":ok = MyClient.set_log_level(\"debug\")","ref":"Opal.MCP.Client.html#set_log_level/1-examples"},{"type":"function","title":"Opal.MCP.Client.start_link/1","doc":"","ref":"Opal.MCP.Client.html#start_link/1"},{"type":"function","title":"Opal.MCP.Client.transport_name/1","doc":"Returns the registered process name for an MCP server's transport process.","ref":"Opal.MCP.Client.html#transport_name/1"},{"type":"function","title":"Opal.MCP.Client.unregister_log_callback/1","doc":"Unregisters the log callback.","ref":"Opal.MCP.Client.html#unregister_log_callback/1"},{"type":"function","title":"Opal.MCP.Client.unregister_progress_callback/2","doc":"Unregisters a progress callback.","ref":"Opal.MCP.Client.html#unregister_progress_callback/2"},{"type":"module","title":"Opal.MCP.Config","doc":"Discovers and parses MCP server configuration files.\n\nSearches multiple standard locations for `mcp.json` files following the\n[VS Code MCP configuration format](https://code.visualstudio.com/docs/copilot/customization/mcp-servers#_configuration-format),\nand converts them into the internal `%{name, transport}` maps that\n`Opal.MCP.Supervisor` expects.","ref":"Opal.MCP.Config.html"},{"type":"module","title":"Discovery paths (in order) - Opal.MCP.Config","doc":"Project-local (relative to `working_dir`):\n  1. `.vscode/mcp.json`\n  2. `.github/mcp.json`\n  3. `.opal/mcp.json`\n  4. `.mcp.json`\n\nUser global:\n  5. `~/.opal/mcp.json`\n\nFirst definition wins per server name — project-local overrides global.","ref":"Opal.MCP.Config.html#module-discovery-paths-in-order"},{"type":"module","title":"VS Code format - Opal.MCP.Config","doc":"```json\n{\n  \"servers\": {\n    \"memory\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-memory\"]\n    },\n    \"github\": {\n      \"type\": \"http\",\n      \"url\": \"https://api.githubcopilot.com/mcp\"\n    }\n  }\n}\n```\n\nStdio servers use `command` + `args` + optional `env`/`envFile`.\nHTTP/SSE servers use `type` (\"http\" or \"sse\") + `url` + optional `headers`.","ref":"Opal.MCP.Config.html#module-vs-code-format"},{"type":"function","title":"Opal.MCP.Config.discover/2","doc":"Discovers MCP server configurations from standard file locations.","ref":"Opal.MCP.Config.html#discover/2"},{"type":"function","title":"Options - Opal.MCP.Config.discover/2","doc":"* `:extra_files` — additional file paths to search (absolute or relative to working_dir)\n\nReturns a list of `%{name: atom, transport: tuple}` maps, deduplicated\nby server name (first found wins).","ref":"Opal.MCP.Config.html#discover/2-options"},{"type":"function","title":"Opal.MCP.Config.parse_file/1","doc":"Parses a single mcp.json file and returns a list of server configs.\n\nReturns `[]` if the file doesn't exist or is invalid.","ref":"Opal.MCP.Config.html#parse_file/1"},{"type":"function","title":"Opal.MCP.Config.parse_server/2","doc":"Parses a single server entry from VS Code format into internal format.\n\nReturns `%{name: String.t(), transport: tuple}` or `nil` if invalid.","ref":"Opal.MCP.Config.html#parse_server/2"},{"type":"module","title":"Opal.MCP.Resources","doc":"Discovers and reads resources from connected MCP servers.\n\nMCP servers can expose resources (file contents, database schemas, etc.)\nthat can be injected into the agent's context. This module provides a\nthin wrapper around Anubis client resource operations.","ref":"Opal.MCP.Resources.html"},{"type":"function","title":"Opal.MCP.Resources.list/1","doc":"Lists available resources from a named MCP client.\n\nReturns a list of resource maps, or `[]` if discovery fails.","ref":"Opal.MCP.Resources.html#list/1"},{"type":"function","title":"Opal.MCP.Resources.list_all/1","doc":"Lists resources from all configured MCP servers.\n\nReturns a flat list of `{server_name, resource}` tuples.","ref":"Opal.MCP.Resources.html#list_all/1"},{"type":"function","title":"Opal.MCP.Resources.read/2","doc":"Reads a specific resource by URI from a named MCP client.\n\nReturns `{:ok, contents}` or `{:error, reason}`.","ref":"Opal.MCP.Resources.html#read/2"},{"type":"module","title":"Opal.MCP.Supervisor","doc":"Supervisor for MCP client processes within a session.\n\nStarts one `Opal.MCP.Client` child per configured MCP server using\na `:one_for_one` strategy — each server connection is independent,\nso a crash in one doesn't affect others.","ref":"Opal.MCP.Supervisor.html"},{"type":"module","title":"Supervision tree placement - Opal.MCP.Supervisor","doc":"SessionSupervisor (:rest_for_one)\n    ├── Task.Supervisor      — tool execution\n    ├── DynamicSupervisor    — sub-agents\n    ├── Opal.MCP.Supervisor  — MCP clients\n    │   ├── Client :server_a\n    │   ├── Client :server_b\n    │   └── ...\n    ├── Opal.Session         — persistence (optional)\n    └── Opal.Agent           — the agent loop\n\nWhen the session shuts down, this supervisor cascades termination to\nall Anubis client processes, which cleanly close their connections.","ref":"Opal.MCP.Supervisor.html#module-supervision-tree-placement"},{"type":"function","title":"Opal.MCP.Supervisor.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Opal.MCP.Supervisor.html#child_spec/1"},{"type":"function","title":"Opal.MCP.Supervisor.running_clients/1","doc":"Returns the list of running MCP client names from this supervisor.","ref":"Opal.MCP.Supervisor.html#running_clients/1"},{"type":"function","title":"Opal.MCP.Supervisor.start_link/1","doc":"Starts the MCP supervisor with the given server configurations.","ref":"Opal.MCP.Supervisor.html#start_link/1"},{"type":"function","title":"Parameters - Opal.MCP.Supervisor.start_link/1","doc":"* `opts` — keyword list with:\n    * `:servers` — list of `%{name: atom | String.t(), transport: tuple}` maps\n    * `:name` — optional process name (atom or via-tuple)","ref":"Opal.MCP.Supervisor.html#start_link/1-parameters"},{"type":"module","title":"Opal.Context","doc":"Discovers project context files and agent skills from the filesystem.\n\nContext is gathered from two sources:","ref":"Opal.Context.html"},{"type":"module","title":"Context Files (walk-up discovery) - Opal.Context","doc":"Starting from the agent's `working_dir`, walks up the directory tree to\nthe filesystem root, collecting known context files at each level. These\nfiles provide project-specific instructions that are prepended to the\nagent's system prompt.\n\nFiles checked at each directory level:\n  * `AGENTS.md`\n  * `OPAL.md`\n  * `.agents/AGENTS.md`\n  * `.opal/OPAL.md`\n\nThe filename list is configurable via `Opal.Config.Features` `:context` subsystem.\nFiles found closer to `working_dir` appear later in the list (higher priority).","ref":"Opal.Context.html#module-context-files-walk-up-discovery"},{"type":"module","title":"Skills (directory discovery) - Opal.Context","doc":"Scans well-known directories for skill subdirectories, each containing a\n`SKILL.md` file per the [agentskills.io spec](https://agentskills.io/specification).\n\nStandard search locations:\n  * ` /.agents/skills/*/SKILL.md`\n  * ` /.github/skills/*/SKILL.md`\n  * `~/.agents/skills/*/SKILL.md`\n  * `~/.opal/skills/*/SKILL.md`\n\nAdditional directories can be specified via `Opal.Config.Features` `:skills` subsystem.\n\nSkills use **progressive disclosure**: only `name` and `description` are\nloaded into the agent's context at startup. Full instructions are loaded\nwhen a skill is activated.","ref":"Opal.Context.html#module-skills-directory-discovery"},{"type":"function","title":"Opal.Context.build_context/2","doc":"Builds the context string to inject into the system prompt.\n\nConcatenates discovered context files and skill summaries into a single\nstring block. Returns an empty string if no context is found.","ref":"Opal.Context.html#build_context/2"},{"type":"function","title":"Options - Opal.Context.build_context/2","doc":"* `:filenames` — context filenames (default: `[\"AGENTS.md\", \"OPAL.md\"]`)\n  * `:extra_dirs` — additional skill directories (default: `[]`)\n  * `:skip_skills` — if `true`, skip skill discovery entirely (default: `false`)","ref":"Opal.Context.html#build_context/2-options"},{"type":"function","title":"Opal.Context.discover_context/2","doc":"Discovers context files by walking up from `working_dir`.\n\nReturns a list of `%{path: String.t(), content: String.t()}` maps,\nordered from root-most to deepest (closest to `working_dir` comes last).","ref":"Opal.Context.html#discover_context/2"},{"type":"function","title":"Options - Opal.Context.discover_context/2","doc":"* `:filenames` — list of filenames to look for (default from config).\n    Also searches `.agents/ ` and `.opal/ ` variants.","ref":"Opal.Context.html#discover_context/2-options"},{"type":"function","title":"Opal.Context.discover_skills/2","doc":"Discovers skills from standard and configured directories.\n\nReturns a list of `Opal.Skill.t()` structs with metadata parsed.\nOnly valid skills (those that parse and pass validation) are included;\ninvalid `SKILL.md` files are silently skipped.","ref":"Opal.Context.html#discover_skills/2"},{"type":"function","title":"Options - Opal.Context.discover_skills/2","doc":"* `:extra_dirs` — additional directories containing skill subdirectories\n    (default: `[]`).","ref":"Opal.Context.html#discover_skills/2-options"},{"type":"module","title":"Opal.Message","doc":"A struct representing messages in an agent conversation.\n\nMessages flow through the agent loop and carry content between the user,\nassistant, and tool executions. Each message has a role that determines\nits semantics:\n\n  * `:user` — a user-originated message with text content\n  * `:assistant` — an assistant response with text and optional tool calls\n  * `:tool_call` — a tool invocation specifying name, call ID, and arguments\n  * `:tool_result` — the result of a tool execution, keyed by call ID\n\nEvery message is assigned a unique ID at construction time.","ref":"Opal.Message.html"},{"type":"type","title":"Opal.Message.role/0","doc":"","ref":"Opal.Message.html#t:role/0"},{"type":"type","title":"Opal.Message.t/0","doc":"","ref":"Opal.Message.html#t:t/0"},{"type":"type","title":"Opal.Message.tool_call/0","doc":"","ref":"Opal.Message.html#t:tool_call/0"},{"type":"function","title":"Opal.Message.assistant/2","doc":"Creates an assistant message with text content and optional tool calls.","ref":"Opal.Message.html#assistant/2"},{"type":"function","title":"Examples - Opal.Message.assistant/2","doc":"iex> msg = Opal.Message.assistant(\"Sure, let me check.\", [])\n    iex> msg.role\n    :assistant","ref":"Opal.Message.html#assistant/2-examples"},{"type":"function","title":"Opal.Message.tool_call/3","doc":"Creates a tool call message representing a tool invocation.","ref":"Opal.Message.html#tool_call/3"},{"type":"function","title":"Parameters - Opal.Message.tool_call/3","doc":"* `call_id` — unique identifier linking this call to its result\n  * `name` — the tool name to invoke\n  * `arguments` — a map of arguments to pass to the tool","ref":"Opal.Message.html#tool_call/3-parameters"},{"type":"function","title":"Opal.Message.tool_result/3","doc":"Creates a tool result message with the output of a tool execution.","ref":"Opal.Message.html#tool_result/3"},{"type":"function","title":"Parameters - Opal.Message.tool_result/3","doc":"* `call_id` — the call ID this result corresponds to\n  * `output` — the string output produced by the tool\n  * `is_error` — whether the tool execution resulted in an error (default: `false`)","ref":"Opal.Message.html#tool_result/3-parameters"},{"type":"function","title":"Opal.Message.user/1","doc":"Creates a user message with the given text content.","ref":"Opal.Message.html#user/1"},{"type":"function","title":"Examples - Opal.Message.user/1","doc":"iex> msg = Opal.Message.user(\"Hello\")\n    iex> msg.role\n    :user","ref":"Opal.Message.html#user/1-examples"},{"type":"module","title":"Opal.Path","doc":"Cross-platform path normalization and security utilities.\n\nProvides functions for normalizing file paths across operating systems\nand ensuring paths stay within allowed base directories to prevent\npath traversal attacks.","ref":"Opal.Path.html"},{"type":"function","title":"Opal.Path.normalize/1","doc":"Normalizes a path by replacing backslashes with forward slashes and expanding it.\n\nThis ensures consistent path representation regardless of the source OS.","ref":"Opal.Path.html#normalize/1"},{"type":"function","title":"Examples - Opal.Path.normalize/1","doc":"iex> Opal.Path.normalize(\"foo\\\\bar/baz\")\n    Path.expand(\"foo/bar/baz\")","ref":"Opal.Path.html#normalize/1-examples"},{"type":"function","title":"Opal.Path.safe_relative/2","doc":"Ensures a path is safely contained within a base directory.\n\nExpands both paths and verifies the target is a child of the base directory.\nThis prevents path traversal attacks (e.g. `../../etc/passwd`).\n\nReturns `{:ok, expanded_path}` if the path is within the base directory,\nor `{:error, :outside_base_dir}` if it escapes.","ref":"Opal.Path.html#safe_relative/2"},{"type":"function","title":"Examples - Opal.Path.safe_relative/2","doc":"iex> Opal.Path.safe_relative(\"src/main.ex\", \"/project\")\n    {:ok, \"/project/src/main.ex\"}\n\n    iex> Opal.Path.safe_relative(\"../../etc/passwd\", \"/project\")\n    {:error, :outside_base_dir}","ref":"Opal.Path.html#safe_relative/2-examples"},{"type":"function","title":"Opal.Path.to_native/1","doc":"Converts a path to use native OS separators.\n\nUses backslashes on Windows and forward slashes elsewhere.","ref":"Opal.Path.html#to_native/1"},{"type":"function","title":"Examples - Opal.Path.to_native/1","doc":"iex> Opal.Path.to_native(\"foo/bar/baz\")\n    \"foo/bar/baz\"","ref":"Opal.Path.html#to_native/1-examples"},{"type":"module","title":"Opal.Session.Compaction","doc":"Context window compaction following pi's approach.\n\nSummarizes older messages using the agent's LLM, producing a structured\nsummary that preserves goals, progress, decisions, and file operations.\nFalls back to truncation if no agent is available.","ref":"Opal.Session.Compaction.html"},{"type":"module","title":"How it works - Opal.Session.Compaction","doc":"1. Walk backwards from the newest message, estimating tokens, until\n   `keep_recent_tokens` (default 20k) is reached — this is the cut point.\n2. Cut at a turn boundary (user message), never mid-turn.\n3. Serialize messages before the cut point into a text transcript.\n4. Ask the LLM to produce a structured summary.\n5. Replace old messages with a single summary message.","ref":"Opal.Session.Compaction.html#module-how-it-works"},{"type":"module","title":"Usage - Opal.Session.Compaction","doc":"Opal.Session.Compaction.compact(session, agent: agent_pid)\n    Opal.Session.Compaction.compact(session, strategy: :truncate)","ref":"Opal.Session.Compaction.html#module-usage"},{"type":"function","title":"Opal.Session.Compaction.compact/2","doc":"Compacts old messages in the session.","ref":"Opal.Session.Compaction.html#compact/2"},{"type":"function","title":"Options - Opal.Session.Compaction.compact/2","doc":"* `:agent` — Agent pid for LLM summarization (calls get_state to get provider/model)\n  * `:provider` — Provider module (alternative to `:agent`, avoids GenServer call)\n  * `:model` — Model struct (required when `:provider` is given)\n  * `:strategy` — `:summarize` (default if provider available) or `:truncate`\n  * `:keep_recent_tokens` — tokens to keep uncompacted (default: 20000)\n  * `:instructions` — optional focus instructions for the summary","ref":"Opal.Session.Compaction.html#compact/2-options"},{"type":"function","title":"Opal.Session.Compaction.extract_file_ops/1","doc":"Extracts file read/write operations from tool calls in messages.","ref":"Opal.Session.Compaction.html#extract_file_ops/1"},{"type":"function","title":"Opal.Session.Compaction.serialize_conversation/1","doc":"Serializes messages into a text transcript for summarization.","ref":"Opal.Session.Compaction.html#serialize_conversation/1"},{"type":"module","title":"Opal.SessionServer","doc":"Per-session supervisor that owns the full session process tree.\n\nEach session gets its own supervision subtree:\n\n    Opal.SessionServer (Supervisor, :rest_for_one)\n    ├── Task.Supervisor        — per-session tool execution\n    ├── DynamicSupervisor      — per-session sub-agents\n    ├── Opal.MCP.Supervisor    — MCP client connections (optional)\n    ├── Opal.Session           — conversation persistence (optional)\n    └── Opal.Agent             — the agent loop\n\nTerminating the SessionServer cleans up everything: the agent, all\nrunning tools, all sub-agents, MCP connections, and the session store.\n\nThe `:rest_for_one` strategy means if the Task.Supervisor,\nDynamicSupervisor, or MCP.Supervisor crashes, the Agent (which depends\non them) restarts too.","ref":"Opal.SessionServer.html"},{"type":"function","title":"Opal.SessionServer.agent/1","doc":"Returns the Agent pid from a SessionServer supervisor.","ref":"Opal.SessionServer.html#agent/1"},{"type":"function","title":"Opal.SessionServer.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Opal.SessionServer.html#child_spec/1"},{"type":"function","title":"Opal.SessionServer.session/1","doc":"Returns the Session pid from a SessionServer supervisor, or nil.","ref":"Opal.SessionServer.html#session/1"},{"type":"function","title":"Opal.SessionServer.start_link/1","doc":"Starts a session supervisor with the given options.","ref":"Opal.SessionServer.html#start_link/1"},{"type":"function","title":"Required Options - Opal.SessionServer.start_link/1","doc":"* `:session_id` — unique session identifier\n  * `:model` — `Opal.Model.t()` struct\n  * `:working_dir` — base directory for tool execution","ref":"Opal.SessionServer.html#start_link/1-required-options"},{"type":"function","title":"Optional Options - Opal.SessionServer.start_link/1","doc":"* `:system_prompt` — system prompt string\n  * `:tools` — list of `Opal.Tool` modules\n  * `:config` — `Opal.Config.t()` struct\n  * `:provider` — `Opal.Provider` module\n  * `:session` — if `true`, starts an `Opal.Session` process","ref":"Opal.SessionServer.html#start_link/1-optional-options"},{"type":"module","title":"Opal.SubAgent","doc":"Spawns and manages child agents that work in parallel.\n\nA sub-agent is another `Opal.Agent` started under `Opal.SessionSupervisor`.\nIt gets its own process, message history, and tool set. The supervision tree\nensures cleanup — if the parent session is torn down, sub-agents started by\ntools within that session are cleaned up when those tool tasks terminate.","ref":"Opal.SubAgent.html"},{"type":"module","title":"Usage - Opal.SubAgent","doc":"# From within a tool or the parent agent:\n    {:ok, sub} = Opal.SubAgent.spawn(parent_agent, %{\n      system_prompt: \"You are a test-writing specialist.\",\n      tools: [Opal.Tool.Read, Opal.Tool.Write, Opal.Tool.Shell],\n      model: {:copilot, \"claude-haiku-3-5\"}\n    })\n\n    {:ok, result} = Opal.SubAgent.run(sub, \"Write tests for lib/opal/agent.ex\")\n\nMultiple sub-agents can be spawned in parallel, each working on different\nfiles or tasks. If a sub-agent crashes, only that sub-agent is affected.","ref":"Opal.SubAgent.html#module-usage"},{"type":"function","title":"Opal.SubAgent.run/3","doc":"Sends a prompt to a sub-agent and synchronously collects the response.\n\nSubscribes to the sub-agent's events, sends the prompt, and waits for\n`:agent_end`. Returns the accumulated text response.","ref":"Opal.SubAgent.html#run/3"},{"type":"function","title":"Options - Opal.SubAgent.run/3","doc":"* `timeout` — maximum wait time in milliseconds (default: `120_000`)","ref":"Opal.SubAgent.html#run/3-options"},{"type":"function","title":"Opal.SubAgent.spawn/2","doc":"Spawns a new sub-agent inheriting defaults from the parent agent.\n\nThe parent agent's config, working directory, model, provider, and tools\nare used as defaults. Any key in `overrides` replaces the parent's value.","ref":"Opal.SubAgent.html#spawn/2"},{"type":"function","title":"Overrides - Opal.SubAgent.spawn/2","doc":"* `:system_prompt` — system prompt for the sub-agent (default: parent's)\n  * `:tools` — tool modules (default: parent's tools)\n  * `:model` — `{provider, model_id}` tuple (default: parent's model)\n  * `:working_dir` — working directory (default: parent's)\n  * `:provider` — provider module (default: parent's)\n\nReturns `{:ok, sub_agent_pid}` or `{:error, reason}`.","ref":"Opal.SubAgent.html#spawn/2-overrides"},{"type":"function","title":"Opal.SubAgent.spawn_from_state/2","doc":"Like `spawn/2`, but takes an already-captured `Opal.Agent.State` struct\ninstead of a pid. Use this from within tool execution to avoid calling\nback into the blocked Agent GenServer (which would deadlock).","ref":"Opal.SubAgent.html#spawn_from_state/2"},{"type":"function","title":"Opal.SubAgent.stop/1","doc":"Stops a sub-agent and cleans up its process.\n\nAccepts either just the sub-agent pid (looks up the parent supervisor\nfrom process ancestry) or the sub-agent pid and the supervisor to\nterminate it from.","ref":"Opal.SubAgent.html#stop/1"},{"type":"extras","title":"Overview","doc":"# ✦ Opal\n\n**Your coding agent is a GenServer. Your sub-agents are child processes. Your debugger is `:observer`.**\n\n```bash\n# Install it!\nnpm i -g @unfinite/opal\n# Start it!\nopal\n# Inspect it!\nopal --inspect --connect\n# Integrate it!\n# Soon: Consume the library on Hexpm!\n#       Use it from any language through JSON-RPC!\n```\n\nI looked at every open-source agent harness I could find — [Pi](https://github.com/badlogic/pi-mono), Claude Code, Goose — and they're all written in TypeScript. Every single one.\n\nA coding agent is a tree of stateful, long-running actors with a conversation loop at the heart. You need process isolation, concurrency, mid-run message injection, live introspection. That's not a TypeScript problem. That's an Erlang problem — and Erlang solved it decades ago.\n\nOpal is two things: a **clean Elixir library** you can drop into any application's supervision tree, and a **terminal interface** that uses the library to give you a fully interactive coding agent. The CLI is actually built with the library — it bootstraps itself. The same library you'd use in your own app is the same one powering the TUI.\n\nIt ships a base set of tools (`read_file`, `write_file`, `edit_file`, `shell`, `sub_agent`), an MCP host, a skills system, sub-agent support, and a JSON-RPC daemon mode. Not ultra-minimal, but just enough to be genuinely useful out of the box.\n\n---","ref":"readme.html"},{"type":"extras","title":"What makes it interesting - Overview","doc":"**You can connect to a running agent and watch it think.** This is the one that gets people. Opal uses Erlang distribution — from another terminal, connect to a live session and stream every event from every agent and sub-agent in real time:\n\n```sh\nopal --connect opal@hostname --inspect\n```\n\nNo special debug mode. No logging infrastructure. Crack open `:observer` and you can see the full process tree, message queues, memory — everything. It's just how the BEAM works, and it's free.\n\n**Sub-agents are just processes.** Want to delegate a task to a child agent? Spawn one. It gets its own message history, its own tools, its own model if you want. Runs in parallel, fully isolated. If the parent dies, sub-agents are cleaned up automatically. No thread pools, no `Promise.all`, no async/await ceremony. Just processes.\n\n**The process mailbox is the steering queue.** Need to redirect an agent mid-run? `Opal.steer(agent, \"focus on tests instead\")` drops a message into the GenServer's mailbox. Between tool executions, the agent checks for it. No polling, no callback chains. The BEAM's had this primitive for 30+ years.\n\n**SSE streaming lands in `handle_info/2`.** The LLM response streams via `Req` with `into: :self` — SSE chunks arrive directly as messages in the GenServer's mailbox. The agent loop processes them alongside tool results, steering messages, and abort signals using the same `receive` block. There's something very satisfying about that.\n\n**It's an embeddable library, not just a CLI.** Add `{:opal, ...}` to your deps and the full harness lives inside your Elixir app. No external process, no JSON-RPC overhead, no language interop — just Erlang message passing. Or run it headless as a JSON-RPC 2.0 daemon and consume it from any language.","ref":"readme.html#what-makes-it-interesting"},{"type":"extras","title":"What you get - Overview","doc":"- **Interactive TUI** — fullscreen terminal chat with streaming, thinking indicators, task tracking, themes. Elm Architecture via TermUI.\n- **Daemon mode** — headless JSON-RPC 2.0 over stdio. Consume from any language.\n- **Sub-agents** — delegate tasks to child agents. They're supervised processes with their own context.\n- **MCP host** — connects to MCP servers, surfaces their tools alongside native ones. They become indistinguishable at runtime.\n- **Built-in tools** — `read_file`, `write_file`, `edit_file`, `shell` (cross-platform), `sub_agent`.\n- **Skills** — drop instruction sets into your project, Opal discovers and loads them as context.\n- **Event system** — `Registry`-based pub/sub. Subscribe from any process, build whatever you want on top.\n- **Cross-platform** — Linux, macOS, Windows.","ref":"readme.html#what-you-get"},{"type":"extras","title":"Features - Overview","doc":"Here's what the harness supports today.","ref":"readme.html#features"},{"type":"extras","title":"Agent runtime - Overview","doc":"- [x] Agentic tool loop — prompt → LLM → tool calls → repeat until done\n- [x] SSE streaming responses into the GenServer mailbox (`Req` + `into: :self`)\n- [x] Concurrent tool execution via `TaskSupervisor`\n- [x] Streaming tool output — tools emit output chunks in real time (e.g., long shell commands)\n- [x] Extended thinking / reasoning — surfaces thinking events from Claude, o-series, etc.\n- [x] Configurable thinking level (`:off`, `:low`, `:medium`, `:high`)\n- [x] Mid-run steering — redirect the agent between tool executions\n- [x] Abort / cancel in-flight responses\n- [x] Stream stall detection — watchdog warns if no chunks arrive for 10+ seconds\n- [x] Auto-compaction — summarizes old messages when context nears 80% capacity\n- [x] Token usage tracking across turns\n- [x] Per-session supervision tree (`rest_for_one`)","ref":"readme.html#agent-runtime"},{"type":"extras","title":"Tools - Overview","doc":"- [x] `read_file` — read with optional line offset/limit\n- [x] `write_file` — write with auto-created parent directories\n- [x] `edit_file` — search-and-replace, enforces single-match uniqueness\n- [x] `shell` — cross-platform, configurable shell (sh/bash/zsh/cmd/powershell), streaming output, timeout\n- [x] `sub_agent` — spawn a child agent for delegated work, depth-limited to 1 level\n- [x] `tasks` — DETS-backed project-scoped task tracker (priorities, statuses, groups, tags, due dates, views)\n- [x] `use_skill` — load a skill's full instructions into context on demand\n- [x] Path sandboxing — all file tools reject directory traversal escapes","ref":"readme.html#tools"},{"type":"extras","title":"Sessions - Overview","doc":"- [x] Conversation tree with branching (rewind to any past message)\n- [x] JSONL persistence (save/load sessions to disk)\n- [x] Auto-save on idle\n- [x] Auto-title generation via LLM\n- [x] Session listing with title and modification time\n- [x] LLM-powered compaction with structured summaries (goal, progress, decisions, file ops, next steps)\n- [x] Truncation fallback when no LLM is available\n- [x] Turn-boundary-aware cutting — never splits mid-turn","ref":"readme.html#sessions"},{"type":"extras","title":"Skills - Overview","doc":"- [x] Skill discovery — scans `.agents/skills/`, `.github/skills/`, `~/.agents/skills/`, `~/.opal/skills/`\n- [x] Progressive disclosure — only name/description loaded at startup, full instructions on demand\n- [x] YAML frontmatter parsing (agentskills.io spec)","ref":"readme.html#skills"},{"type":"extras","title":"Context discovery - Overview","doc":"- [x] Walk-up file discovery — collects `AGENTS.md` / `OPAL.md` from working dir to root\n- [x] Priority ordering — closer files override distant ones","ref":"readme.html#context-discovery"},{"type":"extras","title":"MCP - Overview","doc":"- [x] MCP client host (Anubis, protocol v2025-03-26)\n- [x] Stdio and HTTP/SSE transports\n- [x] Auto-discovery from `.vscode/mcp.json`, `.github/mcp.json`, `.opal/mcp.json`, `.mcp.json`\n- [x] MCP tools bridged as native `Opal.Tool` modules at runtime — identical to built-in tools\n- [x] Tool name collision resolution (server-prefixed)\n- [x] MCP resource access (list + read)\n- [x] Per-session MCP supervision","ref":"readme.html#mcp"},{"type":"extras","title":"Provider - Overview","doc":"- [x] GitHub Copilot (Claude, GPT-4o/5, Gemini 2.5/3, Grok, o-series)\n- [x] Chat Completions API + Responses API (dual support)\n- [x] Device-code OAuth with auto-refresh\n- [x] Token persistence (`~/.opal/auth.json`)\n- [x] GitHub Enterprise support\n- [x] Provider behaviour — ready for OpenAI direct, Anthropic, Ollama, etc.","ref":"readme.html#provider"},{"type":"extras","title":"RPC - Overview","doc":"- [x] JSON-RPC 2.0 over stdio (daemon mode)\n- [x] Bidirectional — server can request confirmations and input from the client\n- [x] Full event streaming (12 event types)\n- [x] Declarative protocol spec for codegen","ref":"readme.html#rpc"},{"type":"extras","title":"CLI / TUI - Overview","doc":"- [x] Fullscreen interactive chat (Elm Architecture via TermUI)\n- [x] Slash commands — `/clear`, `/compact`, `/dump`, `/model`, `/debug`, `/help`\n- [x] Interactive model picker\n- [x] Context dump to JSON\n- [x] Remote inspection via Erlang distribution (`--connect --inspect`)","ref":"readme.html#cli-tui"},{"type":"extras","title":"Configuration - Overview","doc":"- [x] Layered config — defaults → app config → env vars → session overrides\n- [x] Feature toggles for sub-agents, context discovery, skills, MCP\n- [x] Cross-platform data dir (`~/.opal` / `%APPDATA%/opal`)\n- [x] Configurable default model, tools, shell type","ref":"readme.html#configuration"},{"type":"extras","title":"Architecture - Overview","doc":"The repo is an [Nx](https://nx.dev)-managed monorepo with two projects:\n\n| Project     | What it is                                                                                                                                                                                     |\n| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **`core/`** | **Opal SDK** — the agent engine as an Elixir library. Tools, providers, sessions, MCP bridge, RPC server. Add `{:opal, ...}` to your deps and embed the whole thing in your supervision tree.  |\n| **`cli/`**  | **Opal CLI** — a fullscreen terminal UI that consumes the core library directly. No serialization layer between the TUI and the agent — it's all function calls in the same BEAM process tree. |\n\n```\nopal/\n├── core/               Opal SDK (Elixir library)\n│   └── lib/opal/\n│       ├── agent.ex        Agent loop (GenServer)\n│       ├── events.ex       Registry-based pub/sub\n│       ├── sub_agent.ex    Supervised child agents\n│       ├── rpc/            JSON-RPC 2.0 server (daemon mode)\n│       ├── mcp/            MCP client bridge\n│       ├── tool/           Built-in tools (read, write, edit, shell, sub_agent)\n│       └── provider/       LLM providers (Copilot)\n├── cli/                Terminal UI (TermUI / Elm Architecture)\n│   └── lib/opal/cli/\n│       ├── app.ex          TUI application\n│       ├── main.ex         Binary entry point\n│       └── views/          UI components\n├── docs/               Design documents\n└── ARCHITECTURE.md     Full system design reference\n```","ref":"readme.html#architecture"},{"type":"extras","title":"The process tree - Overview","doc":"This is where it gets fun. Every session is its own supervision subtree:\n\n```\nOpal.SessionSupervisor (DynamicSupervisor)\n└── Opal.SessionServer (per session)\n    ├── Opal.Agent (GenServer — the agentic loop)\n    ├── Opal.Session (GenServer — message history & persistence)\n    ├── Opal.ToolSup (TaskSupervisor — concurrent tool execution)\n    └── [Sub-agents] (full Agent processes, supervised)\n\nOpal.Events (Registry — pub/sub, any process can subscribe)\n```\n\nThe agent loop is a GenServer. It receives prompts, streams LLM responses via `Req` (SSE chunks arrive as messages in `handle_info/2` — beautiful), executes tool calls concurrently through a `TaskSupervisor`, and loops until the model produces a final response with no tool calls.\n\nSee [ARCHITECTURE.md](ARCHITECTURE.md) for the full system design.\n\n---","ref":"readme.html#the-process-tree"},{"type":"extras","title":"Quick start - Overview","doc":"**Requirements:** Elixir ≥ 1.18 / OTP ≥ 27, a [GitHub Copilot](https://github.com/features/copilot) subscription, [Nx](https://nx.dev) (`npm i -g nx`).\n\n```sh\ngit clone https://github.com/scohen/opal.git\ncd opal\nnx run-many -t deps\ncd cli && mix opal\n```\n\nOn first run, you'll authenticate via GitHub device code flow. No API keys to juggle.","ref":"readme.html#quick-start"},{"type":"extras","title":"Building the binary - Overview","doc":"```sh\nnx run cli:escript\n\ncli/opal                   # interactive TUI\ncli/opal --daemon          # headless JSON-RPC server\ncli/opal --inspect         # stream all agent events to terminal\ncli/opal --help\n```","ref":"readme.html#building-the-binary"},{"type":"extras","title":"CLI modes - Overview","doc":"| Flag                       | Mode           | What it does                                         |\n| -------------------------- | -------------- | ---------------------------------------------------- |\n| _(none)_                   | Interactive    | Fullscreen TUI with streaming chat                   |\n| `--daemon`                 | Headless       | JSON-RPC 2.0 server on stdin/stdout                  |\n| `--inspect`                | Inspector      | Stream all agent events to terminal                  |\n| `--connect NODE --inspect` | Remote inspect | Attach to a running instance via Erlang distribution |","ref":"readme.html#cli-modes"},{"type":"extras","title":"Using Opal as a library - Overview","doc":"This is the part I'm most excited about. The `core/` project is an embeddable Elixir library — add it to your supervision tree and you get everything. No external process, no RPC, no serialization. Just Erlang message passing.\n\n```elixir\n# mix.exs\ndefp deps do\n  [{:opal, path: \"../opal/core\"}]\nend\n```\n\n```elixir\n# Start a session — it's a supervised process tree\n{:ok, agent} = Opal.start_session(%{\n  system_prompt: \"You are a helpful coding assistant.\",\n  working_dir: \"/path/to/project\"\n})\n\n# Async — subscribe to Opal.Events for streaming output\n:ok = Opal.prompt(agent, \"List all Elixir files\")\n\n# Sync — blocks until the agent finishes\n{:ok, response} = Opal.prompt_sync(agent, \"What does this module do?\")\n\n# Steer mid-run — injected between tool executions\n:ok = Opal.steer(agent, \"Actually, focus on the test files\")\n\n# Change models on the fly\n:ok = Opal.set_model(agent, :copilot, \"claude-sonnet-4\")\n\n# Clean up\n:ok = Opal.stop_session(agent)\n```","ref":"readme.html#using-opal-as-a-library"},{"type":"extras","title":"Observability - Overview","doc":"Any process can subscribe to agent events in real time. The event system is built on `Registry`, so it's fast and it's what Elixir developers already know:\n\n```elixir\nOpal.Events.subscribe(session_id)\n\nreceive do\n  {:opal_event, ^session_id, {:message_delta, %{delta: text}}} ->\n    IO.write(text)\n  {:opal_event, ^session_id, {:tool_execution_start, %{name: name}}} ->\n    IO.puts(\"Running tool: #{name}\")\n  {:opal_event, ^session_id, {:agent_end, _}} ->\n    IO.puts(\"Done.\")\nend\n```\n\n`Opal.Events.subscribe_all()` gives you events from _every_ session — useful for dashboards, logging, or just poking around.","ref":"readme.html#observability"},{"type":"extras","title":"RPC interface - Overview","doc":"If you're not in the Elixir/Erlang ecosystem, run Opal in daemon mode and talk to it over JSON-RPC 2.0 on stdio:\n\n```sh\nopal --daemon\n```\n\nWire format follows the MCP stdio transport convention. See [ARCHITECTURE.md](ARCHITECTURE.md) for the full schema.","ref":"readme.html#rpc-interface"},{"type":"extras","title":"Development - Overview","doc":"```sh\n# Install deps\nnx run-many -t deps\n\n# Run the TUI in dev mode (auto-recompiles)\ncd cli && mix opal\n# — or —\nnx run cli:dev\n\n# Tests\nnx run-many -t test\nnx run core:test\nnx run cli:test\n\n# Lint / format\nnx run-many -t lint\nnx run-many -t format\n```","ref":"readme.html#development"},{"type":"extras","title":"Nx targets - Overview","doc":"| Target    | Core | CLI | Description                         |\n| --------- | ---- | --- | ----------------------------------- |\n| `dev`     | —    | ✓   | Run TUI in dev mode (`mix opal`)    |\n| `build`   | ✓    | ✓   | Compile with `--warnings-as-errors` |\n| `test`    | ✓    | ✓   | Run ExUnit tests                    |\n| `lint`    | ✓    | ✓   | Check formatting                    |\n| `format`  | ✓    | ✓   | Auto-format code                    |\n| `escript` | —    | ✓   | Build standalone binary             |\n| `deps`    | ✓    | ✓   | Fetch dependencies                  |\n| `docs`    | ✓    | —   | Generate ex_doc                     |\n| `clean`   | ✓    | ✓   | Clean build artifacts               |","ref":"readme.html#nx-targets"},{"type":"extras","title":"Provider - Overview","doc":"Opal currently ships with one LLM provider: **GitHub Copilot**. One endpoint gives you access to Claude, GPT-4o, o3, and other models. Authentication is device-code OAuth — no API keys to manage.\n\nThe provider system is a behaviour (`Opal.Provider`), so adding OpenAI direct, Anthropic, Ollama, or anything else is straightforward. The Copilot provider uses the OpenAI Responses API wire format, so most of the hard work transfers.","ref":"readme.html#provider-1"},{"type":"extras","title":"Why I built this - Overview","doc":"I wanted to understand how agent harnesses actually work — not just use one, but build one from the ground up. I studied [Pi](https://github.com/badlogic/pi-mono) and thought the architecture was smart, but everything was TypeScript. And the more I stared at the problem — long-running loops, concurrent tool execution, process isolation, sub-agent orchestration — the more it looked like someone had described Erlang/OTP to me without saying the name.\n\nSo I built it. It took dramatically fewer lines of code than I expected. Sub-agents? Processes. Steering? Mailbox. Fault isolation? Supervision tree. Live debugging? Erlang distribution. I didn't have to build any of that infrastructure — it was already there.\n\nThis is a hobby project and a research project. It's inspired by Pi but doesn't chase extreme minimalism — Elixir's process model makes features like sub-agents and concurrent tool execution essentially free, so there's no reason to leave them out. Not minimal for the sake of it, just enough to be useful. And it does bootstrap itself, which is pretty fun.\n\nMade with love by a proud Boricua.","ref":"readme.html#why-i-built-this"},{"type":"extras","title":"Disclaimer - Overview","doc":"This is a personal hobby project. I work at Microsoft (Azure), and our GitHub Copilot subscription provides the LLM access I use for development.\n\n**This project is not affiliated with, endorsed by, or related to my employer in any way. Neither are my opinions.**","ref":"readme.html#disclaimer"},{"type":"extras","title":"License - Overview","doc":"[MIT](LICENSE) — Sergio Mattei","ref":"readme.html#license"},{"type":"extras","title":"Architecture","doc":"# Opal — An OTP-Native Coding Agent Harness\n\n> _Inspired by [Pi](https://github.com/badlogic/pi-mono/tree/main/packages/coding-agent), reimagined for the BEAM._","ref":"architecture.html"},{"type":"extras","title":"What This Is - Architecture","doc":"Opal is an Elixir SDK for building coding agents that takes full advantage of OTP\nprimitives — supervision trees, GenServers, process isolation, message passing,\nand the observer. Rather than port Pi to Elixir, we steal the ideas that matter\nand throw away the ones OTP already solves better.\n\n**Core thesis:** A coding agent is a tree of actors with a conversation loop at\nthe heart. The BEAM gives us fault-tolerance, introspection, and massive\nparallelism for free — things Pi has to bolt on through extensions, tmux hacks,\nor external process spawning.\n\n**Cross-platform by default.** Elixir and the BEAM run on Linux, macOS, and\nWindows. Opal must work on all three from day one — no POSIX assumptions, no\nbash-only tooling, no hardcoded `/` paths.\n\n---","ref":"architecture.html#what-this-is"},{"type":"extras","title":"What We Take from Pi - Architecture","doc":"| Pi Concept                                          | What We Keep                    | What We Change                                                         |\n| --------------------------------------------------- | ------------------------------- | ---------------------------------------------------------------------- |\n| **Agent loop** (prompt → LLM → tool calls → repeat) | The core loop shape             | It's a GenServer, not an async function                                |\n| **Tools** (read, write, edit, shell)                | Tool interface and built-in set | Tools are module callbacks, not JS objects                             |\n| **Sessions** (JSONL tree with branching)            | Tree-structured message history | ETS/DETS-backed, not file-append                                       |\n| **Events** (agent_start, tool_execution_end, etc.)  | Event lifecycle model           | `Registry`-based pubsub, not callback lists                            |\n| **SDK embedding**                                   | Embeddable in apps              | Native OTP — just add to your supervision tree                         |\n| **Extensibility** (extensions, skills, prompts)     | Plugin system concept           | Behaviours, not runtime JS loading                                     |\n| **Steering/follow-up queues**                       | Mid-run message injection       | Process mailbox _is_ the queue                                         |\n| **Provider abstraction**                            | Multi-provider from day one     | Single provider (GitHub Copilot) to start — behaviour ready for others |","ref":"architecture.html#what-we-take-from-pi"},{"type":"extras","title":"What We Don't Take - Architecture","doc":"- **No npm/git package system.** Hex packages and Mix deps.\n- **Single binary with built-in TUI.** The `opal` binary includes both the\n  interactive terminal UI (TermUI/Elm Architecture) and the agent engine in a\n  single BEAM process tree. No separate frontend process or serialization layer.\n  A `--daemon` flag provides headless JSON-RPC mode for external consumers.\n- **RPC for external consumers only.** Opal ships as both a library\n  (`{:opal, ...}`) and a binary (`opal`). In interactive mode, the TUI calls\n  the agent directly via Elixir function calls — no RPC overhead. In daemon\n  mode (`opal --daemon`), it communicates via JSON-RPC 2.0 over stdio for\n  external clients.\n- **MCP client, not MCP-hostile.** Pi says \"no MCP\" — we disagree. Opal acts\n  as an MCP _host_: it connects to external MCP servers and surfaces their\n  tools/resources to the agent alongside native `Opal.Tool` modules. We use\n  [Anubis MCP](https://hexdocs.pm/anubis_mcp) (`~> 0.17`) as the protocol\n  foundation — it handles transports, lifecycle, and JSON-RPC so we don't\n  reinvent any of it. Native tools and MCP tools coexist; MCP servers are just\n  another tool source, managed by supervised Anubis client processes.\n\n---","ref":"architecture.html#what-we-don-t-take"},{"type":"extras","title":"Architecture Overview - Architecture","doc":"```\n┌─────────────────────────────────────────────────────────┐\n│                    opal binary (Elixir)                  │\n│                                                          │\n│  Interactive mode (default):                             │\n│  ┌─────────────────────────────────────────────────────┐ │\n│  │              Opal.CLI.App (TermUI)                   │ │\n│  │  init/update/view — Elm Architecture                 │ │\n│  │                                                      │ │\n│  │  Header │ MessageList │ Thinking │ TaskList           │ │\n│  │  Input  │ StatusBar   │ ConfirmDialog                │ │\n│  └────────────────────────┬────────────────────────────┘ │\n│                           │ direct Elixir calls          │\n│                           │ (no serialization)           │\n│  ┌────────────────────────▼────────────────────────────┐ │\n│  │              Opal (core library)                     │ │\n│  │  Agent | Session | Tools | MCP | Provider | Events  │ │\n│  └──────────────────────────────────────────────────────┘ │\n│                                                          │\n│  Daemon mode (--daemon):                                 │\n│  ┌──────────────────────────────────────────────────────┐ │\n│  │  Opal.RPC.Stdio (JSON-RPC 2.0 on stdin/stdout)      │ │\n│  │  For external clients — no TUI, headless operation   │ │\n│  └──────────────────────────────────────────────────────┘ │\n│                                                          │\n│  As a library ({:opal, \"~> 0.x\"}):                       │\n│  ┌──────────────────────────────────────────────────────┐ │\n│  │  Opal.start_session/1, Opal.prompt/2, etc.          │ │\n│  │  Embed in your own Elixir application                │ │\n│  └──────────────────────────────────────────────────────┘ │\n└──────────────────────────────────────────────────────────┘\n```","ref":"architecture.html#architecture-overview"},{"type":"extras","title":"Internal Process Tree - Architecture","doc":"```\n┌─────────────────────────────────────────────────────────┐\n│                  Opal.SessionSupervisor                 │\n│              (DynamicSupervisor per session)             │\n│                                                         │\n│  ┌──────────────┐  ┌──────────────┐  ┌───────────────┐ │\n│  │ Opal.Agent   │  │ Opal.Session │  │ Opal.ToolSup  │ │\n│  │ (GenServer)  │  │ (GenServer)  │  │ (TaskSupervisor│ │\n│  │              │  │              │  │  for tools)    │ │\n│  │ • LLM loop   │  │ • Message    │  │               │ │\n│  │ • Streaming   │  │   history   │  │ • Concurrent   │ │\n│  │ • Turn mgmt   │  │ • Branching │  │   tool exec   │ │\n│  │ • Steering    │  │ • Persist   │  │ • Timeouts    │ │\n│  └──────┬───────┘  └──────────────┘  └───────────────┘ │\n│         │                                               │\n│         │ events via Registry                           │\n│         ▼                                               │\n│  ┌──────────────┐                                       │\n│  │ Opal.Events  │ ← Any process can subscribe          │\n│  │ (Registry)   │                                       │\n│  └──────────────┘                                       │\n└─────────────────────────────────────────────────────────┘\n```\n\n---","ref":"architecture.html#internal-process-tree"},{"type":"extras","title":"Staged Build Plan - Architecture","doc":"When in doubt, you can check [Pi](https://github.com/badlogic/pi-mono/tree/main/packages/coding-agent) for specific algorithms or implementation inspiration. You must stick to the overall architecture in this document, however.","ref":"architecture.html#staged-build-plan"},{"type":"extras","title":"Stage 1 — The Loop (MVP) - Architecture","doc":"> Goal: Send a prompt, get a streamed response, execute tools, repeat.\n> Dependencies: [`req`](https://hexdocs.pm/req) (~> 0.5), [`jason`](https://hexdocs.pm/jason) (~> 1.4)\n\nThis is the beating heart. Everything else is scaffolding around it.\n\n#### Modules\n\n**`Opal.Agent`** — GenServer\n\nThe agent loop as a stateful process. Holds the system prompt, message history,\ntools, model config, and streaming state.\n\n```elixir\n# Public API\nOpal.Agent.prompt(agent, \"What files are in src/?\")\nOpal.Agent.steer(agent, \"Actually, focus on lib/ instead\")\nOpal.Agent.follow_up(agent, \"Now write tests for those\")\nOpal.Agent.abort(agent)\nOpal.Agent.get_state(agent)\nOpal.Agent.platform(agent)  # :linux | :macos | :windows\n```\n\nInternal state:\n\n```elixir\n%Opal.Agent.State{\n  system_prompt: String.t(),\n  messages: [Opal.Message.t()],\n  model: Opal.Model.t(),   # e.g. %{provider: :copilot, id: \"claude-sonnet-4-5\"}\n  tools: [Opal.Tool.t()],\n  thinking_level: :off | :low | :medium | :high,\n  streaming?: boolean(),\n  pending_tool_calls: MapSet.t()\n}\n```\n\nThe loop:\n\n1. Receive `prompt` cast → append user message → call LLM\n2. Stream response tokens → broadcast `:message_update` events\n3. If response contains tool calls → execute each tool (via TaskSupervisor)\n4. Append tool results → call LLM again (next turn)\n5. If no tool calls → broadcast `:agent_end` → return to idle\n6. Between tool executions, check mailbox for steering messages\n\nSteering is natural: `steer/2` sends a message to the GenServer's mailbox.\nBetween tool executions, the loop does a selective `receive` to check for\nsteering — no polling, no callbacks, just the mailbox.\n\n**`Opal.Provider`** — Behaviour\n\n```elixir\ndefmodule Opal.Provider do\n  @callback stream(model, context, opts) :: {:ok, stream_ref} | {:error, term}\n  @callback parse_event(raw_event) :: Opal.Provider.Event.t()\n  @callback models() :: [Opal.Model.t()]\nend\n```\n\nStage 1 ships with `Opal.Provider.Copilot` — GitHub Copilot via the OpenAI\nResponses API. This is the only provider we build initially; the behaviour is\nready for others later.\n\n**Why Copilot first?**\n\n- Free for anyone with a GitHub account (Copilot Free tier)\n- Uses the OpenAI Responses API wire format, so the same code path covers\n  direct OpenAI usage later with minimal changes\n- Device-code OAuth flow — no manual API key management needed\n- Access to Claude, GPT-4o, o3, and other models through one endpoint\n\n**`Opal.Provider.Copilot`** — the GitHub Copilot provider\n\nThe provider implements the OpenAI Responses API streaming protocol, with\nCopilot-specific headers and OAuth token management. All HTTP is done via\n[Req](https://hexdocs.pm/req) (`~> 0.5`). Reference implementation:\n[Pi's openai-responses.ts](https://github.com/badlogic/pi-mono/blob/main/packages/ai/src/providers/openai-responses.ts)\nand [github-copilot.ts](https://github.com/badlogic/pi-mono/blob/main/packages/ai/src/utils/oauth/github-copilot.ts).\n\nKey implementation details from the reference:\n\n**Authentication — Device Code OAuth Flow:**\n\n1. POST `https://github.com/login/device/code` with client ID → get\n   `device_code`, `user_code`, `verification_uri`\n2. User visits URL, enters code\n3. Poll `https://github.com/login/oauth/access_token` until granted\n4. Exchange GitHub access token → Copilot API token via\n   `https://api.github.com/copilot_internal/v2/token`\n5. Parse `proxy-ep` from Copilot token to derive the API base URL\n   (e.g. `https://api.individual.githubcopilot.com`)\n6. Token expires → refresh using the stored GitHub access token\n\nThe token is stored on disk in `Opal.Config.data_dir()/auth.json`.\nRe-login only when refresh fails. All HTTP calls in the auth flow use `Req`.\n\n```elixir\ndefmodule Opal.Auth do\n  @moduledoc \"Manages Copilot OAuth credentials.\"\n\n  @copilot_headers %{\n    \"user-agent\" => \"GitHubCopilotChat/0.35.0\",\n    \"editor-version\" => \"vscode/1.107.0\",\n    \"editor-plugin-version\" => \"copilot-chat/0.35.0\",\n    \"copilot-integration-id\" => \"vscode-chat\"\n  }\n\n  defp client_id, do: Opal.Config.copilot(:client_id) || \"Iv1.b507a08c87ecfe98\"\n  defp domain,    do: Opal.Config.copilot(:domain) || \"github.com\"\n\n  def start_device_flow(dom \\\\ domain()) do\n    Req.post!(\"https://#{dom}/login/device/code\",\n      json: %{client_id: client_id(), scope: \"read:user\"},\n      headers: %{\"accept\" => \"application/json\"})\n    |> Map.get(:body)\n    # => %{\"device_code\" => ..., \"user_code\" => ..., \"verification_uri\" => ...}\n  end\n\n  def poll_for_token(domain, device_code, interval_ms) do\n    # Poll with Req, handle \"authorization_pending\" / \"slow_down\"\n    Req.post!(\"https://#{domain}/login/oauth/access_token\",\n      json: %{client_id: client_id(), device_code: device_code,\n              grant_type: \"urn:ietf:params:oauth:grant-type:device_code\"},\n      headers: %{\"accept\" => \"application/json\"})\n  end\n\n  def exchange_copilot_token(github_token, domain \\\\ \"github.com\") do\n    Req.get!(\"https://api.#{domain}/copilot_internal/v2/token\",\n      auth: {:bearer, github_token},\n      headers: @copilot_headers)\n    |> Map.get(:body)\n    # => %{\"token\" => ..., \"expires_at\" => ...}\n  end\n\n  def get_token do\n    # Load from disk, refresh if expired via exchange_copilot_token/2\n  end\nend\n```\n\n**Request Format — OpenAI Responses API (streaming via Req):**\n\nThe key insight: `Req.post!/2` with `into: :self` streams SSE chunks directly\ninto the calling process's mailbox — perfect for a GenServer. The provider\nprocess receives raw SSE data as messages, parses them with\n`Req.parse_message/2`, and dispatches events.\n\n```elixir\ndefmodule Opal.Provider.Copilot do\n  @behaviour Opal.Provider\n\n  @impl true\n  def stream(model, context, opts) do\n    token = Opal.Auth.get_token()\n    base_url = Opal.Auth.base_url(token)\n    messages = convert_messages(model, context)\n\n    req = Req.new(\n      base_url: base_url,\n      auth: {:bearer, token},\n      headers: copilot_headers(context)\n    )\n\n    # into: :self streams SSE into the GenServer mailbox\n    resp = Req.post!(req,\n      url: \"/v1/responses\",\n      json: %{\n        model: model.id,\n        input: messages,\n        stream: true,\n        store: false,\n        tools: convert_tools(context.tools)\n      },\n      into: :self\n    )\n\n    {:ok, resp}  # caller iterates via Req.parse_message/2 or Enum\n  end\nend\n```\n\nIn the `Opal.Agent` GenServer, incoming stream chunks arrive as regular\nmessages handled in `handle_info/2`:\n\n```elixir\n# In Opal.Agent\ndef handle_info(message, %{streaming_resp: resp} = state) do\n  case Req.parse_message(resp, message) do\n    {:ok, [{:data, data}]} ->\n      data\n      |> parse_sse_line()\n      |> dispatch_event(state)\n\n    {:ok, [:done]} ->\n      finalize_response(state)\n\n    {:error, reason} ->\n      handle_stream_error(reason, state)\n\n    :unknown ->\n      {:noreply, state}\n  end\nend\n```\n\n**Copilot-specific headers** (set via `Req.new/1` `:headers`):\n\n```elixir\ndefp copilot_headers(context) do\n  last_role = context.messages |> List.last() |> Map.get(:role, \"user\")\n  %{\n    \"user-agent\" => \"GitHubCopilotChat/0.35.0\",\n    \"editor-version\" => \"vscode/1.107.0\",\n    \"editor-plugin-version\" => \"copilot-chat/0.35.0\",\n    \"copilot-integration-id\" => \"vscode-chat\",\n    \"openai-intent\" => \"conversation-edits\",\n    \"x-initiator\" => if(last_role != \"user\", do: \"agent\", else: \"user\")\n  }\nend\n```\n\n**Streaming SSE events** to handle (from `processResponsesStream`):\n\n| Event                                                | What to do                                              |\n| ---------------------------------------------------- | ------------------------------------------------------- |\n| `response.output_item.added` (type: `reasoning`)     | Push `{:thinking_start, ...}`                           |\n| `response.reasoning_summary_text.delta`              | Accumulate thinking text, push `{:thinking_delta, ...}` |\n| `response.output_item.added` (type: `message`)       | Push `{:text_start, ...}`                               |\n| `response.output_text.delta`                         | Accumulate text, push `{:message_delta, ...}`           |\n| `response.output_item.added` (type: `function_call`) | Push `{:tool_call_start, ...}`                          |\n| `response.function_call_arguments.delta`             | Accumulate JSON args, push `{:tool_call_delta, ...}`    |\n| `response.function_call_arguments.done`              | Parse final JSON args                                   |\n| `response.output_item.done` (type: `function_call`)  | Emit complete `ToolCall` struct                         |\n| `response.completed`                                 | Extract usage stats, determine stop reason              |\n| `error` / `response.failed`                          | Emit error event                                        |\n\n**Message conversion** (internal → Responses API input):\n\n- User messages → `%{role: \"user\", content: [%{type: \"input_text\", text: ...}]}`\n- Assistant text → `%{type: \"message\", role: \"assistant\", content: [%{type: \"output_text\", text: ...}], ...}`\n- Tool calls → `%{type: \"function_call\", call_id: ..., name: ..., arguments: ...}`\n- Tool results → `%{type: \"function_call_output\", call_id: ..., output: ...}`\n- System prompt → `%{role: \"developer\", content: ...}` (for reasoning models)\n  or `%{role: \"system\", content: ...}` (otherwise)\n\n**Tool conversion:**\n\n```elixir\ndef convert_tools(tools) do\n  Enum.map(tools, fn tool ->\n    %{type: \"function\", name: tool.name(),\n      description: tool.description(),\n      parameters: tool.parameters(), strict: false}\n  end)\nend\n```\n\n**`Opal.Tool`** — Behaviour\n\n```elixir\ndefmodule Opal.Tool do\n  @callback name() :: String.t()\n  @callback description() :: String.t()\n  @callback parameters() :: Opal.Schema.t()   # JSON Schema-ish\n  @callback execute(args :: map(), context :: map()) ::\n    {:ok, result :: String.t()} | {:error, reason :: String.t()}\nend\n```\n\nStage 1 tools:\n\n- `Opal.Tool.Read` — read files\n- `Opal.Tool.Write` — write files\n- `Opal.Tool.Edit` — search-and-replace edits\n- `Opal.Tool.Shell` — run shell commands (cross-platform)\n\n**`Opal.Tool.Shell`** — Cross-platform shell execution\n\nPi's `bash` tool assumes POSIX. Opal's `Shell` tool detects the platform and\nacts accordingly:\n\n```elixir\n# Internal dispatch:\ncase :os.type() do\n  {:unix, _}  -> System.cmd(\"sh\", [\"-c\", command], opts)\n  {:win32, _} -> System.cmd(\"cmd\", [\"/C\", command], opts)\nend\n```\n\nThe tool name exposed to the LLM matches the configured shell (`\"shell\"`,\n`\"bash\"`, `\"cmd\"`, `\"powershell\"`, etc.) so the model generates appropriate\nsyntax. On Windows, commands run via `cmd.exe` by default, with an option to\nuse PowerShell:\n\n```elixir\n# In session config:\nOpal.start_session(%{\n  shell: :powershell,  # :cmd (default on Windows) | :powershell | :sh (default on Unix)\n  ...\n})\n```\n\n**`Opal.Path`** — Path normalization\n\nAll internal path handling uses `Path` module functions (`Path.join/2`,\n`Path.expand/1`, `Path.relative_to/2`) which are already cross-platform in\nElixir. The working directory and any tool arguments go through normalization:\n\n```elixir\ndefmodule Opal.Path do\n  def normalize(path) do\n    path\n    |> String.replace(\"\\\\\", \"/\")   # normalize separators for internal use\n    |> Path.expand()\n  end\n\n  def to_native(path) do\n    case :os.type() do\n      {:win32, _} -> String.replace(path, \"/\", \"\\\\\")\n      _ -> path\n    end\n  end\nend\n```\n\n**`Opal.Events`** — Registry-based pubsub\n\n```elixir\n# Subscribe to all events from a session\nOpal.Events.subscribe(session_id)\n\n# In your process\nreceive do\n  {:opal_event, ^session_id, {:agent_start}} -> ...\n  {:opal_event, ^session_id, {:message_update, delta}} -> ...\n  {:opal_event, ^session_id, {:tool_execution_start, tool, args}} -> ...\n  {:opal_event, ^session_id, {:tool_execution_end, tool, result}} -> ...\n  {:opal_event, ^session_id, {:turn_end, message, tool_results}} -> ...\n  {:opal_event, ^session_id, {:agent_end, messages}} -> ...\nend\n```\n\nAny process in the VM can subscribe. Your LiveView, your CLI, your monitoring\ndashboard, another agent — they all get the same event stream with zero\nserialization overhead.\n\n**`Opal.Config`** — Configuration\n\nOpal uses Elixir's native application configuration as the foundation. Defaults\nare sensible, the host app overrides via `config :opal`, and individual sessions\ncan override further at startup.\n\n**Priority (highest wins):**\n\n1. Session config — `Opal.start_session(%{data_dir: ..., shell: ..., ...})`\n2. Application config — `config :opal, data_dir: \"~/.opal\"`\n3. Environment variables — `OPAL_DATA_DIR`, `OPAL_SHELL`\n4. Built-in defaults\n\n**`config/config.exs`** (in the host app):\n\n```elixir\nconfig :opal,\n  data_dir: \"~/.opal\",\n  shell: :zsh,\n  default_model: {\"copilot\", \"claude-sonnet-4-5\"},\n  default_tools: [Opal.Tool.Read, Opal.Tool.Write, Opal.Tool.Edit, Opal.Tool.Shell],\n  copilot: [\n    client_id: \"Iv1.b507a08c87ecfe98\",\n    domain: \"github.com\"\n  ]\n```\n\n**`config/runtime.exs`** (for env-var-driven deploys/CI):\n\n```elixir\nconfig :opal,\n  data_dir: System.get_env(\"OPAL_DATA_DIR\", \"~/.opal\"),\n  shell: System.get_env(\"OPAL_SHELL\", \"sh\") |> String.to_existing_atom()\n```\n\n**Module:**\n\n```elixir\ndefmodule Opal.Config do\n  @moduledoc \"\"\"\n  Reads Opal configuration from Application env with per-session overrides.\n  \"\"\"\n\n  @defaults %{\n    data_dir: \"~/.opal\",\n    shell: nil,              # nil = auto-detect per platform\n    default_model: {\"copilot\", \"claude-sonnet-4-5\"},\n    default_tools: [Opal.Tool.Read, Opal.Tool.Write, Opal.Tool.Edit, Opal.Tool.Shell]\n  }\n\n  @doc \"Get a config value. Session overrides > Application env > defaults.\"\n  def get(key, session_opts \\\\ %{}) do\n    case Map.get(session_opts, key) do\n      nil -> Application.get_env(:opal, key, Map.get(@defaults, key))\n      val -> val\n    end\n  end\n\n  @doc \"Resolved data directory (expanded to absolute path).\"\n  def data_dir(session_opts \\\\ %{}),  do: get(:data_dir, session_opts) |> Path.expand()\n  def sessions_dir(opts \\\\ %{}),      do: Path.join(data_dir(opts), \"sessions\")\n  def auth_file(opts \\\\ %{}),         do: Path.join(data_dir(opts), \"auth.json\")\n  def logs_dir(opts \\\\ %{}),          do: Path.join(data_dir(opts), \"logs\")\n\n  @doc \"Resolved shell — session override, app config, or platform default.\"\n  def shell(session_opts \\\\ %{}) do\n    case get(:shell, session_opts) do\n      nil -> Opal.Tool.Shell.default_shell()\n      shell -> shell\n    end\n  end\n\n  @doc \"Ensures the data directory tree exists.\"\n  def ensure_dirs!(opts \\\\ %{}) do\n    for dir <- [data_dir(opts), sessions_dir(opts), logs_dir(opts)] do\n      File.mkdir_p!(dir)\n    end\n  end\n\n  @doc \"All copilot-specific config.\"\n  def copilot(key) do\n    :opal |> Application.get_env(:copilot, []) |> Keyword.get(key)\n  end\nend\n```\n\nDirectory layout:\n\n```\n~/.opal/\n├── auth.json          # Copilot OAuth tokens\n├── sessions/          # Saved conversation trees\n│   ├──  .etf\n│   └── ...\n├── logs/              # Agent logs (optional)\n└── skills/            # User-defined skill files (optional)\n```\n\n**`Opal`** — Public API / Entry point\n\n```elixir\n# Start a session (returns pid of the session supervisor)\n# Uses defaults from `config :opal` — override per-session as needed.\n{:ok, session} = Opal.start_session(%{\n  model: {\"copilot\", \"claude-sonnet-4-5\"},\n  system_prompt: \"You are a helpful coding assistant.\",\n  working_dir: \"/path/to/project\"\n  # tools:    defaults from config :opal, :default_tools\n  # shell:    defaults from config :opal, :shell (or platform auto-detect)\n  # data_dir: defaults from config :opal, :data_dir (~/.opal)\n})\n\n# Send a prompt (async — subscribe to events for output)\n:ok = Opal.prompt(session, \"List all Elixir files\")\n\n# Or synchronous convenience\n{:ok, response} = Opal.prompt_sync(session, \"What is 2 + 2?\")\n```\n\n#### What You Can Do After Stage 1\n\n- Embed Opal in any Elixir app and have a working coding agent\n- Stream LLM output to any subscriber\n- Execute tools (file ops + shell)\n- Steer the agent mid-run\n- Inspect agent state via `:observer` or `:sys.get_state/1`\n\n#### Testing the Provider\n\n`Req.Test` lets you plug in a fake adapter so tests never hit the network:\n\n```elixir\n# In test setup:\nReq.Test.stub(Opal.Provider.Copilot, fn conn ->\n  conn\n  |> Plug.Conn.put_resp_content_type(\"text/event-stream\")\n  |> Plug.Conn.send_resp(200, sse_fixture(\"simple_response\"))\nend)\n```\n\nThis gives us deterministic, fast tests for the entire SSE parsing and event\ndispatch pipeline — no mocking libraries, no network.\n\n- Crash-recover individual sessions without taking down the app\n\n---","ref":"architecture.html#stage-1-the-loop-mvp"},{"type":"extras","title":"Stage 2 — Sessions & Persistence - Architecture","doc":"> Goal: Save and restore conversations. Branch and navigate history.\n\n**`Opal.Session`** — GenServer\n\nManages the conversation tree. Each message gets an ID and a parent ID, exactly\nlike Pi's JSONL tree — but backed by ETS for fast in-memory access and optionally\nDETS or a file for persistence.\n\n```elixir\nOpal.Session.save(session)           # persist current state\nOpal.Session.branch(session, entry_id) # rewind to a point\nOpal.Session.get_tree(session)       # full tree structure\nOpal.Session.get_path(session)       # root → current leaf\nOpal.Session.list_sessions(dir)      # enumerate saved sessions\n```\n\nSession format: Erlang term storage (`.etf`) or JSONL for interop. We don't need\nto match Pi's format — we need something that's fast to read/write from the BEAM.\n\n**`Opal.Session.Compaction`**\n\nWhen context gets long, summarize older messages. Same idea as Pi but\nimplemented as a separate pass that the Agent can trigger:\n\n```elixir\nOpal.Session.compact(session, keep_recent: 10)\n```\n\n---","ref":"architecture.html#stage-2-sessions-persistence"},{"type":"extras","title":"Stage 3 — Sub-Agents & Parallelism - Architecture","doc":"> Goal: Spawn child agents that work in parallel.\n\nThis is where OTP shines and Pi explicitly punts. Pi says \"spawn tmux sessions\"\nor \"build it with extensions.\" We say: `DynamicSupervisor.start_child/2`.\n\n**`Opal.SubAgent`**\n\nA sub-agent is just another `Opal.Agent` started under the parent session's\nsupervisor. It gets its own process, its own message history, its own tool set.\n\n```elixir\n# From within a tool or the parent agent:\n{:ok, sub} = Opal.SubAgent.spawn(parent_session, %{\n  system_prompt: \"You are a test-writing specialist.\",\n  tools: [Opal.Tool.Read, Opal.Tool.Write, Opal.Tool.Shell],\n  model: {\"copilot\", \"claude-haiku-3-5\"}\n})\n\n{:ok, result} = Opal.SubAgent.run(sub, \"Write tests for lib/opal/agent.ex\")\n```\n\nThe parent can spawn N sub-agents in parallel, each working on different files or\ntasks. The supervision tree ensures cleanup:\n\n```\nSessionSupervisor\n├── Opal.Agent (parent)\n├── Opal.Session\n├── Opal.ToolSup\n└── Opal.SubAgentSup (DynamicSupervisor)\n    ├── SubAgent session 1\n    │   ├── Opal.Agent\n    │   └── Opal.ToolSup\n    ├── SubAgent session 2\n    │   ├── Opal.Agent\n    │   └── Opal.ToolSup\n    └── ... N agents\n```\n\nIf a sub-agent crashes, only that sub-agent restarts. The parent and siblings\nare unaffected. If the parent session is torn down, all sub-agents are cleaned\nup automatically. This is free from the supervision tree.\n\n**Parallel tool execution**\n\nEven within a single agent turn, Pi executes tool calls sequentially. We can\noptionally run independent tool calls concurrently via `Task.async_stream`:\n\n```elixir\n# When the LLM returns multiple tool calls in one response:\ntool_calls\n|> Task.async_stream(fn call -> execute_tool(call) end, max_concurrency: 4)\n|> Enum.map(fn {:ok, result} -> result end)\n```\n\n---","ref":"architecture.html#stage-3-sub-agents-parallelism"},{"type":"extras","title":"Stage 4 — Context Files & Skills - Architecture","doc":"> Goal: Load project context and reusable instruction sets.\n\n**`Opal.Context`**\n\nWalk up from `cwd`, collect `AGENTS.md` / `OPAL.md` files, concatenate into the\nsystem prompt. Simple file-system walk, no magic.\n\n```elixir\ncontext_files = Opal.Context.discover(working_dir)\n# Returns list of %{path: ..., content: ...}\n```\n\n**`Opal.Skill`** — Behaviour (optional)\n\n```elixir\ndefmodule Opal.Skill do\n  @callback name() :: String.t()\n  @callback description() :: String.t()\n  @callback instructions() :: String.t()  # Markdown content\nend\n```\n\nSkills are just modules that provide markdown instructions to append to the\nsystem prompt on demand. No file-system discovery needed — they're Hex packages\nor modules in your app.\n\n---","ref":"architecture.html#stage-4-context-files-skills"},{"type":"extras","title":"Stage 5 — MCP Client Integration - Architecture","doc":"> Goal: Connect to external MCP servers and expose their tools to the agent.\n> Dependency: [`anubis_mcp`](https://hexdocs.pm/anubis_mcp) (~> 0.17)\n\nOpal acts as an MCP _host_ (in MCP terminology). Rather than hand-rolling\nJSON-RPC 2.0 framing, transport management, and protocol lifecycle, we lean on\n**Anubis MCP** — a mature Elixir SDK that already provides all of this as\nsupervised processes with a `use Anubis.Client` DSL.\n\nOur job is thin: define one Anubis client module per MCP server, start them\nunder the session supervisor, discover their tools, and bridge those tools into\nthe `Opal.Tool` interface so the agent can't tell the difference.\n\n#### What Anubis Gives Us (for free)\n\n| Concern             | Anubis handles it                                                   |\n| ------------------- | ------------------------------------------------------------------- |\n| **Transports**      | `:stdio`, `:streamable_http`, `:websocket`, `:sse` — all built-in   |\n| **Lifecycle**       | `initialize` → capability negotiation → `notifications/initialized` |\n| **Tool ops**        | `list_tools/0`, `call_tool/2,3`, progress callbacks, timeouts       |\n| **Resource ops**    | `list_resources/0`, `read_resource/1`                               |\n| **Supervision**     | Each client is a child spec, drops into any supervisor tree         |\n| **Named instances** | `Supervisor.child_spec/2` with `id:` for multiple servers           |\n| **Protocol**        | JSON-RPC 2.0 framing, message validation via Peri schemas           |\n\nThis means we write _zero_ transport code and _zero_ protocol code.\n\n#### Architecture\n\n```\nSessionSupervisor\n├── Opal.Agent\n├── Opal.Session\n├── Opal.ToolSup\n└── Opal.MCP.Supervisor          (plain Supervisor, one_for_one)\n    ├── Opal.MCP.Client :fs       (Anubis.Client — stdio)\n    ├── Opal.MCP.Client :sentry   (Anubis.Client — streamable_http)\n    └── ...\n```\n\n**`Opal.MCP.Client`** — dynamic Anubis client module\n\nWe generate one `use Anubis.Client` module per configured MCP server at\nruntime. Each module is a supervised GenServer that Anubis manages internally.\n\n```elixir\ndefmodule Opal.MCP.Client do\n  @moduledoc \"\"\"\n  Dynamically defines and starts an Anubis MCP client for each\n  configured MCP server.\n  \"\"\"\n\n  use Anubis.Client,\n    name: \"Opal\",\n    version: \"0.1.0\",\n    protocol_version: \"2025-03-26\",\n    capabilities: [:roots]\n\n  @doc \"\"\"\n  Build a child spec for a named MCP server connection.\n  \"\"\"\n  def child_spec(%{name: server_name, transport: transport_config}) do\n    Supervisor.child_spec(\n      {__MODULE__, transport: transport_config, name: server_name},\n      id: {:mcp, server_name}\n    )\n  end\nend\n```\n\n**`Opal.MCP.Supervisor`** — plain Supervisor\n\nStarts one `Opal.MCP.Client` child per configured server.\n\n```elixir\ndefmodule Opal.MCP.Supervisor do\n  use Supervisor\n\n  def start_link(mcp_servers) do\n    Supervisor.start_link(__MODULE__, mcp_servers, name: __MODULE__)\n  end\n\n  @impl true\n  def init(mcp_servers) do\n    children = Enum.map(mcp_servers, &Opal.MCP.Client.child_spec/1)\n    Supervisor.init(children, strategy: :one_for_one)\n  end\nend\n```\n\n**`Opal.MCP.Bridge`** — tool bridge\n\nAfter each Anubis client connects, `Bridge` calls `list_tools/0` on the\nclient and wraps each discovered MCP tool into the `Opal.Tool` format that\nthe agent already understands. No new behaviour needed — just a data\ntransformation.\n\n```elixir\ndefmodule Opal.MCP.Bridge do\n  @moduledoc \"\"\"\n  Discovers tools from connected Anubis clients and presents them\n  as Opal-compatible tool definitions for the agent's tool list.\n  \"\"\"\n\n  @doc \"\"\"\n  Given a named MCP client, return a list of Opal tool maps.\n  \"\"\"\n  def discover_tools(client_name) do\n    {:ok, %{result: %{\"tools\" => tools}}} =\n      Opal.MCP.Client.list_tools(client_name)\n\n    Enum.map(tools, fn tool ->\n      %{\n        name: \"mcp__#{client_name}__#{tool[\"name\"]}\",\n        description: tool[\"description\"],\n        parameters: tool[\"inputSchema\"],\n        execute: fn args ->\n          case Opal.MCP.Client.call_tool(client_name, tool[\"name\"], args) do\n            {:ok, %{is_error: false, result: result}} -> {:ok, result}\n            {:ok, %{is_error: true, result: err}}     -> {:error, err}\n            {:error, reason}                          -> {:error, reason}\n          end\n        end\n      }\n    end)\n  end\n\n  @doc \"\"\"\n  Discover tools from all running MCP clients.\n  \"\"\"\n  def discover_all_tools(mcp_servers) do\n    mcp_servers\n    |> Enum.flat_map(fn %{name: name} -> discover_tools(name) end)\n  end\nend\n```\n\nTool names are namespaced as `mcp__ __ ` to avoid collisions with\nnative `Opal.Tool` modules (e.g. `mcp__sentry__search_issues`).\n\n**`Opal.MCP.Resources`** — resource injection\n\nSame pattern for resources — discover them via `list_resources/0` and\n`read_resource/1`, then inject their contents into the agent's context.\n\n```elixir\ndefmodule Opal.MCP.Resources do\n  def list(client_name) do\n    {:ok, %{result: %{\"resources\" => resources}}} =\n      Opal.MCP.Client.list_resources(client_name)\n    resources\n  end\n\n  def read(client_name, uri) do\n    {:ok, %{result: %{\"contents\" => contents}}} =\n      Opal.MCP.Client.read_resource(client_name, uri)\n    contents\n  end\nend\n```\n\n#### Session configuration\n\n```elixir\n{:ok, session} = Opal.start_session(%{\n  model: {\"copilot\", \"claude-sonnet-4-5\"},\n  tools: [Opal.Tool.Read, Opal.Tool.Write, Opal.Tool.Edit, Opal.Tool.Shell],\n  mcp_servers: [\n    %{name: :filesystem,\n      transport: {:stdio, command: \"npx\",\n                  args: [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path\"]}},\n    %{name: :sentry,\n      transport: {:streamable_http,\n                  base_url: \"https://mcp.sentry.dev\",\n                  headers: [{\"Authorization\", \"Bearer ...\"}]}},\n    %{name: :db,\n      transport: {:stdio, command: \"python\", args: [\"db_server.py\"]}}\n  ],\n  system_prompt: \"You are a helpful coding assistant.\",\n  working_dir: File.cwd!()\n})\n```\n\nOn session start, `Opal.MCP.Supervisor` launches one Anubis client per entry.\nEach client connects, negotiates, and is ready. Then `Opal.MCP.Bridge` walks\nall clients, discovers their tools, and merges them into the agent's flat tool\nlist. The agent loop calls MCP tools the same way it calls native tools — the\nbridge closure routes the call through Anubis.\n\n#### Why Anubis + OTP supervision?\n\n| Concern            | How it works                                                                                                   |\n| ------------------ | -------------------------------------------------------------------------------------------------------------- |\n| MCP server crashes | Anubis client process dies, supervisor restarts it, Anubis re-negotiates automatically                         |\n| Slow MCP server    | `call_tool/3` supports `:timeout` option; doesn't block other tools                                            |\n| Multiple servers   | Each is an independent child — parallel startup, independent failure domains                                   |\n| Cleanup            | Session supervisor shutdown cascades through `Opal.MCP.Supervisor` to all Anubis clients, each calls `close/0` |\n| Transport choice   | Config-driven — swap `:stdio` for `:streamable_http` without code changes                                      |\n| Progress tracking  | Anubis built-in `progress:` option with token + callback                                                       |\n\n#### What MCP Gets You\n\n- Access to the entire MCP server ecosystem (filesystem, databases, Sentry,\n  GitHub, Slack, etc.) without writing Elixir wrappers for each\n- Remote tool execution via HTTP transport — tools on another machine\n- Resource injection — MCP servers can provide context (file contents, DB\n  schemas) that gets appended to the system prompt\n- Dynamic tool updates — servers can add/remove tools at runtime via\n  notifications, and the agent picks them up immediately\n\n#### What We Don't Build\n\nBecause Anubis handles it:\n\n- ❌ JSON-RPC 2.0 framing / message parsing\n- ❌ Transport implementations (stdio, HTTP, WebSocket, SSE)\n- ❌ Protocol lifecycle (`initialize` / capability negotiation)\n- ❌ Progress token management\n- ❌ Message validation schemas\n\n---","ref":"architecture.html#stage-5-mcp-client-integration"},{"type":"extras","title":"Stage 5.5 — RPC Server (Headless Mode) - Architecture","doc":"> Goal: Ship Opal as both a library and a standalone binary that any language\n> can drive over JSON-RPC 2.0. The `opal --daemon` flag activates headless mode\n> for external clients.\n\n**The TUI is now built-in.** The `opal` binary defaults to interactive mode\nusing TermUI (Elm Architecture). Headless JSON-RPC mode is available via\n`opal --daemon` for external consumers that want to build their own frontends.\nThe Elixir `mix opal.chat` task remains as a debugging utility.\n\n#### Design Decision: JSON-RPC 2.0 over stdio\n\nWe evaluated gRPC, WebSocket, HTTP+SSE, and custom binary protocols. **JSON-RPC\n2.0 over stdio** wins on every axis that matters for the daemon mode:\n\n| Concern            | JSON-RPC stdio                                                |\n| ------------------ | ------------------------------------------------------------- |\n| **Proven pattern** | Same protocol as LSP and MCP — well-understood, battle-tested |\n| **Distribution**   | `opal --daemon` — no ports, firewall, TLS              |\n| **Bidirectional**  | Both sides send requests + responses (like LSP)               |\n| **Streaming**      | Notifications — no SSE, no WebSocket, no special mechanism    |\n| **Cross-platform** | stdin/stdout identical on macOS, Linux, Windows               |\n| **Self-contained** | ~200 lines of Elixir — `Opal.RPC` owns the codec, no deps     |\n| **Future SDKs**    | Protocol spec is a markdown doc — any language implements     |\n| **TS ecosystem**   | `vscode-jsonrpc` (6M+ downloads/week)                         |\n\nThe one constraint — single client per process — is the _correct_ constraint\nfor a CLI. One terminal = one agent. If we ever need multi-client (web UI,\nIDE extension), we add a WebSocket or HTTP transport behind the same protocol\nlayer; only the transport changes, the methods stay identical.\n\n#### Protocol Specification\n\nThe wire format is **newline-delimited JSON** on stdin/stdout. Each message is a\nsingle JSON object followed by `\\n`. Stderr is reserved for unstructured logs.\nThis matches the MCP stdio transport convention.\n\n##### Requests (Client → Server)\n\nStandard JSON-RPC 2.0 requests with `id`, `method`, `params`:\n\n```jsonc\n// Start or resume a session\n{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"session/start\", \"params\": {\n  \"model\": {\"provider\": \"copilot\", \"id\": \"claude-sonnet-4-5\"},\n  \"system_prompt\": \"You are a helpful coding assistant.\",\n  \"working_dir\": \"/Users/me/project\",\n  \"tools\": [\"read\", \"write\", \"edit\", \"shell\"],\n  \"mcp_servers\": [\n    {\"name\": \"filesystem\", \"transport\": {\"type\": \"stdio\",\n      \"command\": \"npx\", \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path\"]}}\n  ]\n}}\n// => {\"jsonrpc\": \"2.0\", \"id\": 1, \"result\": {\"session_id\": \"abc123\"}}\n\n// Send a prompt (async — results stream as notifications)\n{\"jsonrpc\": \"2.0\", \"id\": 2, \"method\": \"agent/prompt\", \"params\": {\n  \"session_id\": \"abc123\",\n  \"text\": \"List all Elixir files in lib/\"\n}}\n// => {\"jsonrpc\": \"2.0\", \"id\": 2, \"result\": {\"ok\": true}}\n\n// Steer the agent mid-run\n{\"jsonrpc\": \"2.0\", \"id\": 3, \"method\": \"agent/steer\", \"params\": {\n  \"session_id\": \"abc123\",\n  \"text\": \"Actually, focus on test/ instead\"\n}}\n\n// Abort the current run\n{\"jsonrpc\": \"2.0\", \"id\": 4, \"method\": \"agent/abort\", \"params\": {\n  \"session_id\": \"abc123\"\n}}\n\n// Get agent state\n{\"jsonrpc\": \"2.0\", \"id\": 5, \"method\": \"agent/state\", \"params\": {\n  \"session_id\": \"abc123\"\n}}\n// => {\"jsonrpc\": \"2.0\", \"id\": 5, \"result\": {\"status\": \"idle\", \"model\": ...}}\n\n// Session management\n{\"jsonrpc\": \"2.0\", \"id\": 6, \"method\": \"session/branch\", \"params\": {\n  \"session_id\": \"abc123\", \"entry_id\": \"msg-42\"\n}}\n{\"jsonrpc\": \"2.0\", \"id\": 7, \"method\": \"session/compact\", \"params\": {\n  \"session_id\": \"abc123\", \"keep_recent\": 10\n}}\n{\"jsonrpc\": \"2.0\", \"id\": 8, \"method\": \"session/list\", \"params\": {}}\n\n// Auth\n{\"jsonrpc\": \"2.0\", \"id\": 9, \"method\": \"auth/status\", \"params\": {}}\n{\"jsonrpc\": \"2.0\", \"id\": 10, \"method\": \"auth/login\", \"params\": {}}\n\n// Model listing\n{\"jsonrpc\": \"2.0\", \"id\": 11, \"method\": \"models/list\", \"params\": {}}\n```\n\n##### Notifications (Server → Client)\n\nStreaming events are JSON-RPC 2.0 **notifications** (no `id` — fire and forget).\nThese map 1:1 to `Opal.Events`:\n\n```jsonc\n// Agent lifecycle\n{\"jsonrpc\": \"2.0\", \"method\": \"agent/event\", \"params\": {\n  \"session_id\": \"abc123\", \"type\": \"agent_start\"\n}}\n\n// LLM text streaming (one per token delta)\n{\"jsonrpc\": \"2.0\", \"method\": \"agent/event\", \"params\": {\n  \"session_id\": \"abc123\", \"type\": \"message_delta\",\n  \"delta\": \"Here are the \"\n}}\n\n// Thinking/reasoning\n{\"jsonrpc\": \"2.0\", \"method\": \"agent/event\", \"params\": {\n  \"session_id\": \"abc123\", \"type\": \"thinking_delta\",\n  \"delta\": \"I should list the files...\"\n}}\n\n// Tool execution\n{\"jsonrpc\": \"2.0\", \"method\": \"agent/event\", \"params\": {\n  \"session_id\": \"abc123\", \"type\": \"tool_execution_start\",\n  \"tool\": \"shell\", \"call_id\": \"call_1\",\n  \"args\": {\"command\": \"find lib/ -name '*.ex'\"}\n}}\n{\"jsonrpc\": \"2.0\", \"method\": \"agent/event\", \"params\": {\n  \"session_id\": \"abc123\", \"type\": \"tool_execution_end\",\n  \"tool\": \"shell\", \"call_id\": \"call_1\",\n  \"result\": {\"ok\": true, \"output\": \"lib/opal.ex\\nlib/opal/agent.ex\\n...\"}\n}}\n\n// Turn and agent end\n{\"jsonrpc\": \"2.0\", \"method\": \"agent/event\", \"params\": {\n  \"session_id\": \"abc123\", \"type\": \"turn_end\",\n  \"message\": \"Found 12 Elixir files...\"\n}}\n{\"jsonrpc\": \"2.0\", \"method\": \"agent/event\", \"params\": {\n  \"session_id\": \"abc123\", \"type\": \"agent_end\"\n}}\n\n// Auth flow (device code)\n{\"jsonrpc\": \"2.0\", \"method\": \"auth/device_code\", \"params\": {\n  \"user_code\": \"ABCD-1234\",\n  \"verification_uri\": \"https://github.com/login/device\"\n}}\n```\n\n##### Server → Client Requests (Bidirectional)\n\nThe server can send requests _to_ the client that require a response. This\nis the LSP `window/showMessageRequest` pattern — essential for user\nconfirmation prompts, permission gates, etc.\n\n```jsonc\n// Server asks: \"Should I execute this command?\"\n{\"jsonrpc\": \"2.0\", \"id\": \"s2c-1\", \"method\": \"client/confirm\", \"params\": {\n  \"session_id\": \"abc123\",\n  \"title\": \"Execute shell command?\",\n  \"message\": \"rm -rf node_modules/\",\n  \"actions\": [\"allow\", \"deny\", \"allow_session\"]\n}}\n// Client responds:\n{\"jsonrpc\": \"2.0\", \"id\": \"s2c-1\", \"result\": {\"action\": \"allow\"}}\n\n// Server asks for user input\n{\"jsonrpc\": \"2.0\", \"id\": \"s2c-2\", \"method\": \"client/input\", \"params\": {\n  \"session_id\": \"abc123\",\n  \"prompt\": \"Enter your API key:\",\n  \"sensitive\": true\n}}\n// Client responds:\n{\"jsonrpc\": \"2.0\", \"id\": \"s2c-2\", \"result\": {\"text\": \"sk-...\"}}\n```\n\n#### Architecture\n\n```\n┌────────────────────────────────────────────────────────────┐\n│            Daemon mode (opal --daemon)                      │\n│   • Reads JSON-RPC requests from stdin                      │\n│   • Writes JSON-RPC responses/notifications to stdout       │\n│   • No TUI — designed for external clients/SDKs             │\n│                                                            │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │ Opal.RPC.Stdio (GenServer)                           │  │\n│  │  • Reads newline-delimited JSON from :stdio           │  │\n│  │  • Dispatches to Opal.RPC.Handler                     │  │\n│  │  • Writes responses + notifications to :stdio         │  │\n│  │  • Subscribes to Opal.Events, forwards as notifs      │  │\n│  └──────────────────┬───────────────────────────────────┘  │\n│                     │                                      │\n│  ┌──────────────────▼───────────────────────────────────┐  │\n│  │ Opal.RPC.Handler                                     │  │\n│  │  • \"session/start\"  → Opal.start_session/1            │  │\n│  │  • \"agent/prompt\"   → Opal.prompt/2                   │  │\n│  │  • \"agent/abort\"    → Opal.abort/1                    │  │\n│  │  • \"agent/state\"    → Opal.Agent.get_state/1          │  │\n│  │  • \"session/list\"   → Opal.Session.list_sessions/0    │  │\n│  │  • \"models/list\"    → Opal.Provider.models/1          │  │\n│  │  • \"auth/*\"         → Opal.Auth.*                     │  │\n│  └──────────────────┬───────────────────────────────────┘  │\n│                     │                                      │\n│          (calls into the normal Opal library API)          │\n│                                                            │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │              Opal (library — Stages 1-5)              │  │\n│  │  Agent, Session, Tools, MCP, Events, etc.             │  │\n│  └──────────────────────────────────────────────────────┘  │\n└────────────────────────────────────────────────────────────┘\n```\n\n#### Modules\n\n**`Opal.RPC`** — Protocol layer (transport-agnostic)\n\nEncode/decode JSON-RPC 2.0 messages. Stateless functions.\n\n```elixir\ndefmodule Opal.RPC do\n  @moduledoc \"\"\"\n  JSON-RPC 2.0 encoding/decoding. Transport-agnostic — used by\n  Opal.RPC.Stdio today, could be used by a WebSocket transport later.\n  \"\"\"\n\n  @type message :: request() | response() | notification()\n  @type request :: %{jsonrpc: String.t(), id: id(), method: String.t(), params: map()}\n  @type response :: %{jsonrpc: String.t(), id: id(), result: term()} |\n                    %{jsonrpc: String.t(), id: id(), error: error()}\n  @type notification :: %{jsonrpc: String.t(), method: String.t(), params: map()}\n  @type id :: integer() | String.t()\n  @type error :: %{code: integer(), message: String.t(), data: term()}\n\n  # Standard JSON-RPC error codes\n  @parse_error      -32700\n  @invalid_request  -32600\n  @method_not_found -32601\n  @invalid_params   -32602\n  @internal_error   -32603\n\n  def encode_request(id, method, params) do\n    Jason.encode!(%{jsonrpc: \"2.0\", id: id, method: method, params: params})\n  end\n\n  def encode_response(id, result) do\n    Jason.encode!(%{jsonrpc: \"2.0\", id: id, result: result})\n  end\n\n  def encode_error(id, code, message, data \\\\ nil) do\n    error = %{code: code, message: message}\n    error = if data, do: Map.put(error, :data, data), else: error\n    Jason.encode!(%{jsonrpc: \"2.0\", id: id, error: error})\n  end\n\n  def encode_notification(method, params) do\n    Jason.encode!(%{jsonrpc: \"2.0\", method: method, params: params})\n  end\n\n  def decode(json) do\n    case Jason.decode(json) do\n      {:ok, %{\"jsonrpc\" => \"2.0\", \"id\" => id, \"method\" => method} = msg} ->\n        {:request, id, method, Map.get(msg, \"params\", %{})}\n\n      {:ok, %{\"jsonrpc\" => \"2.0\", \"id\" => id, \"result\" => result}} ->\n        {:response, id, result}\n\n      {:ok, %{\"jsonrpc\" => \"2.0\", \"id\" => id, \"error\" => error}} ->\n        {:error_response, id, error}\n\n      {:ok, %{\"jsonrpc\" => \"2.0\", \"method\" => method} = msg} ->\n        {:notification, method, Map.get(msg, \"params\", %{})}\n\n      {:ok, _} -> {:error, :invalid_request}\n      {:error, _} -> {:error, :parse_error}\n    end\n  end\nend\n```\n\n**`Opal.RPC.Handler`** — Method dispatch\n\nMaps JSON-RPC methods to Opal library calls. Pure functions — receives method +\nparams, returns result or error. No transport awareness.\n\n```elixir\ndefmodule Opal.RPC.Handler do\n  @moduledoc \"\"\"\n  Dispatches JSON-RPC methods to Opal library functions.\n  Returns {:ok, result} | {:error, code, message, data}.\n  \"\"\"\n\n  def handle(\"session/start\", params) do\n    opts = decode_session_opts(params)\n    case Opal.start_session(opts) do\n      {:ok, session_id} -> {:ok, %{session_id: session_id}}\n      {:error, reason}  -> {:error, -32603, \"Failed to start session\", reason}\n    end\n  end\n\n  def handle(\"agent/prompt\", %{\"session_id\" => sid, \"text\" => text}) do\n    case Opal.prompt(sid, text) do\n      :ok          -> {:ok, %{ok: true}}\n      {:error, r}  -> {:error, -32603, \"Prompt failed\", r}\n    end\n  end\n\n  def handle(\"agent/steer\", %{\"session_id\" => sid, \"text\" => text}) do\n    :ok = Opal.steer(sid, text)\n    {:ok, %{ok: true}}\n  end\n\n  def handle(\"agent/abort\", %{\"session_id\" => sid}) do\n    :ok = Opal.abort(sid)\n    {:ok, %{ok: true}}\n  end\n\n  def handle(\"agent/state\", %{\"session_id\" => sid}) do\n    state = Opal.Agent.get_state(sid)\n    {:ok, serialize_state(state)}\n  end\n\n  def handle(\"session/list\", _params) do\n    sessions = Opal.Session.list_sessions()\n    {:ok, %{sessions: sessions}}\n  end\n\n  def handle(\"session/branch\", %{\"session_id\" => sid, \"entry_id\" => eid}) do\n    :ok = Opal.Session.branch(sid, eid)\n    {:ok, %{ok: true}}\n  end\n\n  def handle(\"session/compact\", %{\"session_id\" => sid} = params) do\n    keep = Map.get(params, \"keep_recent\", 10)\n    :ok = Opal.Session.compact(sid, keep_recent: keep)\n    {:ok, %{ok: true}}\n  end\n\n  def handle(\"models/list\", _params) do\n    models = Opal.Provider.Copilot.models()\n    {:ok, %{models: Enum.map(models, &serialize_model/1)}}\n  end\n\n  def handle(\"auth/status\", _params) do\n    {:ok, %{authenticated: Opal.Auth.authenticated?()}}\n  end\n\n  def handle(\"auth/login\", _params) do\n    # Triggers device flow — progress sent as notifications\n    case Opal.Auth.login() do\n      {:ok, _} -> {:ok, %{ok: true}}\n      {:error, r} -> {:error, -32603, \"Login failed\", r}\n    end\n  end\n\n  def handle(method, _params) do\n    {:error, -32601, \"Method not found: #{method}\", nil}\n  end\n\n  # ... serialization helpers\nend\n```\n\n**`Opal.RPC.Stdio`** — Stdio transport GenServer\n\nThe glue. Reads lines from stdin, dispatches, writes to stdout. Subscribes to\n`Opal.Events` and forwards as notifications. Handles server→client requests\nfor user confirmations.\n\n```elixir\ndefmodule Opal.RPC.Stdio do\n  @moduledoc \"\"\"\n  JSON-RPC 2.0 transport over stdin/stdout.\n\n  Reads newline-delimited JSON from stdin, dispatches via\n  Opal.RPC.Handler, writes responses to stdout. Subscribes\n  to Opal.Events and emits notifications for streaming events.\n  \"\"\"\n\n  use GenServer\n\n  defstruct [:port, :buffer, pending_requests: %{}, next_server_id: 1]\n\n  def start_link(opts \\\\ []) do\n    GenServer.start_link(__MODULE__, opts, name: __MODULE__)\n  end\n\n  @impl true\n  def init(_opts) do\n    # Open stdin as a port for line-based reading\n    port = Port.open({:fd, 0, 1}, [:binary, :stream, {:line, 1_048_576}])\n    {:ok, %__MODULE__{port: port, buffer: \"\"}}\n  end\n\n  # --- Incoming data from stdin ---\n\n  @impl true\n  def handle_info({port, {:data, {:eol, line}}}, %{port: port} = state) do\n    state = process_line(line, state)\n    {:noreply, state}\n  end\n\n  # --- Opal events → JSON-RPC notifications ---\n\n  def handle_info({:opal_event, session_id, event}, state) do\n    notification = event_to_notification(session_id, event)\n    write_stdout(notification)\n    {:noreply, state}\n  end\n\n  # --- Server→Client request responses ---\n\n  def handle_info({:client_response, id, result}, state) do\n    case Map.pop(state.pending_requests, id) do\n      {from, pending} when from != nil ->\n        GenServer.reply(from, result)\n        {:noreply, %{state | pending_requests: pending}}\n      _ ->\n        {:noreply, state}\n    end\n  end\n\n  # --- Internal ---\n\n  defp process_line(line, state) do\n    case Opal.RPC.decode(line) do\n      {:request, id, method, params} ->\n        handle_request(id, method, params, state)\n\n      {:response, id, result} ->\n        # Client responding to a server→client request\n        send(self(), {:client_response, id, result})\n        state\n\n      {:error, _reason} ->\n        write_stdout(Opal.RPC.encode_error(nil, -32700, \"Parse error\"))\n        state\n    end\n  end\n\n  defp handle_request(id, method, params, state) do\n    case Opal.RPC.Handler.handle(method, params) do\n      {:ok, result} ->\n        write_stdout(Opal.RPC.encode_response(id, result))\n\n        # Auto-subscribe to events for new sessions\n        if method == \"session/start\" do\n          Opal.Events.subscribe(result.session_id)\n        end\n\n      {:error, code, message, data} ->\n        write_stdout(Opal.RPC.encode_error(id, code, message, data))\n    end\n    state\n  end\n\n  @doc \"\"\"\n  Send a request to the client and wait for a response.\n  Used for user confirmations, input prompts, etc.\n  \"\"\"\n  def request_client(method, params, timeout \\\\ 30_000) do\n    GenServer.call(__MODULE__, {:request_client, method, params}, timeout)\n  end\n\n  @impl true\n  def handle_call({:request_client, method, params}, from, state) do\n    id = \"s2c-#{state.next_server_id}\"\n    write_stdout(Opal.RPC.encode_request(id, method, params))\n    pending = Map.put(state.pending_requests, id, from)\n    {:noreply, %{state | pending_requests: pending,\n                         next_server_id: state.next_server_id + 1}}\n  end\n\n  defp event_to_notification(session_id, event) do\n    {type, data} = serialize_event(event)\n    params = Map.merge(%{session_id: session_id, type: type}, data)\n    Opal.RPC.encode_notification(\"agent/event\", params)\n  end\n\n  defp serialize_event({:agent_start}),\n    do: {\"agent_start\", %{}}\n  defp serialize_event({:message_delta, %{delta: delta}}),\n    do: {\"message_delta\", %{delta: delta}}\n  defp serialize_event({:thinking_delta, %{delta: delta}}),\n    do: {\"thinking_delta\", %{delta: delta}}\n  defp serialize_event({:tool_execution_start, tool, args}),\n    do: {\"tool_execution_start\", %{tool: tool, args: args}}\n  defp serialize_event({:tool_execution_end, tool, result}),\n    do: {\"tool_execution_end\", %{tool: tool, result: result}}\n  defp serialize_event({:turn_end, message, _results}),\n    do: {\"turn_end\", %{message: message}}\n  defp serialize_event({:agent_end, _messages}),\n    do: {\"agent_end\", %{}}\n\n  defp write_stdout(json) do\n    IO.write(:stdio, json <> \"\\n\")\n  end\nend\n```\n\n**`Opal.CLI.Server`** — Headless daemon entry point\n\nThe headless daemon mode (`opal --daemon`). Starts the OTP application,\nlaunches the stdio transport, and blocks until stdin closes.\n\n```elixir\ndefmodule Opal.CLI.Server do\n  @moduledoc \"\"\"\n  Entry point for headless daemon mode (opal --daemon).\n\n  Usage: opal --daemon [--log-level debug]\n\n  The server communicates exclusively via JSON-RPC 2.0 on stdin/stdout.\n  Logs go to stderr (configurable level).\n  \"\"\"\n\n  def main(args \\\\ []) do\n    configure_logging(args)\n    Logger.configure_backend(:console, device: :standard_error)\n    {:ok, _} = Application.ensure_all_started(:opal)\n    {:ok, _} = Opal.RPC.Stdio.start_link()\n\n    receive do\n      {:EXIT, _, _} -> :ok\n    end\n  end\nend\n```\n\n**`Opal.CLI.Main`** — Binary entry point\n\nThe `opal` binary entry point. Dispatches between interactive TUI (default)\nand headless daemon mode (`--daemon`).\n\n```elixir\ndefmodule Opal.CLI.Main do\n  def main(args \\\\ []) do\n    {opts, _, _} = OptionParser.parse(args, ...)\n\n    cond do\n      opts[:daemon] || opts[:headless] -> Opal.CLI.Server.main(args)\n      true -> TermUI.Runtime.run(root: Opal.CLI.App, render_interval: 16)\n    end\n  end\nend\n```\n\n#### Distribution\n\nThe `opal` binary is built as either:\n\n- **Escript** — `mix escript.build` (requires Erlang/OTP on the target machine)\n- **Mix release** — `mix release` (self-contained, bundles ERTS)\n- **Burrito** — single-file binary, no runtime dependencies (future)\n\n```\ncd core\nmix escript.build\n./opal               # Interactive TUI\n./opal --daemon      # Headless JSON-RPC\n```\n\n#### Deployment Modes\n\n| Concern              | Opal library (Hex)                  | opal binary                     |\n| -------------------- | ----------------------------------- | ------------------------------- |\n| **Audience**         | Elixir developers embedding agents  | End users & external clients    |\n| **Distribution**     | `{:opal, \"~> 0.1\"}` in `mix.exs`    | escript, mix release, or Burrito |\n| **Interface**        | Elixir function calls, OTP messages | TUI (default) or JSON-RPC (--daemon) |\n| **State management** | Your supervision tree               | Self-contained OTP app          |\n| **Streaming**        | `Opal.Events.subscribe/1` + mailbox | Direct in TUI / notifications in daemon |\n\n#### Future Transports (Not in This Stage)\n\nThe protocol layer (`Opal.RPC` + `Opal.RPC.Handler`) is transport-agnostic.\nAdding new transports later is a small module each:\n\n- **`Opal.RPC.WebSocket`** — for web UIs, IDE extensions, multi-client\n- **`Opal.RPC.HTTP`** — REST + SSE for browser-based clients\n- **`Opal.RPC.TCP`** — for daemon mode (long-running server, multiple CLIs)\n\nEach transport module only handles framing and connection management. The\nhandler dispatch is shared.\n\n---","ref":"architecture.html#stage-5-5-rpc-server-headless-mode"},{"type":"extras","title":"Stage 6 — CLI Frontend (Native Elixir / TermUI) - Architecture","doc":"> Goal: A production-quality `opal` terminal application built into the binary.\n\nThe CLI is built in Elixir using [TermUI](https://github.com/pcharbon70/term_ui),\na BubbleTea-inspired Elm Architecture framework for terminal UIs. The TUI runs\nin the same BEAM process tree as the agent engine — no child process spawning,\nno JSON-RPC serialization for interactive mode.\n\n**Why native Elixir instead of TypeScript/Ink?**\n\n- **Zero serialization overhead.** The TUI calls `Opal.prompt/2` directly —\n  no JSON encoding, no stdio parsing, no process spawning.\n- **Single binary.** One `opal` executable, no Node.js runtime dependency.\n- **Event bridge is trivial.** `Opal.Events.subscribe/1` delivers events as\n  Erlang messages directly to the TermUI runtime process.\n- **TermUI maturity.** 24+ widgets, 60fps differential rendering, markdown\n  support via `mdex`, full RGB color, Elm Architecture state management.\n\n**`mix opal.chat`** remains as a debugging utility for library developers.\n\n#### Module Structure\n\n```\ncore/lib/opal/cli/\n├── app.ex              # Main TUI application (use TermUI.Elm)\n├── commands.ex         # Slash command handling (/clear, /help, etc.)\n├── config.ex           # Persistent CLI config (~/.config/opal/config.json)\n├── main.ex             # Binary entry point (arg parsing, mode dispatch)\n├── server.ex           # Headless JSON-RPC server entry point (--daemon)\n├── theme.ex            # Color theme (pink accents, dark/light)\n└── views/\n    ├── confirm_dialog.ex  # Tool confirmation overlay\n    ├── header.ex          # Header bar (title, cwd, model name)\n    ├── input.ex           # User input prompt (cursor, submit)\n    ├── message_list.ex    # Scrollable chat with role badges\n    ├── status_bar.ex      # Bottom bar (tokens, shortcuts)\n    ├── task_list.ex       # Tool execution status icons\n    └── thinking.ex        # Animated kaomoji indicator\n```\n\n#### Usage\n\n```\n$ opal                           # Interactive TUI (default)\n$ opal --daemon                  # Headless JSON-RPC on stdio\n$ opal --version                 # Print version\n$ opal --help                    # Show help\n```\n\n#### Platform Distribution\n\nThe `opal` binary is built as either:\n\n1. **`mix escript.build`** — portable escript (requires Erlang/OTP on host)\n2. **`mix release`** — self-contained release (bundles BEAM + deps)\n\n| Platform        | Install method                          |\n| --------------- | --------------------------------------- |\n| **macOS arm64** | `brew install opal` / GitHub release    |\n| **macOS x64**   | `brew install opal` / GitHub release    |\n| **Linux x64**   | GitHub release / curl one-liner         |\n| **Linux arm64** | GitHub release / curl one-liner         |\n| **Windows x64** | GitHub release / scoop / winget         |\n\n---","ref":"architecture.html#stage-6-cli-frontend-native-elixir-termui"},{"type":"extras","title":"OTP Advantages Over Pi's Architecture - Architecture","doc":"| Concern             | Pi (TypeScript)                                 | Opal (Elixir/OTP)                                                                                             |\n| ------------------- | ----------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |\n| **Agent isolation** | Single process, careful state management        | Each agent is a process — crash one, others survive                                                           |\n| **Sub-agents**      | \"Build it yourself\" or tmux                     | `DynamicSupervisor.start_child/2`                                                                             |\n| **Concurrency**     | Sequential tool execution                       | `Task.async_stream` for parallel tools                                                                        |\n| **Event system**    | Callback arrays, manual cleanup                 | `Registry` pubsub — subscribe/unsubscribe is process lifecycle                                                |\n| **Steering**        | Explicit queue arrays + polling                 | Process mailbox — selective receive                                                                           |\n| **Inspection**      | Console logging                                 | `:observer`, `:sys.get_state`, tracing                                                                        |\n| **Fault tolerance** | try/catch, process exit                         | Supervision trees, automatic restart strategies                                                               |\n| **Embedding**       | SDK import + async/await                        | Add to your supervision tree — it's just processes                                                            |\n| **Multi-session**   | Multiple AgentSession instances in one thread   | Each session is an isolated process tree                                                                      |\n| **Hot code reload** | Restart the process                             | Hot code upgrade via releases                                                                                 |\n| **Backpressure**    | Manual (message queue modes)                    | Process mailbox + GenServer handle_continue                                                                   |\n| **Distributed**     | Not built-in                                    | `Node.connect` — agents across machines for free                                                              |\n| **Cross-platform**  | Works but bash tool assumes POSIX               | BEAM runs natively on Windows, macOS, Linux — `Opal.Tool.Shell` dispatches per OS                             |\n| **MCP integration** | Explicitly rejected; \"build it with extensions\" | Anubis MCP clients under OTP supervision — zero transport/protocol code, fault-tolerant, parallel negotiation |\n\n---","ref":"architecture.html#otp-advantages-over-pi-s-architecture"},{"type":"extras","title":"Module Summary - Architecture","doc":"| Module                              | Type              | Stage | Purpose                                         |\n| ----------------------------------- | ----------------- | ----- | ----------------------------------------------- |\n| `Opal`                              | API               | 1     | Public interface, session lifecycle             |\n| `Opal.Agent`                        | GenServer         | 1     | Core agent loop                                 |\n| `Opal.Provider`                     | Behaviour         | 1     | LLM provider abstraction                        |\n| `Opal.Provider.Copilot`             | Module            | 1     | GitHub Copilot (OpenAI Responses API)           |\n| `Opal.Auth`                         | Module            | 1     | Copilot OAuth device-code flow + token storage  |\n| `Opal.Tool`                         | Behaviour         | 1     | Tool interface                                  |\n| `Opal.Tool.{Read,Write,Edit,Shell}` | Modules           | 1     | Built-in tools                                  |\n| `Opal.Config`                       | Module            | 1     | Application config + per-session overrides      |\n| `Opal.Path`                         | Module            | 1     | Cross-platform path normalization               |\n| `Opal.Events`                       | Registry          | 1     | Event pubsub                                    |\n| `Opal.Message`                      | Struct            | 1     | Message types                                   |\n| `Opal.SessionSupervisor`            | DynamicSupervisor | 1     | Per-session process tree                        |\n| `Opal.Session`                      | GenServer         | 2     | Message history + persistence                   |\n| `Opal.Session.Compaction`           | Module            | 2     | Context window management                       |\n| `Opal.SubAgent`                     | Module            | 3     | Sub-agent spawning                              |\n| `Opal.SubAgentSup`                  | DynamicSupervisor | 3     | Sub-agent supervision                           |\n| `Opal.Context`                      | Module            | 4     | Context file discovery                          |\n| `Opal.Skill`                        | Behaviour         | 4     | Reusable instructions                           |\n| `Opal.MCP.Supervisor`               | Supervisor        | 5     | Manages Anubis client processes                 |\n| `Opal.MCP.Client`                   | Anubis.Client     | 5     | MCP server connection (via Anubis)              |\n| `Opal.MCP.Bridge`                   | Module            | 5     | Discovers MCP tools → Opal tool format          |\n| `Opal.MCP.Resources`                | Module            | 5     | MCP resource discovery + reading                |\n| `Opal.RPC`                          | Module            | 5.5   | JSON-RPC 2.0 encode/decode (transport-agnostic) |\n| `Opal.RPC.Handler`                  | Module            | 5.5   | Method dispatch → Opal API                      |\n| `Opal.RPC.Stdio`                    | GenServer         | 5.5   | Stdio transport for headless daemon mode        |\n| `Opal.CLI.Server`                   | Module            | 5.5   | Headless daemon entry point (`--daemon`)        |\n| `Opal.CLI.Main`                     | Module            | 6     | Binary entry point (mode dispatch)              |\n| `Opal.CLI.App`                      | TermUI.Elm        | 6     | Main TUI application (Elm Architecture)         |\n| `Opal.CLI.Theme`                    | Module            | 6     | Color themes (dark/light, pink accents)         |\n| `Opal.CLI.Config`                   | Module            | 6     | Persistent CLI config (~/.config/opal)          |\n| `Opal.CLI.Commands`                 | Module            | 6     | Slash command handling                          |\n| `Opal.CLI.Views.*`                  | Modules           | 6     | View components (Header, Input, MessageList, etc.) |\n| `opal.chat`                         | Mix task          | 6     | Elixir debugging TUI (direct library usage)     |\n\n---","ref":"architecture.html#module-summary"},{"type":"extras","title":"Usage: SDK in Your App - Architecture","doc":"```elixir\n# In your application.ex\nchildren = [\n  Opal.Supervisor  # starts the registry, session supervisor, etc.\n]\n\n# Anywhere in your app — tools, shell, data_dir come from config :opal\n{:ok, session} = Opal.start_session(%{\n  system_prompt: \"You are a helpful assistant.\",\n  working_dir: File.cwd!()\n})\n\n# Subscribe from a LiveView, GenServer, or any process\nOpal.Events.subscribe(session)\n\n# Non-blocking\nOpal.prompt(session, \"Refactor the user module\")\n\n# Events arrive in your process mailbox\nreceive do\n  {:opal_event, _, {:message_update, %{delta: text}}} ->\n    IO.write(text)\n  {:opal_event, _, {:agent_end, _messages}} ->\n    IO.puts(\"\\n--- Done ---\")\nend\n```","ref":"architecture.html#usage-sdk-in-your-app"},{"type":"extras","title":"Usage: Headless / Script - Architecture","doc":"```elixir\n# In a Mix task or escript\nOpal.Supervisor.start_link([])\n\n{:ok, response} = Opal.prompt_sync(session, \"What's in this repo?\")\nIO.puts(response)\n```\n\n---","ref":"architecture.html#usage-headless-script"},{"type":"extras","title":"Cross-Platform Design Principles - Architecture","doc":"1. **No POSIX assumptions.** Never shell out with hardcoded `sh -c`. Use\n   `Opal.Tool.Shell` which dispatches to the right shell per OS.\n2. **Use `Path` everywhere.** Never concatenate paths with `\"/\"`. Use\n   `Path.join/2`, `Path.expand/1`, `Path.relative_to/2`.\n3. **Normalize paths at boundaries.** Input from users, LLMs, and tool results\n   goes through `Opal.Path.normalize/1` before storage or comparison.\n4. **Data directory.** All persistent state lives under `~/.opal/` by default\n   — one predictable location on every platform (like `~/.ssh`, `~/.docker`).\n   Override via `config :opal, data_dir: ...` in your app, per-session\n   with `data_dir:`, or `OPAL_DATA_DIR` env var. See `Opal.Config` for the\n   full precedence chain.\n5. **Session storage.** Saved under `Opal.Config.sessions_dir/0` which defaults\n   to `~/.opal/sessions/`. Embedded apps can redirect to their own data dir.\n6. **Environment variables.** `System.get_env/1` is cross-platform. API keys\n   and config via env vars work everywhere.\n7. **Line endings.** File reads/writes preserve platform line endings. Diffs\n   and edits normalize to `\\n` internally.\n8. **Test on CI.** GitHub Actions matrix: `ubuntu-latest`, `macos-latest`,\n   `windows-latest`. No platform is a second-class citizen.\n\n---","ref":"architecture.html#cross-platform-design-principles"},{"type":"extras","title":"What's Not Here (Yet) - Architecture","doc":"- **Multiple providers** — Ship GitHub Copilot first. Direct OpenAI, Anthropic,\n  Google, etc. follow the same `Opal.Provider` behaviour. The Copilot provider\n  already speaks the OpenAI Responses API, so direct OpenAI support is a\n  near-trivial second provider.\n- **Web UI** — Could be a Phoenix LiveView app that subscribes to events.\n  That's a separate project.\n- **Distributed agents** — The architecture supports it (processes + message\n  passing), but we don't build for it in early stages.\n- **Image/multimodal support** — Messages can carry image content, but tooling\n  for it comes later.\n\n---","ref":"architecture.html#what-s-not-here-yet"},{"type":"extras","title":"Naming - Architecture","doc":"**Opal** — it's a gemstone, short, easy to type, and the `O` is for OTP.\nOpen to alternatives.","ref":"architecture.html#naming"},{"type":"extras","title":"Agent Loop","doc":"# The Agent Loop\n\nThis document explains how `Opal.Agent` implements the agentic loop pattern\non top of OTP's `GenServer`, and how every phase of the loop maps to native\nOTP concepts: casts, handle_info, selective receive, and supervised tasks.\n\n---","ref":"agent-loop.html"},{"type":"extras","title":"Overview - Agent Loop","doc":"An agent loop is a cycle: **prompt → stream LLM → execute tools → repeat**.\nThe loop runs until the LLM produces a text-only response with no tool calls.\n\nIn Opal, this cycle is expressed entirely through GenServer state transitions\nand OTP message passing — no spawned loops, no recursive spawns, no custom\nschedulers. The BEAM scheduler *is* the scheduler.\n\n```mermaid\nstateDiagram-v2\n    [*] --> idle\n    idle --> running : prompt cast\n    running --> streaming : provider stream\n    streaming --> streaming : handle_info SSE chunks\n    streaming --> running : finalize response\n    running --> idle : no tool calls, agent_end\n    running --> running : tools, execute, run_turn\n\n    note right of streaming : SSE chunks arrive\\nvia handle_info\n    note right of running : Tool execution blocks\\nthen loops back\n```\n\n---","ref":"agent-loop.html#overview"},{"type":"extras","title":"State Machine - Agent Loop","doc":"The Agent has three states, tracked by the `status` field:\n\n| State        | Meaning                                    | Accepts prompts? |\n|--------------|--------------------------------------------|------------------|\n| `:idle`      | Waiting for user input                     | Yes              |\n| `:running`   | Processing (building messages, dispatching)| Via steering     |\n| `:streaming` | Receiving SSE chunks from the LLM          | Via steering     |\n\nState transitions are driven by OTP callbacks:\n\n```mermaid\nstateDiagram-v2\n    [*] --> idle\n\n    idle --> running : prompt cast\n    running --> streaming : provider stream\n\n    streaming --> streaming : handle_info SSE chunks\n    streaming --> idle : finalize, no tool calls\n    streaming --> tool_execution : finalize, has tool calls\n\n    tool_execution --> running : steering check, run_turn\n\n    state tool_execution {\n        [*] --> dispatched\n        dispatched --> results : async_stream_nolink\n    }\n```\n\n---","ref":"agent-loop.html#state-machine"},{"type":"extras","title":"Phase 1: Receiving the Prompt - Agent Loop","doc":"```elixir\ndef handle_cast({:prompt, text}, %State{} = state) do\n  user_msg = Opal.Message.user(text)\n  state = append_message(state, user_msg)\n  state = %{state | status: :running}\n  broadcast(state, {:agent_start})\n  run_turn(state)\nend\n```\n\n**Why `cast` instead of `call`?**\n\nA `call` would block the caller until the agent finishes — which could be\nminutes if the LLM runs multiple tool-use turns. Using `cast`:\n\n- The caller gets `:ok` immediately\n- The caller observes progress via `Opal.Events` (pubsub)\n- The GenServer is free to process `handle_info` messages (SSE chunks)\n  without a caller hanging\n\n**OTP mapping:** This is a standard GenServer `handle_cast`. The prompt is\nappended to the conversation history, status transitions to `:running`, and\n`run_turn/1` is called synchronously within the same callback — it returns\n`{:noreply, state}` once the streaming response is set up.\n\n---","ref":"agent-loop.html#phase-1-receiving-the-prompt"},{"type":"extras","title":"Phase 2: Starting the LLM Stream - Agent Loop","doc":"```elixir\ndefp run_turn(%State{} = state) do\n  all_messages = build_messages(state)\n  tools = active_tools(state)\n\n  case state.provider.stream(state.model, all_messages, tools) do\n    {:ok, resp} ->\n      state = %{state | streaming_resp: resp, status: :streaming, ...}\n      {:noreply, state}\n\n    {:error, reason} ->\n      broadcast(state, {:error, reason})\n      {:noreply, %{state | status: :idle}}\n  end\nend\n```\n\n`run_turn/1` is always the last call in a `handle_cast` or at the end of tool\nexecution. It calls the configured `Provider.stream/4` which initiates an\nasync HTTP request via `Req`.\n\n**How Req async streaming works with GenServer:**\n\n1. `Req` opens an HTTP connection and returns a `%Req.Response{}` immediately\n2. As SSE chunks arrive over the wire, `Req` sends them as regular Erlang\n   messages to the calling process (the Agent GenServer)\n3. The Agent's `handle_info/2` receives these messages\n\nThis is the key integration point: **Req's async streaming maps directly to\nGenServer's `handle_info`**. No polling, no separate receiver process, no\ncallbacks — just messages in the GenServer mailbox.\n\n```mermaid\nflowchart LR\n    LLM[\"LLM API  HTTP/SSE \"] --> Req[\"Req  async \"]\n    Req -- \"Erlang messages {ref, chunk}\" --> Agent[\"Agent mailbox  handle_info \"]\n```\n\n---","ref":"agent-loop.html#phase-2-starting-the-llm-stream"},{"type":"extras","title":"Phase 3: Processing the Stream - Agent Loop","doc":"```elixir\ndef handle_info(message, %State{status: :streaming, streaming_resp: resp} = state)\n    when resp != nil do\n  case Req.parse_message(resp, message) do\n    {:ok, chunks} ->\n      state = Enum.reduce(chunks, state, fn\n        {:data, data}, acc -> parse_sse_data(data, acc)\n        :done, acc -> acc\n        _other, acc -> acc\n      end)\n\n      if :done in chunks do\n        finalize_response(state)\n      else\n        {:noreply, state}\n      end\n\n    :unknown ->\n      {:noreply, state}\n  end\nend\n```\n\nEach `handle_info` invocation processes one batch of SSE chunks. The Agent\npattern-matches on `status: :streaming` to ensure it only processes stream\ndata when actually streaming.\n\n**SSE event types and how they update state:**\n\n| LLM Stream Event | State Mutation | Event Broadcast |\n|---|---|---|\n| `text_start` | (no state change) | `{:message_start}` |\n| `text_delta \"Hel\"` | `current_text <> \"Hel\"` | `{:message_delta, %{delta: \"Hel\"}}` |\n| `text_delta \"lo\"` | `current_text <> \"lo\"` | `{:message_delta, %{delta: \"lo\"}}` |\n| `text_done \"Hello\"` | `current_text = \"Hello\"` | (none) |\n| `tool_call_start` | append to `current_tool_calls` | (none) |\n| `tool_call_delta` | append to `arguments_json` | (none) |\n| `tool_call_done` | finalize tool call entry | (none) |\n| `thinking_start` | (no state change) | `{:thinking_start}` |\n| `thinking_delta` | (no state change) | `{:thinking_delta, ...}` |\n| `response_done` | (no state change) | (none) |\n| `:done` (Req) | triggers `finalize_response` | (see below) |\n\n**OTP mapping:** Every SSE chunk is a `handle_info` call. Between chunks, the\nGenServer is free to process other messages — including `abort` casts. The\nBEAM scheduler interleaves chunk processing with any other work the VM needs\nto do.","ref":"agent-loop.html#phase-3-processing-the-stream"},{"type":"extras","title":"Provider Abstraction - Agent Loop","doc":"The raw SSE JSON is never interpreted by the Agent directly. Instead:\n\n1. `Req.parse_message/2` extracts `{:data, iodata}` from the HTTP-level framing\n2. The Agent calls `state.provider.parse_stream_event(json)` to get semantic events\n3. The Agent dispatches on the semantic event type (`:text_delta`, `:tool_call_start`, etc.)\n\nThis means the Agent loop is **provider-agnostic**. The same GenServer handles\nAnthropic's Responses API, OpenAI's Chat Completions API, or any custom provider.\nThe `Provider` behaviour defines the translation layer:\n\n```mermaid\nflowchart LR\n    SSE[\"Raw SSE JSON  wire format   Anthropic: content_block_delta  OpenAI: choices[0].delta\"] --> Provider[\"Provider behaviour  parse_stream_event/1  Returns: {:text_delta, &quot;&quot;}\"]\n    Provider --> Agent[\"Agent loop  Handles: text_delta, tool_call_done, etc.\"]\n```\n\n---","ref":"agent-loop.html#provider-abstraction"},{"type":"extras","title":"Phase 4: Finalizing the Response - Agent Loop","doc":"When `:done` arrives in the chunk list, `finalize_response/1` is called:\n\n```elixir\ndefp finalize_response(%State{} = state) do\n  tool_calls = finalize_tool_calls(state.current_tool_calls)\n  assistant_msg = Opal.Message.assistant(state.current_text, tool_calls)\n  state = append_message(state, assistant_msg)\n\n  if tool_calls != [] do\n    broadcast(state, {:turn_end, assistant_msg, []})\n    execute_tool_calls(tool_calls, state)\n  else\n    broadcast(state, {:agent_end, state.messages})\n    {:noreply, %{state | status: :idle}}\n  end\nend\n```\n\nThis is the branching point of the loop:\n\n- **No tool calls** → The agent is done. Broadcast `agent_end`, go `:idle`.\n  The GenServer sits in its mailbox waiting for the next `handle_cast`.\n\n- **Has tool calls** → Execute them, then loop back to `run_turn`. The\n  GenServer stays in `:running` status.\n\n**OTP mapping:** `finalize_response` is called from within `handle_info`.\nIt returns `{:noreply, state}` either directly (no tools) or through\n`execute_tool_calls` → `run_turn` (tools). In both cases, the GenServer\ncallback contract is satisfied — the return value is always `{:noreply, state}`.\n\n---","ref":"agent-loop.html#phase-4-finalizing-the-response"},{"type":"extras","title":"Phase 5: Concurrent Tool Execution - Agent Loop","doc":"```elixir\ndefp execute_tool_calls(tool_calls, %State{} = state) do\n  context = %{\n    working_dir: state.working_dir,\n    session_id: state.session_id,\n    config: state.config,\n    agent_pid: self(),\n    agent_state: state          # ← snapshot, not a live reference\n  }\n\n  tasks = Enum.map(tool_calls, fn tc ->\n    {tc, find_tool_module(tc.name, active_tools(state))}\n  end)\n\n  results =\n    Task.Supervisor.async_stream_nolink(\n      state.tool_supervisor,       # ← per-session supervisor\n      tasks,\n      fn {tc, tool_mod} -> ... end,\n      ordered: true,\n      timeout: :infinity\n    )\n    |> Enum.zip(tasks)\n    |> Enum.map(fn ... end)\n\n  state = append_messages(state, tool_result_messages)\n  state = check_for_steering(state)\n  run_turn(state)\nend\n```\n\nThis is the most OTP-integrated phase. Let's break down every decision:","ref":"agent-loop.html#phase-5-concurrent-tool-execution"},{"type":"extras","title":"Why Task.Supervisor.async_stream_nolink? - Agent Loop","doc":"This is an OTP primitive that provides exactly the semantics an agent loop\nneeds:\n\n| Property          | What it means for agents                        |\n|-------------------|-------------------------------------------------|\n| **Supervised**    | Tasks run under a `Task.Supervisor`, not wild   |\n| **Concurrent**    | All tool calls execute in parallel automatically|\n| **Unlinked**      | A crashing tool doesn't crash the Agent         |\n| **Ordered**       | Results arrive in input order                   |\n| **Streaming**     | Results are consumed as they complete           |\n| **Back-pressure** | The Agent blocks until all tools finish         |\n\nCompare with alternatives:\n\n| Alternative | Verdict | Why |\n|---|---|---|\n| `Task.async/1` | ✗ | Linked — crash propagates to Agent |\n| `Task.async_stream/3` | ✗ | Linked |\n| `spawn/1` | ✗ | Unsupervised, no result collection |\n| GenServer pool | ✗ | Over-engineered for ephemeral work |\n| `async_stream_nolink` | ✓ | Supervised, isolated, ordered |","ref":"agent-loop.html#why-task-supervisor-async_stream_nolink"},{"type":"extras","title":"The Blocking Model - Agent Loop","doc":"While tool tasks run, the Agent GenServer is **blocked** inside\n`Enum.zip(results, tasks)` — it cannot process `handle_info` or `handle_cast`.\n\nThis is intentional:\n\n1. The agent cannot stream a new LLM response while tools are running\n2. Tool results must be collected before the next `run_turn`\n3. The conversation must stay consistent — no interleaved mutations\n\nBut this blocking creates two constraints that require specific solutions:","ref":"agent-loop.html#the-blocking-model"},{"type":"extras","title":"Constraint 1: No Calling Back to the Agent - Agent Loop","doc":"Since the Agent is blocked, any `GenServer.call(agent_pid, ...)` from a tool\ntask would deadlock:\n\n```mermaid\nsequenceDiagram\n    participant Agent as Agent (blocked)\n    participant Task as Tool Task\n\n    Agent->>Task: async_stream_nolink(...)\n    Note over Agent: waiting for results...\n\n    Task->>Agent: GenServer.call(agent_pid, :get_state)\n    Note over Task: blocks waiting for reply\n\n    Note over Agent,Task: ╳ DEADLOCK (5s timeout)\n```\n\n**Solution: State snapshot.** Before dispatching tasks, the Agent captures\nits entire state into the context map:\n\n```elixir\ncontext = %{agent_state: state, ...}\n```\n\nTools read from `context.agent_state` — a frozen snapshot — instead of\ncalling back to the live GenServer. The `SubAgent` tool uses\n`spawn_from_state(context.agent_state, overrides)` instead of\n`spawn(agent_pid, overrides)`.","ref":"agent-loop.html#constraint-1-no-calling-back-to-the-agent"},{"type":"extras","title":"Constraint 2: Steering Messages - Agent Loop","doc":"Users may want to inject guidance while tools are running (\"actually, skip\nthat file\"). Since the Agent is blocked, it can't process `handle_cast`\nmessages. But those messages still accumulate in the GenServer mailbox.\n\n**Solution: Selective receive.** After tool execution completes, the Agent\nperforms a zero-timeout selective receive on its own mailbox:\n\n```elixir\ndefp check_for_steering(%State{} = state) do\n  receive do\n    {:\"$gen_cast\", {:steer, text}} ->\n      user_msg = Opal.Message.user(text)\n      state = append_message(state, user_msg)\n      check_for_steering(state)\n  after\n    0 -> state\n  end\nend\n```\n\nThis reaches directly into the GenServer's internal message format\n(`:\"$gen_cast\"`) to extract steering messages that arrived during tool\nexecution. The `after 0` clause ensures it never blocks — if no steering\nmessages are waiting, it returns immediately.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Agent\n    participant Tasks as Tool Tasks\n\n    User->>Agent: cast(:prompt)\n    Agent->>Tasks: async_stream_nolink(...)\n    Note over Agent: blocked waiting for results\n\n    User->>Agent: cast(:steer, \"skip that file\")\n    Note over Agent: steer message queued in mailbox\n\n    Tasks-->>Agent: results collected\n    Note over Agent: check_for_steering drains mailbox\n    Note over Agent: steer message appended to msgs\n    Agent->>Agent: run_turn (with steering)\n```\n\n**OTP mapping:** This is a standard Erlang selective receive. OTP GenServers\nprocess messages in order via `handle_*` callbacks, but within a callback\nimplementation, you can use `receive` to selectively pull specific messages\nfrom the mailbox. The BEAM's per-process mailbox makes this a zero-cost\noperation.\n\n---","ref":"agent-loop.html#constraint-2-steering-messages"},{"type":"extras","title":"The Full Cycle - Agent Loop","doc":"Putting it all together, here's one complete agentic turn:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Agent\n    participant BEAM as BEAM Scheduler\n    participant Provider as Provider/LLM\n    participant TaskSup as Task.Supervisor\n\n    User->>Agent: prompt \"Fix the bug\"\n    Note over Agent: Append user message, idle to running\n\n    Agent->>Provider: provider.stream\n    Provider-->>Agent: {:ok, resp}\n    Note over Agent: running to streaming\n    Note over BEAM: GenServer yields to scheduler\n\n    Provider-->>Agent: handle_info chunk_1\n    Note over Agent: text_delta, broadcast message_delta\n\n    Provider-->>Agent: handle_info chunk_2\n    Note over Agent: text_delta, broadcast message_delta\n\n    Provider-->>Agent: handle_info chunk_N with done\n    Note over Agent: tool_call_done, finalize_response\n\n    Note over Agent: streaming to running, broadcast turn_end\n\n    Agent->>TaskSup: async_stream_nolink edit_call\n    Note over Agent: blocked waiting for results\n    TaskSup-->>Agent: results collected\n\n    Note over Agent: Append tool_result, check_for_steering\n\n    Agent->>Provider: provider.stream next turn\n    Provider-->>Agent: stream text only, done\n\n    Note over Agent: No tool calls, broadcast agent_end, idle\n\n    Agent-->>User: GenServer idle, waiting for next cast\n```\n\n---","ref":"agent-loop.html#the-full-cycle"},{"type":"extras","title":"Session Integration - Agent Loop","doc":"When an `Opal.Session` process is attached, every message append is mirrored\nto it:\n\n```elixir\ndefp append_message(%State{session: nil} = state, msg) do\n  %{state | messages: state.messages ++ [msg]}\nend\n\ndefp append_message(%State{session: session} = state, msg) do\n  Opal.Session.append(session, msg)        # ← GenServer.call to Session\n  %{state | messages: state.messages ++ [msg]}\nend\n```\n\nThe Agent maintains its own flat `messages` list for LLM context building\n(fast, in-process), while the Session maintains a tree structure in ETS for\nbranching, persistence, and history. Both are always in sync.\n\n```mermaid\ngraph TD\n    subgraph agent[\"Agent state.messages (flat list for LLM)\"]\n        AM[\"[user, assistant, tool_result, assistant]\"]\n    end\n\n    subgraph session[\"Session ETS table (tree for persistence)\"]\n        M1[\"msg_1 (user)\"]\n        M2[\"msg_2 (assistant)\"]\n        M3[\"msg_3 (tool_result)\"]\n        M4[\"msg_4 (assistant)\"]\n        M5[\"msg_5 (branch!)\"]\n        M1 --> M2\n        M2 --> M3\n        M3 --> M4\n        M3 --> M5\n    end\n```\n\nThe Session is a sibling process under the same `SessionServer` supervisor.\nIf the Session crashes, the `:rest_for_one` strategy restarts the Agent too\n(since it was started after the Session), ensuring they stay in sync.\n\n---","ref":"agent-loop.html#session-integration"},{"type":"extras","title":"Message Types - Agent Loop","doc":"The conversation uses four message roles that form a protocol between the\nAgent, the LLM, and the tools:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Agent\n    participant LLM\n    participant Tools\n\n    User->>Agent: :user \"Fix bug\"\n    Agent->>LLM: system + messages\n    LLM-->>Agent: :assistant \"I'll fix\" + tool_calls [edit]\n    Agent->>Tools: execute(args, ctx)\n    Tools-->>Agent: {:ok, \"Done\"}\n    Agent->>LLM: :tool_result \"Done\"\n    LLM-->>Agent: :assistant \"Fixed!\"\n    Agent-->>User: {:agent_end, msgs}\n```\n\nEach message is an `Opal.Message` struct with a unique `id` and optional\n`parent_id` (used by Session for tree construction). The `call_id` field\nlinks `:tool_call` entries in an assistant message to their corresponding\n`:tool_result` messages — the LLM API requires this correlation.\n\n---","ref":"agent-loop.html#message-types"},{"type":"extras","title":"Auto-Save & Title Generation - Agent Loop","doc":"When the agent goes idle and a Session is attached, two optional background\ntasks fire:\n\n```elixir\ndefp maybe_auto_save(%State{session: session, config: config} = state) do\n  if config.auto_save do\n    maybe_generate_title(state)\n    Opal.Session.save(session, dir)\n  end\nend\n```\n\nTitle generation is a fire-and-forget task started under the session's\n`Task.Supervisor`:\n\n```elixir\nTask.Supervisor.start_child(state.tool_supervisor, fn ->\n  generate_session_title(state, first_user_msg.content)\nend)\n```\n\nThis makes a separate LLM call to generate a concise title. It runs as a\nsupervised task — if it fails, nothing else is affected. The title is written\nto Session metadata via `Session.set_metadata(session, :title, clean)`.\n\n**OTP mapping:** `Task.Supervisor.start_child` starts a fire-and-forget task\n(unlike `async` which expects the caller to await). The task runs under the\nsame per-session supervisor, so it's cleaned up if the session is terminated.\n\n---","ref":"agent-loop.html#auto-save-title-generation"},{"type":"extras","title":"Tool Behaviour - Agent Loop","doc":"Tools are modules implementing the `Opal.Tool` behaviour:\n\n```elixir\n@callback name() :: String.t()\n@callback description() :: String.t()\n@callback parameters() :: map()         # JSON Schema\n@callback execute(args :: map(), context :: map()) :: {:ok, String.t()} | {:error, String.t()}\n```\n\nThe Agent converts tool modules to JSON Schema for the LLM via\n`Provider.convert_tools/1`. When the LLM requests a tool call, the Agent\nlooks up the module by name and calls `execute/2` inside a supervised task.\n\n**Context map passed to every tool:**\n\n| Key              | Type              | Purpose                           |\n|------------------|-------------------|-----------------------------------|\n| `working_dir`    | `String.t()`      | Base directory for file operations|\n| `session_id`     | `String.t()`      | For event broadcasting            |\n| `config`         | `Opal.Config.t()` | Runtime configuration             |\n| `agent_pid`      | `pid()`           | Reference only — do not call!     |\n| `agent_state`    | `State.t()`       | Frozen snapshot of agent state    |\n\nThe `agent_state` snapshot is the key to avoiding deadlocks. Tools can read\nany agent state they need without calling back to the blocked GenServer.\n\n---","ref":"agent-loop.html#tool-behaviour"},{"type":"extras","title":"Error Handling - Agent Loop","doc":"The Agent handles errors at every phase without crashing:","ref":"agent-loop.html#error-handling"},{"type":"extras","title":"Stream errors - Agent Loop","doc":"```elixir\ndefp handle_stream_event({:error, reason}, state) do\n  broadcast(state, {:error, reason})\n  %{state | status: :idle, streaming_resp: nil}\nend\n```\n\nA stream error (rate limit, network failure) resets the agent to `:idle`.\nSubscribers see `{:error, reason}` and can retry.","ref":"agent-loop.html#stream-errors"},{"type":"extras","title":"Tool crashes - Agent Loop","doc":"```elixir\n{{:exit, reason}, {tc, _tool_mod}} ->\n  {tc, {:error, \"Tool execution crashed: #{inspect(reason)}\"}}\n```\n\nA crashing tool produces an error `tool_result` message. The LLM sees the\nerror and can decide how to proceed — retry, use a different tool, or explain\nthe failure to the user.","ref":"agent-loop.html#tool-crashes"},{"type":"extras","title":"Tool exceptions - Agent Loop","doc":"```elixir\ndefp execute_single_tool(tool_mod, args, context) do\n  tool_mod.execute(args, context)\nrescue\n  e -> {:error, \"Tool raised an exception: #{Exception.message(e)}\"}\nend\n```\n\nEven if a tool raises (instead of crashing), the rescue converts it to an\nerror tuple. The tool task completes normally, and the Agent continues.","ref":"agent-loop.html#tool-exceptions"},{"type":"extras","title":"Missing tools - Agent Loop","doc":"```elixir\ndefp execute_single_tool(nil, _args, _context) do\n  {:error, \"Tool not found\"}\nend\n```\n\nIf the LLM hallucinated a tool name, the Agent returns an error result. The\nLLM learns the tool doesn't exist and adjusts.\n\n**Design principle:** The Agent never crashes due to tool-layer failures.\nEvery error is converted to a message the LLM can reason about. The\nsupervision tree is the safety net for truly unexpected failures.","ref":"agent-loop.html#missing-tools"},{"type":"extras","title":"RPC Research","doc":"# RPC Layer Research: Opal Server ↔ TypeScript/Ink CLI\n\n> Date: 2026-02-06\n> Context: Opal is an OTP-native coding agent harness. We want to ship it as a\n> headless binary (via Burrito/Mix releases) that a TypeScript/Ink CLI spawns or\n> connects to. The RPC layer must support streaming tokens, request/response,\n> and server-initiated requests (e.g. \"ask the user for confirmation\").\n\n---","ref":"rpc-research.html"},{"type":"extras","title":"Requirements Matrix - RPC Research","doc":"| Requirement                      | Weight | Notes                                                               |\n| -------------------------------- | ------ | ------------------------------------------------------------------- |\n| Streaming (LLM token deltas)     | ★★★    | Sub-10ms latency for smooth TUI; potentially hundreds of events/sec |\n| Request/Response (prompt, abort) | ★★★    | Standard RPC calls                                                  |\n| Server → Client requests (bidir) | ★★★    | Server asks frontend for confirmation, file picks, etc              |\n| Cross-platform (mac/linux/win)   | ★★★    | Must work on all three from day one (per ARCHITECTURE.md)           |\n| Distribution simplicity          | ★★★    | Single Opal binary + `npx opal` via npm                             |\n| Implementation effort            | ★★☆    | Small team, must ship fast                                          |\n| Language-agnostic protocol       | ★★☆    | Future SDKs in Python, Go, etc                                      |\n| Existing library ecosystem       | ★★☆    | Battle-tested libs on both sides                                    |\n| Debuggability                    | ★☆☆    | Being able to inspect the wire format easily                        |\n\n---","ref":"rpc-research.html#requirements-matrix"},{"type":"extras","title":"Approach Comparison - RPC Research","doc":"","ref":"rpc-research.html#approach-comparison"},{"type":"extras","title":"A. JSON-RPC 2.0 over stdio - RPC Research","doc":"**How it works:** The TS CLI spawns the Opal binary as a child process. Both\nsides read/write newline-delimited JSON-RPC messages on stdin/stdout. This is\nexactly how LSP and MCP work.\n\n**Elixir side:**\n\n- Anubis MCP (`~> 0.17`) already implements JSON-RPC 2.0 over stdio, including\n  a full transport layer with framing. Opal already depends on it.\n- Could reuse Anubis's `STDIO` transport directly or extract its framing logic.\n- Alternatively, a bare GenServer reading `:stdio` is ~100 lines of code.\n\n**TypeScript side:**\n\n- `vscode-jsonrpc` (6.4M weekly downloads) — the exact library VS Code uses\n  for LSP. Has `StreamMessageReader`/`StreamMessageWriter` for child process\n  stdio. Built-in support for requests, responses, notifications, and progress.\n- `json-rpc-2.0` (400K weekly downloads) — lighter, transport-agnostic,\n  supports `JSONRPCServerAndClient` for bidirectional communication.\n- `@anthropic-ai/sdk` and all MCP client SDKs use this pattern.\n\n**Streaming model:** Server sends JSON-RPC _notifications_ for each token\ndelta (no response expected). Client sends a request to start a prompt, and\nthe server streams results as notifications until a final response.\n\n```\nClient → Server:  {\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"prompt\",\"params\":{\"text\":\"Fix the bug\"}}\nServer → Client:  {\"jsonrpc\":\"2.0\",\"method\":\"token\",\"params\":{\"delta\":\"I\"}}\nServer → Client:  {\"jsonrpc\":\"2.0\",\"method\":\"token\",\"params\":{\"delta\":\"'ll\"}}\nServer → Client:  {\"jsonrpc\":\"2.0\",\"method\":\"token\",\"params\":{\"delta\":\" look\"}}\n...\nServer → Client:  {\"jsonrpc\":\"2.0\",\"id\":1,\"result\":{\"status\":\"complete\"}}\n```\n\n**Bidirectional:** Server sends a _request_ (with `id`) to the client:\n\n```\nServer → Client:  {\"jsonrpc\":\"2.0\",\"id\":\"s1\",\"method\":\"confirm\",\"params\":{\"question\":\"Delete file?\"}}\nClient → Server:  {\"jsonrpc\":\"2.0\",\"id\":\"s1\",\"result\":{\"confirmed\":true}}\n```\n\n| Dimension             | Assessment                                                                        |\n| --------------------- | --------------------------------------------------------------------------------- |\n| Streaming latency     | ★★★ Excellent — direct pipe, no HTTP overhead, no TCP handshake                   |\n| Bidirectional         | ★★★ Native — both sides can send requests and notifications                       |\n| Cross-platform        | ★★★ stdin/stdout works everywhere                                                 |\n| Implementation effort | ★★★ Minimal — Anubis already has the transport; `vscode-jsonrpc` is battle-tested |\n| Distribution          | ★★★ Best — TS spawns binary, no ports/addresses to manage                         |\n| Language-agnostic     | ★★★ JSON-RPC 2.0 is a published spec, any language can implement                  |\n| Multiple clients      | ★☆☆ Only one client per process (the parent)                                      |\n| Debuggability         | ★★☆ Can log/tee the pipe; but interleaving with stderr needed for debug output    |\n| Existing art          | ★★★ LSP, MCP, Copilot, Claude Code all use this exact pattern                     |\n\n**Pros:**\n\n- Zero network configuration — no ports, no addresses, no TLS\n- Process lifecycle is automatic — kill parent, child dies (with proper signal handling)\n- Opal already has Anubis MCP with stdio transport, so the framing layer is proven\n- The MCP ecosystem (which Opal participates in) speaks this protocol\n- `vscode-jsonrpc` is the most battle-tested JSON-RPC-over-stdio lib in existence\n- Single binary distribution is trivially simple\n\n**Cons:**\n\n- Single client only — can't attach a second frontend or a web UI to the same server\n- stdout must be reserved for protocol messages (all logging → stderr)\n- Can't easily connect to an already-running Opal process (would need a separate mechanism)\n- Process management on Windows requires care (no SIGTERM, need to handle differently)\n\n---","ref":"rpc-research.html#a-json-rpc-2-0-over-stdio"},{"type":"extras","title":"B. gRPC with Protobuf - RPC Research","doc":"**How it works:** Opal starts a gRPC server on a TCP port. The TS CLI connects\nas a gRPC client. Messages use Protocol Buffers for serialization.\n\n**Elixir side:**\n\n- `elixir-grpc/grpc` package (~0.11.5) — active, supports server and client\n  streaming, bidirectional streaming. 10 dependencies including `cowboy`, `gun`,\n  `protobuf`. Well-maintained with regular releases.\n- Requires a `.proto` file and code generation step.\n\n**TypeScript side:**\n\n- `@grpc/grpc-js` (25M weekly downloads) — pure JS, no native deps.\n- `@grpc/proto-loader` for dynamic loading or `grpc-tools` for codegen.\n- Full streaming support (server streaming, client streaming, bidirectional).\n\n**Streaming model:** Server streaming RPC — client calls `Prompt()`, server\nstreams back `TokenDelta` messages.\n\n```protobuf\nservice OpalAgent {\n  rpc Prompt(PromptRequest) returns (stream AgentEvent);\n  rpc Abort(AbortRequest) returns (AbortResponse);\n  rpc GetState(StateRequest) returns (StateResponse);\n  // Bidir for confirmations\n  rpc Session(stream ClientMessage) returns (stream ServerMessage);\n}\n```\n\n| Dimension             | Assessment                                                         |\n| --------------------- | ------------------------------------------------------------------ |\n| Streaming latency     | ★★★ Excellent — HTTP/2 streams, binary framing                     |\n| Bidirectional         | ★★★ Native bidirectional streaming                                 |\n| Cross-platform        | ★★★ HTTP/2 over TCP works everywhere                               |\n| Implementation effort | ★★☆ More setup — proto files, codegen, dependency weight           |\n| Distribution          | ★★☆ Need port allocation, connection management, process lifecycle |\n| Language-agnostic     | ★★★ Best — proto files ARE the contract, codegen for any language  |\n| Multiple clients      | ★★★ Any number of clients can connect                              |\n| Debuggability         | ★☆☆ Binary protocol; need special tools (grpcurl, Bloom)           |\n| Existing art          | ★★☆ Common in microservices, rare in CLI-to-backend IPC            |\n\n**Pros:**\n\n- Strongest typing story — proto files generate types for both Elixir and TS\n- True bidirectional streaming is a first-class concept\n- Multiple clients can connect simultaneously\n- Best option for future multi-language SDK support\n- Binary protocol means smaller messages and lower parsing overhead\n\n**Cons:**\n\n- Significant complexity tax: proto files, codegen pipelines, build tooling\n- Heavy dependency tree on Elixir side (cowboy, gun, protobuf, flow, etc.)\n- Port allocation and management (need to find free port, communicate it)\n- Process lifecycle management is now your problem (need a way to start/stop server)\n- Overkill for a 1:1 CLI-to-backend relationship\n- gRPC on Elixir is less battle-tested than in Go/Java ecosystems\n- Burrito binary + gRPC server adds complexity to distribution\n- HTTP/2 requirement can cause issues with some proxies/environments\n\n---","ref":"rpc-research.html#b-grpc-with-protobuf"},{"type":"extras","title":"C. WebSocket - RPC Research","doc":"**How it works:** Opal starts an HTTP server with a WebSocket endpoint. The\nTS CLI connects via WS. Messages are JSON (or could be msgpack).\n\n**Elixir side:**\n\n- `Phoenix.Socket` / `Phoenix.Channel` — but pulling in Phoenix for IPC is heavy\n- `WebSockex` (client) or `Cowboy`/`Bandit` directly for server\n- `Bandit` (~> 1.0) is lightweight and would be reasonable\n- Could use `Plug` + `WebSock` adapter pattern\n\n**TypeScript side:**\n\n- `ws` package (100M+ weekly downloads) — the standard WebSocket library\n- Native `WebSocket` in Node.js 21+ (built-in, no deps)\n- Can layer JSON-RPC 2.0 on top of WebSocket transport\n\n| Dimension             | Assessment                                                  |\n| --------------------- | ----------------------------------------------------------- |\n| Streaming latency     | ★★★ Excellent — persistent connection, frame-level messages |\n| Bidirectional         | ★★★ Native — WebSocket is inherently bidirectional          |\n| Cross-platform        | ★★★ TCP-based, works everywhere                             |\n| Implementation effort | ★★☆ Need HTTP server setup, WS upgrade, message framing     |\n| Distribution          | ★★☆ Same port-management issues as gRPC                     |\n| Language-agnostic     | ★★★ WebSocket is universal; can use JSON-RPC on top         |\n| Multiple clients      | ★★★ Multiple connections supported                          |\n| Debuggability         | ★★☆ JSON messages are readable; browser devtools work       |\n| Existing art          | ★★☆ Common pattern but not standard for CLI IPC             |\n\n**Pros:**\n\n- Inherently bidirectional with low overhead\n- Can layer JSON-RPC 2.0 on top (same message format as option A, different transport)\n- Could potentially serve a web frontend too (future Opal web UI)\n- Well-understood technology\n\n**Cons:**\n\n- Requires an HTTP server in Opal (Cowboy/Bandit + Plug dependency)\n- Port allocation problem (find free port, communicate it to CLI)\n- Connection lifecycle management (reconnection logic, health checks)\n- More moving parts than stdio for a 1:1 relationship\n- Starting an HTTP server inside a Burrito binary adds complexity\n- Not a natural fit for \"spawn a child process\" distribution model\n\n---","ref":"rpc-research.html#c-websocket"},{"type":"extras","title":"D. HTTP + Server-Sent Events (SSE) - RPC Research","doc":"**How it works:** Opal starts an HTTP server. TS CLI sends commands via POST\nrequests and receives streaming events via an SSE connection.\n\n**Elixir side:**\n\n- `Plug` + `Bandit`/`Cowboy` for HTTP\n- SSE is just `text/event-stream` — chunked transfer encoding\n- Anubis MCP already supports SSE transport (though deprecated in favor of\n  Streamable HTTP in MCP spec 2025-03-26)\n\n**TypeScript side:**\n\n- `eventsource` or `EventSource` (built-in in Node.js 22+)\n- `fetch` for POST requests\n- Well-established pattern from web development\n\n| Dimension             | Assessment                                                          |\n| --------------------- | ------------------------------------------------------------------- |\n| Streaming latency     | ★★☆ Good — but HTTP overhead per request; SSE is one-way            |\n| Bidirectional         | ★☆☆ SSE is server→client only; need separate POST for client→server |\n| Cross-platform        | ★★★ HTTP works everywhere                                           |\n| Implementation effort | ★★☆ Need HTTP server, SSE endpoint, request routing                 |\n| Distribution          | ★★☆ Port management required                                        |\n| Language-agnostic     | ★★★ HTTP + SSE are universal                                        |\n| Multiple clients      | ★★★ Any number of clients                                           |\n| Debuggability         | ★★★ Best — curl, browser, any HTTP tool                             |\n| Existing art          | ★★☆ MCP used this (now deprecated); OpenAI streaming API uses it    |\n\n**Pros:**\n\n- Very debuggable — can test with curl\n- Well-understood HTTP semantics\n- SSE reconnection is built into the spec\n- Anubis already has SSE transport code\n\n**Cons:**\n\n- **Not truly bidirectional** — SSE is server→client only. For server-initiated\n  requests (confirmations), you'd need polling or a second channel\n- Two separate mechanisms (HTTP POST + SSE) instead of one unified channel\n- Port management required\n- Higher latency than stdio (HTTP overhead, TCP setup)\n- MCP spec itself deprecated SSE in favor of Streamable HTTP\n- Awkward for the \"server asks client a question\" pattern — would need to\n  embed questions in the SSE stream and have the client POST answers back\n\n---","ref":"rpc-research.html#d-http-server-sent-events-sse"},{"type":"extras","title":"E. Custom Binary Protocol over Unix Domain Sockets / Named Pipes - RPC Research","doc":"**How it works:** Opal listens on a Unix domain socket (or named pipe on\nWindows). Custom binary framing for messages.\n\n**Elixir side:**\n\n- `:gen_tcp` with `{:local, path}` for Unix sockets\n- Custom framing (length-prefixed messages, msgpack or custom binary format)\n- No existing high-level library — all custom code\n\n**TypeScript side:**\n\n- `net.connect` with `path` option for Unix sockets\n- Custom framing to match\n\n| Dimension             | Assessment                                                            |\n| --------------------- | --------------------------------------------------------------------- |\n| Streaming latency     | ★★★ Best possible — no HTTP overhead, kernel-level IPC                |\n| Bidirectional         | ★★★ Full duplex socket                                                |\n| Cross-platform        | ★★☆ Unix sockets on mac/linux; named pipes on Windows (different API) |\n| Implementation effort | ★☆☆ All custom — framing, error handling, reconnection                |\n| Distribution          | ★★☆ Need socket file path management                                  |\n| Language-agnostic     | ★☆☆ Custom protocol = every SDK reimplements from scratch             |\n| Multiple clients      | ★★☆ Possible but need connection management                           |\n| Debuggability         | ★☆☆ Custom binary format = custom debug tools needed                  |\n| Existing art          | ★☆☆ Docker does this, but few CLI tools do                            |\n\n**Pros:**\n\n- Absolute lowest latency possible for IPC\n- No port allocation (filesystem paths instead)\n- File-system permissions for access control\n\n**Cons:**\n\n- **Massive implementation effort** for dubious latency gains (the bottleneck\n  is the LLM API, not local IPC)\n- Cross-platform nightmare — Unix domain sockets and Windows named pipes have\n  different APIs, semantics, and path formats\n- Every future SDK must reimplement the binary protocol from scratch\n- No standard tooling for debugging\n- Fragile socket file cleanup (crashes leave stale files)\n- Premature optimization — JSON-RPC over stdio is already faster than the\n  LLM network latency by orders of magnitude\n\n---","ref":"rpc-research.html#e-custom-binary-protocol-over-unix-domain-sockets-named-pipes"},{"type":"extras","title":"F. JSON-RPC 2.0 over stdio with Notifications (LSP/MCP Pattern) - RPC Research","doc":"**How it works:** Same as (A), but explicitly designed around the notification\npattern that LSP and MCP use. This is the fully-realized version of (A).\n\n**This is option A made concrete**, with an explicit protocol design:\n\n```\n── Lifecycle ──\nClient → Server:  initialize        (request)\nServer → Client:  initialized       (notification)\nClient → Server:  shutdown           (request)\n\n── Agent Operations ──\nClient → Server:  agent/prompt       (request → streams notifications → final response)\nClient → Server:  agent/abort        (request)\nClient → Server:  agent/getState     (request)\nClient → Server:  agent/steer        (notification)\n\n── Streaming (server → client notifications) ──\nServer → Client:  agent/event        (notification: token_delta, tool_start, tool_end, etc.)\n\n── Bidirectional (server asks client) ──\nServer → Client:  client/confirm     (request — server sends, client responds)\nServer → Client:  client/selectFile  (request)\nServer → Client:  client/input       (request)\n\n── Session Management ──\nClient → Server:  session/list       (request)\nClient → Server:  session/resume     (request)\nClient → Server:  session/branch     (request)\n```\n\n**This maps 1:1 to Opal's existing event system:**\n\n- `Opal.Events.broadcast(session_id, {:token, delta})` → `agent/event` notification\n- `Opal.Agent.prompt(pid, text)` → `agent/prompt` request\n- `Opal.Agent.abort(pid)` → `agent/abort` request\n- `Opal.Agent.steer(pid, text)` → `agent/steer` notification\n\n**Elixir implementation sketch:**\n\n```elixir\ndefmodule Opal.RPC.Stdio do\n  @moduledoc \"JSON-RPC 2.0 over stdio transport for headless Opal server\"\n  use GenServer\n\n  # Reads newline-delimited JSON from stdin, dispatches to handler\n  # Writes JSON-RPC responses/notifications to stdout\n  # All logging goes to stderr\n\n  # Can reuse Anubis.Transport.STDIO framing or implement the\n  # ~100 lines of Content-Length header parsing (LSP-style)\nend\n```\n\n**TypeScript implementation sketch:**\n\n```typescript\nimport {\n  createMessageConnection,\n  StreamMessageReader,\n  StreamMessageWriter,\n} from \"vscode-jsonrpc/node\";\n\nconst opal = spawn(\"./opal-server\", [], { stdio: [\"pipe\", \"pipe\", \"inherit\"] });\nconst conn = createMessageConnection(\n  new StreamMessageReader(opal.stdout),\n  new StreamMessageWriter(opal.stdin),\n);\n\n// Handle server → client requests\nconn.onRequest(\"client/confirm\", async (params) => {\n  const answer = await renderConfirmDialog(params.question);\n  return { confirmed: answer };\n});\n\n// Handle streaming notifications\nconn.onNotification(\"agent/event\", (event) => {\n  renderEvent(event); // Update Ink UI\n});\n\n// Send a prompt\nconst result = await conn.sendRequest(\"agent/prompt\", { text: \"Fix the bug\" });\n```\n\n| Dimension             | Assessment                                            |\n| --------------------- | ----------------------------------------------------- |\n| Streaming latency     | ★★★ Excellent — direct pipe, zero overhead            |\n| Bidirectional         | ★★★ Both sides can send requests AND notifications    |\n| Cross-platform        | ★★★ stdin/stdout is universal                         |\n| Implementation effort | ★★★ Minimal — proven pattern, proven libraries        |\n| Distribution          | ★★★ Best — TS spawns binary, done                     |\n| Language-agnostic     | ★★★ JSON-RPC 2.0 spec + a protocol doc = any language |\n| Multiple clients      | ★☆☆ One client per process                            |\n| Debuggability         | ★★☆ JSON is readable; can tee stdio for debugging     |\n| Existing art          | ★★★ LSP, MCP, DAP all work this way                   |\n\n**(Same pros/cons as A, but the protocol design is explicit and documented.)**\n\n---","ref":"rpc-research.html#f-json-rpc-2-0-over-stdio-with-notifications-lsp-mcp-pattern"},{"type":"extras","title":"Comparison Table - RPC Research","doc":"| Criterion                  | A/F: JSON-RPC stdio | B: gRPC | C: WebSocket | D: HTTP+SSE | E: Custom UDS |\n| -------------------------- | ------------------- | ------- | ------------ | ----------- | ------------- |\n| **Streaming latency**      | ★★★                 | ★★★     | ★★★          | ★★☆         | ★★★           |\n| **Bidirectional**          | ★★★                 | ★★★     | ★★★          | ★☆☆         | ★★★           |\n| **Cross-platform**         | ★★★                 | ★★★     | ★★★          | ★★★         | ★★☆           |\n| **Impl effort**            | ★★★                 | ★★☆     | ★★☆          | ★★☆         | ★☆☆           |\n| **Distribution**           | ★★★                 | ★★☆     | ★★☆          | ★★☆         | ★★☆           |\n| **Multi-language**         | ★★★                 | ★★★     | ★★★          | ★★★         | ★☆☆           |\n| **Multiple clients**       | ★☆☆                 | ★★★     | ★★★          | ★★★         | ★★☆           |\n| **Debuggability**          | ★★☆                 | ★☆☆     | ★★☆          | ★★★         | ★☆☆           |\n| **Lib ecosystem**          | ★★★                 | ★★☆     | ★★★          | ★★☆         | ★☆☆           |\n| **Existing Opal affinity** | ★★★                 | ★☆☆     | ★☆☆          | ★★☆         | ★☆☆           |\n| **Total**                  | **28**              | **22**  | **23**       | **21**      | **16**        |\n\n---","ref":"rpc-research.html#comparison-table"},{"type":"extras","title":"Recommendation: F — JSON-RPC 2.0 over stdio (LSP/MCP Pattern) - RPC Research","doc":"","ref":"rpc-research.html#recommendation-f-json-rpc-2-0-over-stdio-lsp-mcp-pattern"},{"type":"extras","title":"Why This Wins - RPC Research","doc":"1. **You already use this pattern.** Anubis MCP is a JSON-RPC 2.0 library with\n   stdio transport that's already in your dependency tree. The framing,\n   serialization, and error handling are solved problems.\n\n2. **Distribution is trivial.** The TS CLI does `spawn('./opal-server')` and\n   talks over pipes. No ports, no addresses, no firewall rules, no TLS\n   certificates. The binary is fully self-contained. This is the same model\n   as `typescript-language-server`, `elixir-ls`, `rust-analyzer`, and every\n   MCP server.\n\n3. **Bidirectional is native.** JSON-RPC 2.0 explicitly supports requests in\n   both directions plus fire-and-forget notifications. The\n   `client/confirm` pattern (server asks client a question) is exactly how\n   LSP's `window/showMessageRequest` works — proven at massive scale.\n\n4. **Streaming maps naturally.** LLM token deltas become notifications\n   (`agent/event`). This is the exact pattern Claude Code, Copilot Chat, and\n   every LSP implementation uses for progress reporting. No SSE, no\n   WebSocket, no special streaming mechanism — just notifications on the pipe.\n\n5. **Cross-platform is automatic.** stdin/stdout works identically on macOS,\n   Linux, and Windows. No Unix socket vs named pipe divergence. No port\n   conflicts. Opal's ARCHITECTURE.md mandates cross-platform from day one.\n\n6. **Future SDKs are easy.** The protocol is a JSON-RPC 2.0 spec document.\n   Anyone can implement a client in Python, Go, Rust, whatever. The same\n   `.md` file that describes your protocol is your SDK documentation.\n\n7. **Implementation is minimal.** Elixir side: a GenServer that reads\n   stdin, dispatches JSON-RPC methods to `Opal.Agent` calls, subscribes to\n   `Opal.Events`, and writes notifications to stdout. ~200-400 lines. TS side:\n   `vscode-jsonrpc` does all the hard work.","ref":"rpc-research.html#why-this-wins"},{"type":"extras","title":"The \"Multiple Clients\" Objection - RPC Research","doc":"The only real weakness is single-client-per-process. But consider:\n\n- **This is the right constraint for a CLI.** One terminal = one agent. If the\n  user wants two agents, they spawn two processes. OTP already isolates them.\n- **A future web UI can use a different transport.** Nothing stops you from\n  adding a WebSocket transport _later_ that exposes the same JSON-RPC protocol\n  over WS instead of stdio. The protocol layer is the same; only the transport\n  changes. Anubis MCP already demonstrates this (stdio + streamable_http +\n  SSE transports for the same protocol).\n- **You can add a \"connect to running instance\" mode later** by having the Opal\n  process also listen on a Unix socket or TCP port as a secondary transport.\n  But ship stdio first.","ref":"rpc-research.html#the-multiple-clients-objection"},{"type":"extras","title":"Suggested Architecture - RPC Research","doc":"```\n┌─────────────────────────────────────────────────────────┐\n│  TypeScript/Ink CLI (npm package)                       │\n│                                                         │\n│  ┌──────────────────────────────────────────────┐       │\n│  │  vscode-jsonrpc                              │       │\n│  │  StreamMessageReader ← child.stdout          │       │\n│  │  StreamMessageWriter → child.stdin           │       │\n│  └──────────────────────────────────────────────┘       │\n│                                                         │\n│  • Renders TUI with Ink                                 │\n│  • Handles server requests (confirm, input, etc.)       │\n│  • Spawns opal binary as child process                  │\n└──────────────────────┬──────────────────────────────────┘\n                       │ stdio (stdin/stdout)\n                       │ JSON-RPC 2.0\n                       │ Content-Length headers (LSP framing)\n┌──────────────────────┴──────────────────────────────────┐\n│  Opal Server Binary (Mix release / Burrito)             │\n│                                                         │\n│  ┌──────────────────────────────────────────────┐       │\n│  │  Opal.RPC.Stdio (GenServer)                  │       │\n│  │  • Reads JSON-RPC from stdin                 │       │\n│  │  • Dispatches to Opal.Agent / Opal.Session   │       │\n│  │  • Subscribes to Opal.Events                 │       │\n│  │  • Writes notifications/responses to stdout  │       │\n│  └──────────────────────────────────────────────┘       │\n│                                                         │\n│  ┌──────────────────────────────────────────────┐       │\n│  │  Opal core (unchanged)                       │       │\n│  │  Agent, Session, Events, Tools, MCP, etc.    │       │\n│  └──────────────────────────────────────────────┘       │\n│                                                         │\n│  stderr → logging (piped to CLI for debug mode)         │\n└─────────────────────────────────────────────────────────┘\n```","ref":"rpc-research.html#suggested-architecture"},{"type":"extras","title":"Key Implementation Notes - RPC Research","doc":"1. **Use LSP-style Content-Length framing**, not newline-delimited JSON.\n   This is what `vscode-jsonrpc` expects and what LSP/DAP use. It handles\n   messages containing newlines correctly.\n\n   ```\n   Content-Length: 52\\r\\n\n   \\r\\n\n   {\"jsonrpc\":\"2.0\",\"method\":\"agent/event\",\"params\":{}}\n   ```\n\n2. **Logger goes to stderr.** Configure Elixir's Logger backend to write to\n   stderr so it doesn't corrupt the JSON-RPC stream. The TS CLI can pipe\n   stderr to a log file or display it in debug mode.\n\n3. **Reuse Anubis framing if possible.** Anubis's STDIO transport already\n   handles Content-Length parsing and serialization. Evaluate whether it can\n   be used directly or if its framing module can be extracted.\n\n4. **Define the protocol in a spec document.** Write an `OPAL-RPC.md` that\n   lists every method, its params schema, and its result schema. This becomes\n   the contract for any future SDK.\n\n5. **Future transport upgrade path:** If you later need multi-client support\n   (web UI, IDE plugin), add a WebSocket or Streamable HTTP transport that\n   speaks the same JSON-RPC protocol. The `Opal.RPC.Handler` module dispatches\n   methods to the Opal core; it doesn't care about the transport.","ref":"rpc-research.html#key-implementation-notes"},{"type":"extras","title":"Libraries to Use - RPC Research","doc":"| Side   | Library          | Purpose                                |\n| ------ | ---------------- | -------------------------------------- |\n| Elixir | `anubis_mcp`     | JSON-RPC 2.0 framing (already a dep)   |\n| Elixir | `jason`          | JSON encoding/decoding (already a dep) |\n| TS     | `vscode-jsonrpc` | JSON-RPC over stdio (6.4M DL/week)     |\n| TS     | `ink`            | Terminal UI framework                  |\n| TS     | (none extra)     | child_process.spawn is built-in        |","ref":"rpc-research.html#libraries-to-use"},{"type":"extras","title":"What NOT to Build - RPC Research","doc":"- ❌ Don't build a custom binary protocol. JSON parsing is not your bottleneck.\n- ❌ Don't add gRPC. The proto/codegen overhead isn't justified for 1:1 IPC.\n- ❌ Don't start with WebSocket. You can always add it later as a second transport.\n- ❌ Don't use HTTP+SSE. It can't do server→client requests cleanly.\n- ❌ Don't use newline-delimited JSON. Use Content-Length framing for robustness.","ref":"rpc-research.html#what-not-to-build"},{"type":"extras","title":"Supervision","doc":"# Supervision & Message Passing\n\nThis document describes Opal's OTP supervision architecture, process lifecycle,\nmessage passing patterns, and the design rationale behind each decision.\n\n---","ref":"supervision.html"},{"type":"extras","title":"Supervision Tree - Supervision","doc":"Opal uses a **per-session supervision tree** so that every active session is a\nfully isolated unit — its own processes, its own failure domain, its own cleanup.\n\n```mermaid\ngraph TD\n    OpalSup[\"Opal.Supervisor  :one_for_one \"]\n    Registry[\"Opal.Events.Registry  shared pubsub backbone \"]\n    SessionSup[\"Opal.SessionSupervisor  DynamicSupervisor :one_for_one \"]\n\n    OpalSup --> Registry\n    OpalSup --> SessionSup\n\n    subgraph session_a[\"Session &quot;a1b2c3&quot;\"]\n        SSA[\"SessionServer  Supervisor :rest_for_one \"]\n        TSA[\"Task.Supervisor  tool execution \"]\n        DSA[\"DynamicSupervisor  sub-agents \"]\n        SesA[\"Opal.Session  persistence (optional) \"]\n        AgentA[\"Opal.Agent  agent loop \"]\n        SSA --> TSA\n        SSA --> DSA\n        SSA --> SesA\n        SSA --> AgentA\n    end\n\n    subgraph session_b[\"Session &quot;d4e5f6&quot;\"]\n        SSB[\"SessionServer  Supervisor :rest_for_one \"]\n        TSB[\"Task.Supervisor\"]\n        DSB[\"DynamicSupervisor\"]\n        AgentB[\"Opal.Agent\"]\n        SSB --> TSB\n        SSB --> DSB\n        SSB --> AgentB\n    end\n\n    SessionSup --> SSA\n    SessionSup --> SSB\n```","ref":"supervision.html#supervision-tree"},{"type":"extras","title":"When sub-agents are active - Supervision","doc":"Sub-agents are regular `Opal.Agent` processes started under the session's own\n`DynamicSupervisor`. They share the parent's `Task.Supervisor` for tool\nexecution but cannot spawn further sub-agents (depth = 1).\n\n```mermaid\ngraph TD\n    SS[\"SessionServer &quot;a1b2c3&quot;  :rest_for_one \"]\n    TS[\"Task.Supervisor  shared by parent + sub-agents \"]\n    DS[\"DynamicSupervisor  owns sub-agent processes \"]\n    Ses[\"Opal.Session  conversation tree (optional) \"]\n    PA[\"Opal.Agent  parent agent loop \"]\n    SubA[\"Opal.Agent &quot;sub-x1y2z3&quot;  sub-agent A \"]\n    SubB[\"Opal.Agent &quot;sub-p4q5r6&quot;  sub-agent B \"]\n\n    SS --> TS\n    SS --> DS\n    SS --> Ses\n    SS --> PA\n    DS --> SubA\n    DS --> SubB\n```\n\n---","ref":"supervision.html#when-sub-agents-are-active"},{"type":"extras","title":"Process Roles - Supervision","doc":"### `Opal.Events.Registry`\n\nA `Registry` with `:duplicate` keys. Any process can subscribe to a session ID\nand receive events. This is the **only shared global process** — everything else\nis per-session. The registry never holds state; it simply routes messages.\n\n### `Opal.SessionSupervisor`\n\nA `DynamicSupervisor` that acts as the container for all active sessions. When\n`Opal.start_session/1` is called, a new `SessionServer` child is started here.\nWhen `Opal.stop_session/1` is called, the entire `SessionServer` subtree is\nterminated — one call cleans up the agent, all running tools, all sub-agents,\nand the session store.\n\n### `Opal.SessionServer`\n\nA per-session `Supervisor` using the `:rest_for_one` strategy. Children are\nstarted in order:\n\n1. **`Task.Supervisor`** — executes tool calls as supervised tasks\n2. **`DynamicSupervisor`** — manages sub-agent processes\n3. **`Opal.Session`** — conversation persistence *(optional, started when `session: true`)*\n4. **`Opal.Agent`** — the agent loop\n\nThe `:rest_for_one` strategy means if the `Task.Supervisor` or\n`DynamicSupervisor` crashes, the Agent (which depends on them) is restarted\ntoo. But a crash in the Agent does not affect the supervisors above it.\n\nEach child is registered with a session-scoped atom name for discoverability:\n\n| Process           | Name                                  |\n|-------------------|---------------------------------------|\n| Task.Supervisor   | `:\"opal_tool_sup_#{session_id}\"`      |\n| DynamicSupervisor | `:\"opal_sub_agent_sup_#{session_id}\"` |\n| Session           | `:\"opal_session_#{session_id}\"`       |\n\n### `Opal.Agent`\n\nA `GenServer` that implements the core agent loop:\n\n1. Receive a user prompt (`handle_cast`)\n2. Stream an LLM response via the configured `Provider`\n3. If the LLM returns tool calls → execute them concurrently → loop to step 2\n4. If the LLM returns text only → broadcast `agent_end` → go idle\n\nThe Agent holds references to its session-local `tool_supervisor` and\n`sub_agent_supervisor` in its state — it never touches global process names.\n\n### `Opal.Session`\n\nA `GenServer` backed by an ETS table that stores conversation messages in a\ntree structure (each message has a `parent_id`). Supports branching — rewinding\nto any past message and forking the conversation. Persistence is via ETF\nserialization to disk.\n\n---","ref":"supervision.html#process-roles"},{"type":"extras","title":"Message Passing - Supervision","doc":"Opal uses three distinct message passing patterns, each chosen for a specific\npurpose.","ref":"supervision.html#message-passing"},{"type":"extras","title":"1. GenServer Calls — Synchronous State Access - Supervision","doc":"```mermaid\nsequenceDiagram\n    participant Caller\n    participant Agent\n\n    Caller->>Agent: GenServer.call(:get_state)\n    Agent-->>Caller: %Agent.State{}\n```\n\nUsed for: `Agent.get_state/1`, `Session.append/2`, `Session.get_path/1`\n\nThese are standard GenServer synchronous calls — the caller blocks until the\nserver replies. Used when the caller needs a consistent snapshot of state.\n\n**Key design decision:** Tool tasks never call `Agent.get_state(agent_pid)`\nduring execution. The Agent is blocked in `Task.Supervisor.async_stream_nolink`\nwaiting for tool results — a `GenServer.call` from a tool task back to the\nAgent would deadlock. Instead, the Agent snapshots its state into the tool\nexecution context *before* dispatching tasks:\n\n```mermaid\nflowchart LR\n    Agent[\"Agent  (blocked) \"] -- \"snapshot state\" --> Context[\"context = %{agent_state: ...}\"]\n    Context -- \"start tasks\" --> Tasks[\"Tool Tasks  read from context \"]\n```","ref":"supervision.html#1-genserver-calls-synchronous-state-access"},{"type":"extras","title":"2. GenServer Casts — Asynchronous Commands - Supervision","doc":"```mermaid\nsequenceDiagram\n    participant Caller\n    participant Agent\n\n    Caller->>Agent: GenServer.cast({:prompt, text})\n    Note right of Caller: :ok (immediate)\n    Note right of Agent: begins turn...\n```\n\nUsed for: `Agent.prompt/2`, `Agent.steer/2`, `Agent.abort/1`\n\nPrompts are fire-and-forget casts. The caller gets `:ok` immediately and\nobserves progress through events (pattern 3). This keeps the caller\nnon-blocking — critical for interactive CLI and web UIs.","ref":"supervision.html#2-genserver-casts-asynchronous-commands"},{"type":"extras","title":"3. Registry PubSub — Event Broadcasting - Supervision","doc":"```mermaid\nflowchart LR\n    Agent[\"Agent broadcasts {:message_delta, ...}\"] --> Registry[\"Opal.Events.Registry  session_id key duplicate keys \"]\n    Registry --> SubA[\"Subscriber A  CLI \"]\n    Registry --> SubB[\"Subscriber B  UI \"]\n    Registry --> SubC[\"Subscriber C  test \"]\n```\n\nUsed for: all agent lifecycle events\n\nThe Agent (and tool tasks) call `Opal.Events.broadcast(session_id, event)`.\nEvery process that called `Opal.Events.subscribe(session_id)` receives the\nevent as a regular Erlang message:\n\n```elixir\n{:opal_event, session_id, event}\n```\n\n**Event types:**\n\n| Event                                | Emitted when                         |\n|--------------------------------------|--------------------------------------|\n| `{:agent_start}`                     | Agent begins processing a prompt     |\n| `{:message_delta, %{delta: text}}`   | Streaming text token from the LLM    |\n| `{:thinking_delta, %{delta: text}}`  | Streaming thinking/reasoning token   |\n| `{:turn_end, message, tool_calls}`   | LLM turn complete, tool calls follow |\n| `{:tool_execution_start, name, args}`| Tool begins executing                |\n| `{:tool_execution_end, name, result}`| Tool finished executing              |\n| `{:agent_end, messages}`             | Agent is done, returning to idle     |\n| `{:error, reason}`                   | Unrecoverable error occurred         |\n| `{:sub_agent_event, sub_id, event}`  | Forwarded event from a sub-agent     |\n\nThis is built on OTP's `Registry` — no external dependencies, no message\nbroker, no serialization overhead. Events are plain Erlang terms sent via\n`send/2` under the hood.","ref":"supervision.html#3-registry-pubsub-event-broadcasting"},{"type":"extras","title":"4. Sub-Agent Event Forwarding - Supervision","doc":"Sub-agents broadcast events to their own session ID. The `SubAgent` tool\nsubscribes to those events, collects the response, and **re-broadcasts** each\nevent to the parent session tagged with the sub-agent's ID:\n\n```mermaid\nsequenceDiagram\n    participant SubAgent as Sub-Agent \"sub-x1\"\n    participant Registry as Events Registry\n    participant ToolTask as SubAgent Tool Task\n    participant ParentReg as Parent Events Registry\n    participant CLI as CLI Subscriber\n\n    SubAgent->>Registry: broadcast(sub_id, event)\n    Registry->>ToolTask: {:opal_event, \"sub-x1\", event}\n    Note over ToolTask: re-broadcasts to parent\n    ToolTask->>ParentReg: broadcast {:sub_agent_event, \"sub-x1\", event}\n    ParentReg->>CLI: {:sub_agent_event, \"sub-x1\", {:message_delta, ...}}\n```\n\nThis gives the parent session **real-time observability** into sub-agent\nactivity without any direct process coupling. The CLI renders sub-agent events\nwith a tree border (┌─ / │ / └─) to visually distinguish them from the parent.\n\n---","ref":"supervision.html#4-sub-agent-event-forwarding"},{"type":"extras","title":"Tool Execution - Supervision","doc":"Tool calls are executed concurrently using `Task.Supervisor.async_stream_nolink`:\n\n```mermaid\nflowchart LR\n    Agent[\"Agent  blocked, waiting \"] -- \"async_stream_nolink(tasks)\" --> TaskSup[\"Task.Supervisor  per-session \"]\n    TaskSup --> T1[\"Task: read\"]\n    TaskSup --> T2[\"Task: shell\"]\n    TaskSup --> T3[\"Task: write\"]\n    T1 -- \"results\" --> Agent\n    T2 -- \"results\" --> Agent\n    T3 -- \"results\" --> Agent\n```\n\n**Why `async_stream_nolink`?**\n\n- **`async_stream`** — tasks are linked to the caller. If one crashes, the\n  Agent crashes. Bad for reliability.\n- **`async_stream_nolink`** — tasks are *not* linked. A crashing tool produces\n  `{:exit, reason}` in the result stream. The Agent converts this to an error\n  tool result and continues.\n\n**Why per-session `Task.Supervisor`?**\n\n- **Isolation:** If session A's tool tasks are misbehaving, session B is\n  unaffected.\n- **Cleanup:** Terminating the `SessionServer` automatically kills all running\n  tool tasks for that session.\n- **Observability:** You can inspect `Task.Supervisor.children(sup)` to see\n  what tools are currently running in a specific session.","ref":"supervision.html#tool-execution"},{"type":"extras","title":"Crash Recovery - Supervision","doc":"When a tool task crashes, the Agent preserves the original tool call metadata\nby zipping results with the original task list:\n\n```elixir\nresults\n|> Enum.zip(tasks)\n|> Enum.map(fn\n  {{:ok, {tc, result}}, _}        -> {tc, result}\n  {{:exit, reason}, {tc, _mod}}   -> {tc, {:error, \"crashed: #{inspect(reason)}\"}}\nend)\n```\n\nThis ensures the LLM always receives a `tool_result` message with the correct\n`call_id` — even if the tool crashed. Without this, the LLM API rejects the\nrequest with \"tool call must have a tool call ID\".\n\n---","ref":"supervision.html#crash-recovery"},{"type":"extras","title":"Sub-Agent Architecture - Supervision","doc":"","ref":"supervision.html#sub-agent-architecture"},{"type":"extras","title":"Spawning - Supervision","doc":"Sub-agents are started under the session's `DynamicSupervisor`:\n\n```elixir\nDynamicSupervisor.start_child(\n  state.sub_agent_supervisor,   # per-session, not global\n  {Opal.Agent, opts}\n)\n```\n\nThey inherit the parent's config, provider, and working directory by default.\nAny of these can be overridden — including the model (e.g., use a cheaper model\nfor simple tasks).","ref":"supervision.html#spawning"},{"type":"extras","title":"Depth Enforcement - Supervision","doc":"Sub-agents are limited to **one level** — no recursive spawning. This is\nenforced by simply excluding the `Opal.Tool.SubAgent` module from the\nsub-agent's tool list:\n\n```elixir\nparent_tools = parent_state.tools -- [Opal.Tool.SubAgent]\n```\n\nNo runtime depth counter needed. The sub-agent literally does not have the tool\navailable, so the LLM cannot request it. Clean, declarative, zero overhead.","ref":"supervision.html#depth-enforcement"},{"type":"extras","title":"Tool Sharing - Supervision","doc":"Sub-agents share the parent's `Task.Supervisor` for tool execution. This means:\n\n- Tool tasks from both the parent and sub-agents run under the same supervisor\n- Terminating the session cleans up *all* tool tasks (parent + sub-agents)\n- No need for sub-agents to have their own `Task.Supervisor`","ref":"supervision.html#tool-sharing"},{"type":"extras","title":"Lifecycle - Supervision","doc":"```mermaid\nsequenceDiagram\n    participant Parent as Parent Agent\n    participant SubAgent as Sub-Agent\n\n    Parent->>SubAgent: spawn_from_state(state, %{})\n    SubAgent-->>Parent: {:ok, sub_pid}\n\n    Parent->>SubAgent: Events.subscribe(sub_id)\n    Parent->>SubAgent: Agent.prompt(sub_pid, text)\n\n    loop Streaming & Tools\n        SubAgent-->>Parent: {:opal_event, sub_id, ...}\n        Note over Parent: forward to parent session\n    end\n\n    SubAgent-->>Parent: {:opal_event, sub_id, {:agent_end, _}}\n    Parent->>SubAgent: SubAgent.stop(sub_pid)\n    Note over SubAgent: ✗ terminated\n    Note over Parent: return {:ok, result}\n```\n\n---","ref":"supervision.html#lifecycle"},{"type":"extras","title":"Failure Domains & Isolation - Supervision","doc":"","ref":"supervision.html#failure-domains-isolation"},{"type":"extras","title":"Session Isolation - Supervision","doc":"Each session is a self-contained subtree. Failures in one session cannot\npropagate to another:\n\n| Failure                            | Impact                              |\n|------------------------------------|-------------------------------------|\n| Tool task crashes                  | Error result to LLM, agent continues|\n| Sub-agent crashes                  | Tool returns error, parent continues|\n| Agent GenServer crashes            | SessionServer restarts it (`:rest_for_one`) |\n| Task.Supervisor crashes            | Agent restarts too (`:rest_for_one`)  |\n| Entire SessionServer crashes       | Only that session is lost             |\n| `Events.Registry` crashes          | All sessions lose pubsub temporarily  |\n\n### `:rest_for_one` Strategy\n\nThe SessionServer uses `:rest_for_one` — if a child crashes, all children\nstarted *after* it are restarted. The child order is:\n\n```mermaid\nflowchart TD\n    A[\"1. Task.Supervisor\"] -->|\"if this crashes...\"| B[\"2. DynamicSupervisor\"]\n    B -->|\"...this restarts...\"| C[\"3. Session (optional)\"]\n    C -->|\"...this restarts...\"| D[\"4. Agent\"]\n\n    style A fill:#f9f,stroke:#333\n    style D fill:#bbf,stroke:#333\n```\n\nThis guarantees the Agent never runs without a working `Task.Supervisor`. But\nif the Agent crashes, the supervisors and session store remain intact.","ref":"supervision.html#session-isolation"},{"type":"extras","title":"Deadlock Prevention - Supervision","doc":"The Agent loop is a GenServer that blocks during tool execution (waiting for\n`async_stream_nolink` results). Any `GenServer.call` to the Agent from a tool\ntask would deadlock with a 5-second timeout.\n\n**Solution:** Before dispatching tool tasks, the Agent snapshots its entire\nstate into the execution context:\n\n```elixir\ncontext = %{\n  working_dir: state.working_dir,\n  session_id: state.session_id,\n  config: state.config,\n  agent_pid: self(),          # for reference only, never call into it\n  agent_state: state          # snapshot — tools read from this\n}\n```\n\nTools (including `SubAgent`) use `context.agent_state` instead of calling back\nto the Agent. The `SubAgent` tool uses `spawn_from_state/2` (takes a state\nstruct) rather than `spawn/2` (takes a pid and calls `get_state`).\n\n---","ref":"supervision.html#deadlock-prevention"},{"type":"extras","title":"Design Rationale - Supervision","doc":"","ref":"supervision.html#design-rationale"},{"type":"extras","title":"Why per-session supervision trees? - Supervision","doc":"**Before:** A single global `Task.Supervisor` handled all tool execution across\nall sessions. This had several problems:\n\n- No isolation between sessions\n- No way to cleanly shut down one session's tasks without affecting others\n- No way to inspect what a specific session is doing\n- Cleanup required manual tracking\n\n**After:** Each session owns its entire process tree. `stop_session/1` is a\nsingle `DynamicSupervisor.terminate_child/2` call that cleanly shuts down\neverything.","ref":"supervision.html#why-per-session-supervision-trees"},{"type":"extras","title":"Why Registry-based pubsub? - Supervision","doc":"- **No external dependencies** — built into OTP\n- **No serialization** — events are plain Erlang terms, delivered via `send/2`\n- **Duplicate keys** — multiple subscribers per session ID\n- **Process-native** — subscribers just use `receive`, no callback modules\n- **Automatic cleanup** — when a subscriber process dies, its registrations\n  are removed","ref":"supervision.html#why-registry-based-pubsub"},{"type":"extras","title":"Why async_stream_nolink for tools? - Supervision","doc":"- **Concurrent execution** — multiple tools run in parallel automatically\n- **Fault isolation** — one crashing tool doesn't take down the agent\n- **Ordered results** — results come back in the same order as the input,\n  making it easy to match results with their original tool calls\n- **Back-pressure** — the Agent blocks until all tools complete before\n  starting the next LLM turn (required for correct conversation flow)","ref":"supervision.html#why-async_stream_nolink-for-tools"},{"type":"extras","title":"Why sub-agents share the parent's Task.Supervisor? - Supervision","doc":"- **Simplicity** — fewer processes to manage\n- **Unified cleanup** — one supervisor termination kills everything\n- **Resource sharing** — sub-agent tool tasks are supervised identically to\n  parent tool tasks\n- **No nesting complexity** — sub-agents don't need their own SessionServer","ref":"supervision.html#why-sub-agents-share-the-parent-s-task-supervisor"},{"type":"extras","title":"Why depth-1 sub-agents only? - Supervision","doc":"- **Predictability** — recursive agent spawning can lead to unbounded resource\n  consumption\n- **Debuggability** — a flat parent→child relationship is easy to observe and\n  reason about\n- **Cost control** — each sub-agent gets its own LLM conversation, so costs\n  multiply. One level is sufficient for task delegation patterns (e.g., \"read\n  these 5 files in parallel\") without enabling runaway recursion","ref":"supervision.html#why-depth-1-sub-agents-only"}],"proglang":"elixir","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.40.1"}}