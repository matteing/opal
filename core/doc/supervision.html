<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.40.1">
    <meta name="project" content="Opal v0.1.0">


    <title>Supervision — Opal v0.1.0</title>

    <link rel="stylesheet" href="dist/html-elixir-YJO4MOOW.css" />

    <script defer src="dist/sidebar_items-93C55D77.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-YU4BZFVS.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

      <div>
        <a href="https://github.com/scohen/opal" class="sidebar-projectName" translate="no">
Opal
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v0.1.0
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras="Pages"></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of Opal</span>
            <div class="search-input-wrapper">
              <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
              <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
                <i class="ri-close-line ri-lg" title="Cancel search"></i>
              </button>
            </div>
          </label>
        </form>
        <div class="autocomplete">
        </div>
        <div class="engine-selector" data-multiple="false">
          <button type="button" class="engine-button" aria-label="Select search engine" aria-haspopup="true" aria-expanded="false">
            <i class="ri-search-2-line" aria-hidden="true"></i>
            <span class="engine-name">Default</span>
            <i class="ri-arrow-down-s-line" aria-hidden="true"></i>
          </button>
          <div class="engine-dropdown" hidden role="menu">

              <button type="button"
                      class="engine-option"
                      data-engine-url="search.html?q="
                      role="menuitemradio"
                      aria-checked="true">
                <span class="name">Default</span>
                <span class="help">In-browser search</span>
              </button>

          </div>
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>Supervision &amp; Message Passing</h1>

<a href="supervision.md" title="Copy Markdown (hold Ctrl/Cmd and click it to open as Markdown)" class="copy-markdown icon-action" rel="help">
  <i class="ri-markdown-line" aria-hidden="true"></i>
  <span class="sr-only">Copy Markdown</span>
</a>


      <a href="https://github.com/scohen/opal/blob/v0.1.0/../docs/supervision.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<p>This document describes Opal's OTP supervision architecture, process lifecycle,
message passing patterns, and the design rationale behind each decision.</p><hr class="thin"/><h2 id="supervision-tree" class="section-heading"><a href="#supervision-tree" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Supervision Tree</span></h2><p>Opal uses a <strong>per-session supervision tree</strong> so that every active session is a
fully isolated unit — its own processes, its own failure domain, its own cleanup.</p><pre><code class="mermaid">graph TD
    OpalSup[&quot;Opal.Supervisor&lt;br/&gt;&lt;i&gt;:one_for_one&lt;/i&gt;&quot;]
    Registry[&quot;Opal.Events.Registry&lt;br/&gt;&lt;i&gt;shared pubsub backbone&lt;/i&gt;&quot;]
    SessionSup[&quot;Opal.SessionSupervisor&lt;br/&gt;&lt;i&gt;DynamicSupervisor :one_for_one&lt;/i&gt;&quot;]

    OpalSup --&gt; Registry
    OpalSup --&gt; SessionSup

    subgraph session_a[&quot;Session &amp;quot;a1b2c3&amp;quot;&quot;]
        SSA[&quot;SessionServer&lt;br/&gt;&lt;i&gt;Supervisor :rest_for_one&lt;/i&gt;&quot;]
        TSA[&quot;Task.Supervisor&lt;br/&gt;&lt;i&gt;tool execution&lt;/i&gt;&quot;]
        DSA[&quot;DynamicSupervisor&lt;br/&gt;&lt;i&gt;sub-agents&lt;/i&gt;&quot;]
        SesA[&quot;Opal.Session&lt;br/&gt;&lt;i&gt;persistence (optional)&lt;/i&gt;&quot;]
        AgentA[&quot;Opal.Agent&lt;br/&gt;&lt;i&gt;agent loop&lt;/i&gt;&quot;]
        SSA --&gt; TSA
        SSA --&gt; DSA
        SSA --&gt; SesA
        SSA --&gt; AgentA
    end

    subgraph session_b[&quot;Session &amp;quot;d4e5f6&amp;quot;&quot;]
        SSB[&quot;SessionServer&lt;br/&gt;&lt;i&gt;Supervisor :rest_for_one&lt;/i&gt;&quot;]
        TSB[&quot;Task.Supervisor&quot;]
        DSB[&quot;DynamicSupervisor&quot;]
        AgentB[&quot;Opal.Agent&quot;]
        SSB --&gt; TSB
        SSB --&gt; DSB
        SSB --&gt; AgentB
    end

    SessionSup --&gt; SSA
    SessionSup --&gt; SSB</code></pre><h3 id="when-sub-agents-are-active" class="section-heading"><a href="#when-sub-agents-are-active" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">When sub-agents are active</span></h3><p>Sub-agents are regular <a href="Opal.Agent.html"><code class="inline">Opal.Agent</code></a> processes started under the session's own
<a href="https://hexdocs.pm/elixir/DynamicSupervisor.html"><code class="inline">DynamicSupervisor</code></a>. They share the parent's <a href="https://hexdocs.pm/elixir/Task.Supervisor.html"><code class="inline">Task.Supervisor</code></a> for tool
execution but cannot spawn further sub-agents (depth = 1).</p><pre><code class="mermaid">graph TD
    SS[&quot;SessionServer &amp;quot;a1b2c3&amp;quot;&lt;br/&gt;&lt;i&gt;:rest_for_one&lt;/i&gt;&quot;]
    TS[&quot;Task.Supervisor&lt;br/&gt;&lt;i&gt;shared by parent + sub-agents&lt;/i&gt;&quot;]
    DS[&quot;DynamicSupervisor&lt;br/&gt;&lt;i&gt;owns sub-agent processes&lt;/i&gt;&quot;]
    Ses[&quot;Opal.Session&lt;br/&gt;&lt;i&gt;conversation tree (optional)&lt;/i&gt;&quot;]
    PA[&quot;Opal.Agent&lt;br/&gt;&lt;i&gt;parent agent loop&lt;/i&gt;&quot;]
    SubA[&quot;Opal.Agent &amp;quot;sub-x1y2z3&amp;quot;&lt;br/&gt;&lt;i&gt;sub-agent A&lt;/i&gt;&quot;]
    SubB[&quot;Opal.Agent &amp;quot;sub-p4q5r6&amp;quot;&lt;br/&gt;&lt;i&gt;sub-agent B&lt;/i&gt;&quot;]

    SS --&gt; TS
    SS --&gt; DS
    SS --&gt; Ses
    SS --&gt; PA
    DS --&gt; SubA
    DS --&gt; SubB</code></pre><hr class="thin"/><h2 id="process-roles" class="section-heading"><a href="#process-roles" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Process Roles</span></h2><h3 id="opal-events-registry" class="section-heading"><a href="#opal-events-registry" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text"><code class="inline">Opal.Events.Registry</code></span></h3><p>A <a href="https://hexdocs.pm/elixir/Registry.html"><code class="inline">Registry</code></a> with <code class="inline">:duplicate</code> keys. Any process can subscribe to a session ID
and receive events. This is the <strong>only shared global process</strong> — everything else
is per-session. The registry never holds state; it simply routes messages.</p><h3 id="opal-sessionsupervisor" class="section-heading"><a href="#opal-sessionsupervisor" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text"><code class="inline">Opal.SessionSupervisor</code></span></h3><p>A <a href="https://hexdocs.pm/elixir/DynamicSupervisor.html"><code class="inline">DynamicSupervisor</code></a> that acts as the container for all active sessions. When
<a href="Opal.html#start_session/1"><code class="inline">Opal.start_session/1</code></a> is called, a new <code class="inline">SessionServer</code> child is started here.
When <a href="Opal.html#stop_session/1"><code class="inline">Opal.stop_session/1</code></a> is called, the entire <code class="inline">SessionServer</code> subtree is
terminated — one call cleans up the agent, all running tools, all sub-agents,
and the session store.</p><h3 id="opal-sessionserver" class="section-heading"><a href="#opal-sessionserver" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text"><a href="Opal.SessionServer.html"><code class="inline">Opal.SessionServer</code></a></span></h3><p>A per-session <a href="https://hexdocs.pm/elixir/Supervisor.html"><code class="inline">Supervisor</code></a> using the <code class="inline">:rest_for_one</code> strategy. Children are
started in order:</p><ol><li><strong><a href="https://hexdocs.pm/elixir/Task.Supervisor.html"><code class="inline">Task.Supervisor</code></a></strong> — executes tool calls as supervised tasks</li><li><strong><a href="https://hexdocs.pm/elixir/DynamicSupervisor.html"><code class="inline">DynamicSupervisor</code></a></strong> — manages sub-agent processes</li><li><strong><a href="Opal.Session.html"><code class="inline">Opal.Session</code></a></strong> — conversation persistence <em>(optional, started when <code class="inline">session: true</code>)</em></li><li><strong><a href="Opal.Agent.html"><code class="inline">Opal.Agent</code></a></strong> — the agent loop</li></ol><p>The <code class="inline">:rest_for_one</code> strategy means if the <a href="https://hexdocs.pm/elixir/Task.Supervisor.html"><code class="inline">Task.Supervisor</code></a> or
<a href="https://hexdocs.pm/elixir/DynamicSupervisor.html"><code class="inline">DynamicSupervisor</code></a> crashes, the Agent (which depends on them) is restarted
too. But a crash in the Agent does not affect the supervisors above it.</p><p>Each child is registered with a session-scoped atom name for discoverability:</p><table><thead><tr><th style="text-align: left;">Process</th><th style="text-align: left;">Name</th></tr></thead><tbody><tr><td style="text-align: left;">Task.Supervisor</td><td style="text-align: left;"><code class="inline">:&quot;opal_tool_sup_#{session_id}&quot;</code></td></tr><tr><td style="text-align: left;">DynamicSupervisor</td><td style="text-align: left;"><code class="inline">:&quot;opal_sub_agent_sup_#{session_id}&quot;</code></td></tr><tr><td style="text-align: left;">Session</td><td style="text-align: left;"><code class="inline">:&quot;opal_session_#{session_id}&quot;</code></td></tr></tbody></table><h3 id="opal-agent" class="section-heading"><a href="#opal-agent" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text"><a href="Opal.Agent.html"><code class="inline">Opal.Agent</code></a></span></h3><p>A <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a> that implements the core agent loop:</p><ol><li>Receive a user prompt (<code class="inline">handle_cast</code>)</li><li>Stream an LLM response via the configured <code class="inline">Provider</code></li><li>If the LLM returns tool calls → execute them concurrently → loop to step 2</li><li>If the LLM returns text only → broadcast <code class="inline">agent_end</code> → go idle</li></ol><p>The Agent holds references to its session-local <code class="inline">tool_supervisor</code> and
<code class="inline">sub_agent_supervisor</code> in its state — it never touches global process names.</p><h3 id="opal-session" class="section-heading"><a href="#opal-session" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text"><a href="Opal.Session.html"><code class="inline">Opal.Session</code></a></span></h3><p>A <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a> backed by an ETS table that stores conversation messages in a
tree structure (each message has a <code class="inline">parent_id</code>). Supports branching — rewinding
to any past message and forking the conversation. Persistence is via ETF
serialization to disk.</p><hr class="thin"/><h2 id="message-passing" class="section-heading"><a href="#message-passing" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Message Passing</span></h2><p>Opal uses three distinct message passing patterns, each chosen for a specific
purpose.</p><h3 id="1-genserver-calls-synchronous-state-access" class="section-heading"><a href="#1-genserver-calls-synchronous-state-access" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">1. GenServer Calls — Synchronous State Access</span></h3><pre><code class="mermaid">sequenceDiagram
    participant Caller
    participant Agent

    Caller-&gt;&gt;Agent: GenServer.call(:get_state)
    Agent--&gt;&gt;Caller: %Agent.State{}</code></pre><p>Used for: <code class="inline">Agent.get_state/1</code>, <code class="inline">Session.append/2</code>, <code class="inline">Session.get_path/1</code></p><p>These are standard GenServer synchronous calls — the caller blocks until the
server replies. Used when the caller needs a consistent snapshot of state.</p><p><strong>Key design decision:</strong> Tool tasks never call <code class="inline">Agent.get_state(agent_pid)</code>
during execution. The Agent is blocked in <code class="inline">Task.Supervisor.async_stream_nolink</code>
waiting for tool results — a <code class="inline">GenServer.call</code> from a tool task back to the
Agent would deadlock. Instead, the Agent snapshots its state into the tool
execution context <em>before</em> dispatching tasks:</p><pre><code class="mermaid">flowchart LR
    Agent[&quot;Agent&lt;br/&gt;&lt;i&gt;(blocked)&lt;/i&gt;&quot;] -- &quot;snapshot state&quot; --&gt; Context[&quot;context =&lt;br/&gt;%{agent_state: ...}&quot;]
    Context -- &quot;start tasks&quot; --&gt; Tasks[&quot;Tool Tasks&lt;br/&gt;&lt;i&gt;read from context&lt;/i&gt;&quot;]</code></pre><h3 id="2-genserver-casts-asynchronous-commands" class="section-heading"><a href="#2-genserver-casts-asynchronous-commands" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">2. GenServer Casts — Asynchronous Commands</span></h3><pre><code class="mermaid">sequenceDiagram
    participant Caller
    participant Agent

    Caller-&gt;&gt;Agent: GenServer.cast({:prompt, text})
    Note right of Caller: :ok (immediate)
    Note right of Agent: begins turn...</code></pre><p>Used for: <code class="inline">Agent.prompt/2</code>, <code class="inline">Agent.steer/2</code>, <code class="inline">Agent.abort/1</code></p><p>Prompts are fire-and-forget casts. The caller gets <code class="inline">:ok</code> immediately and
observes progress through events (pattern 3). This keeps the caller
non-blocking — critical for interactive CLI and web UIs.</p><h3 id="3-registry-pubsub-event-broadcasting" class="section-heading"><a href="#3-registry-pubsub-event-broadcasting" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">3. Registry PubSub — Event Broadcasting</span></h3><pre><code class="mermaid">flowchart LR
    Agent[&quot;Agent broadcasts&lt;br/&gt;{:message_delta, ...}&quot;] --&gt; Registry[&quot;Opal.Events.Registry&lt;br/&gt;&lt;i&gt;session_id key&lt;br/&gt;duplicate keys&lt;/i&gt;&quot;]
    Registry --&gt; SubA[&quot;Subscriber A&lt;br/&gt;&lt;i&gt;CLI&lt;/i&gt;&quot;]
    Registry --&gt; SubB[&quot;Subscriber B&lt;br/&gt;&lt;i&gt;UI&lt;/i&gt;&quot;]
    Registry --&gt; SubC[&quot;Subscriber C&lt;br/&gt;&lt;i&gt;test&lt;/i&gt;&quot;]</code></pre><p>Used for: all agent lifecycle events</p><p>The Agent (and tool tasks) call <code class="inline">Opal.Events.broadcast(session_id, event)</code>.
Every process that called <code class="inline">Opal.Events.subscribe(session_id)</code> receives the
event as a regular Erlang message:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="7012525583-1">{</span><span class="ss">:opal_event</span><span class="p">,</span><span class="w"> </span><span class="n">session_id</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p" data-group-id="7012525583-1">}</span></code></pre><p><strong>Event types:</strong></p><table><thead><tr><th style="text-align: left;">Event</th><th style="text-align: left;">Emitted when</th></tr></thead><tbody><tr><td style="text-align: left;"><code class="inline">{:agent_start}</code></td><td style="text-align: left;">Agent begins processing a prompt</td></tr><tr><td style="text-align: left;"><code class="inline">{:message_delta, %{delta: text}}</code></td><td style="text-align: left;">Streaming text token from the LLM</td></tr><tr><td style="text-align: left;"><code class="inline">{:thinking_delta, %{delta: text}}</code></td><td style="text-align: left;">Streaming thinking/reasoning token</td></tr><tr><td style="text-align: left;"><code class="inline">{:turn_end, message, tool_calls}</code></td><td style="text-align: left;">LLM turn complete, tool calls follow</td></tr><tr><td style="text-align: left;"><code class="inline">{:tool_execution_start, name, args}</code></td><td style="text-align: left;">Tool begins executing</td></tr><tr><td style="text-align: left;"><code class="inline">{:tool_execution_end, name, result}</code></td><td style="text-align: left;">Tool finished executing</td></tr><tr><td style="text-align: left;"><code class="inline">{:agent_end, messages}</code></td><td style="text-align: left;">Agent is done, returning to idle</td></tr><tr><td style="text-align: left;"><code class="inline">{:error, reason}</code></td><td style="text-align: left;">Unrecoverable error occurred</td></tr><tr><td style="text-align: left;"><code class="inline">{:sub_agent_event, sub_id, event}</code></td><td style="text-align: left;">Forwarded event from a sub-agent</td></tr></tbody></table><p>This is built on OTP's <a href="https://hexdocs.pm/elixir/Registry.html"><code class="inline">Registry</code></a> — no external dependencies, no message
broker, no serialization overhead. Events are plain Erlang terms sent via
<a href="https://hexdocs.pm/elixir/Kernel.html#send/2"><code class="inline">send/2</code></a> under the hood.</p><h3 id="4-sub-agent-event-forwarding" class="section-heading"><a href="#4-sub-agent-event-forwarding" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">4. Sub-Agent Event Forwarding</span></h3><p>Sub-agents broadcast events to their own session ID. The <code class="inline">SubAgent</code> tool
subscribes to those events, collects the response, and <strong>re-broadcasts</strong> each
event to the parent session tagged with the sub-agent's ID:</p><pre><code class="mermaid">sequenceDiagram
    participant SubAgent as Sub-Agent &quot;sub-x1&quot;
    participant Registry as Events Registry
    participant ToolTask as SubAgent Tool Task
    participant ParentReg as Parent Events Registry
    participant CLI as CLI Subscriber

    SubAgent-&gt;&gt;Registry: broadcast(sub_id, event)
    Registry-&gt;&gt;ToolTask: {:opal_event, &quot;sub-x1&quot;, event}
    Note over ToolTask: re-broadcasts to parent
    ToolTask-&gt;&gt;ParentReg: broadcast {:sub_agent_event, &quot;sub-x1&quot;, event}
    ParentReg-&gt;&gt;CLI: {:sub_agent_event, &quot;sub-x1&quot;, {:message_delta, ...}}</code></pre><p>This gives the parent session <strong>real-time observability</strong> into sub-agent
activity without any direct process coupling. The CLI renders sub-agent events
with a tree border (┌─ / │ / └─) to visually distinguish them from the parent.</p><hr class="thin"/><h2 id="tool-execution" class="section-heading"><a href="#tool-execution" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Tool Execution</span></h2><p>Tool calls are executed concurrently using <code class="inline">Task.Supervisor.async_stream_nolink</code>:</p><pre><code class="mermaid">flowchart LR
    Agent[&quot;Agent&lt;br/&gt;&lt;i&gt;blocked, waiting&lt;/i&gt;&quot;] -- &quot;async_stream_nolink(tasks)&quot; --&gt; TaskSup[&quot;Task.Supervisor&lt;br/&gt;&lt;i&gt;per-session&lt;/i&gt;&quot;]
    TaskSup --&gt; T1[&quot;Task: read&quot;]
    TaskSup --&gt; T2[&quot;Task: shell&quot;]
    TaskSup --&gt; T3[&quot;Task: write&quot;]
    T1 -- &quot;results&quot; --&gt; Agent
    T2 -- &quot;results&quot; --&gt; Agent
    T3 -- &quot;results&quot; --&gt; Agent</code></pre><p><strong>Why <code class="inline">async_stream_nolink</code>?</strong></p><ul><li><strong><code class="inline">async_stream</code></strong> — tasks are linked to the caller. If one crashes, the
Agent crashes. Bad for reliability.</li><li><strong><code class="inline">async_stream_nolink</code></strong> — tasks are <em>not</em> linked. A crashing tool produces
<code class="inline">{:exit, reason}</code> in the result stream. The Agent converts this to an error
tool result and continues.</li></ul><p><strong>Why per-session <a href="https://hexdocs.pm/elixir/Task.Supervisor.html"><code class="inline">Task.Supervisor</code></a>?</strong></p><ul><li><strong>Isolation:</strong> If session A's tool tasks are misbehaving, session B is
unaffected.</li><li><strong>Cleanup:</strong> Terminating the <code class="inline">SessionServer</code> automatically kills all running
tool tasks for that session.</li><li><strong>Observability:</strong> You can inspect <code class="inline">Task.Supervisor.children(sup)</code> to see
what tools are currently running in a specific session.</li></ul><h3 id="crash-recovery" class="section-heading"><a href="#crash-recovery" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Crash Recovery</span></h3><p>When a tool task crashes, the Agent preserves the original tool call metadata
by zipping results with the original task list:</p><pre><code class="makeup elixir" translate="no"><span class="n">results</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">zip</span><span class="p" data-group-id="0419722297-1">(</span><span class="n">tasks</span><span class="p" data-group-id="0419722297-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="0419722297-2">(</span><span class="k" data-group-id="0419722297-3">fn</span><span class="w">
  </span><span class="p" data-group-id="0419722297-4">{</span><span class="p" data-group-id="0419722297-5">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0419722297-6">{</span><span class="n">tc</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="0419722297-6">}</span><span class="p" data-group-id="0419722297-5">}</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="0419722297-4">}</span><span class="w">        </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="0419722297-7">{</span><span class="n">tc</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="0419722297-7">}</span><span class="w">
  </span><span class="p" data-group-id="0419722297-8">{</span><span class="p" data-group-id="0419722297-9">{</span><span class="ss">:exit</span><span class="p">,</span><span class="w"> </span><span class="n">reason</span><span class="p" data-group-id="0419722297-9">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0419722297-10">{</span><span class="n">tc</span><span class="p">,</span><span class="w"> </span><span class="c">_mod</span><span class="p" data-group-id="0419722297-10">}</span><span class="p" data-group-id="0419722297-8">}</span><span class="w">   </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="0419722297-11">{</span><span class="n">tc</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0419722297-12">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;crashed: </span><span class="si" data-group-id="0419722297-13">#{</span><span class="n">inspect</span><span class="p" data-group-id="0419722297-14">(</span><span class="n">reason</span><span class="p" data-group-id="0419722297-14">)</span><span class="si" data-group-id="0419722297-13">}</span><span class="s">&quot;</span><span class="p" data-group-id="0419722297-12">}</span><span class="p" data-group-id="0419722297-11">}</span><span class="w">
</span><span class="k" data-group-id="0419722297-3">end</span><span class="p" data-group-id="0419722297-2">)</span></code></pre><p>This ensures the LLM always receives a <code class="inline">tool_result</code> message with the correct
<code class="inline">call_id</code> — even if the tool crashed. Without this, the LLM API rejects the
request with &quot;tool call must have a tool call ID&quot;.</p><hr class="thin"/><h2 id="sub-agent-architecture" class="section-heading"><a href="#sub-agent-architecture" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Sub-Agent Architecture</span></h2><h3 id="spawning" class="section-heading"><a href="#spawning" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Spawning</span></h3><p>Sub-agents are started under the session's <a href="https://hexdocs.pm/elixir/DynamicSupervisor.html"><code class="inline">DynamicSupervisor</code></a>:</p><pre><code class="makeup elixir" translate="no"><span class="nc">DynamicSupervisor</span><span class="o">.</span><span class="n">start_child</span><span class="p" data-group-id="0278421057-1">(</span><span class="w">
  </span><span class="n">state</span><span class="o">.</span><span class="n">sub_agent_supervisor</span><span class="p">,</span><span class="w">   </span><span class="c1"># per-session, not global</span><span class="w">
  </span><span class="p" data-group-id="0278421057-2">{</span><span class="nc">Opal.Agent</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p" data-group-id="0278421057-2">}</span><span class="w">
</span><span class="p" data-group-id="0278421057-1">)</span></code></pre><p>They inherit the parent's config, provider, and working directory by default.
Any of these can be overridden — including the model (e.g., use a cheaper model
for simple tasks).</p><h3 id="depth-enforcement" class="section-heading"><a href="#depth-enforcement" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Depth Enforcement</span></h3><p>Sub-agents are limited to <strong>one level</strong> — no recursive spawning. This is
enforced by simply excluding the <a href="Opal.Tool.SubAgent.html"><code class="inline">Opal.Tool.SubAgent</code></a> module from the
sub-agent's tool list:</p><pre><code class="makeup elixir" translate="no"><span class="n">parent_tools</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent_state</span><span class="o">.</span><span class="n">tools</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="p" data-group-id="6180071921-1">[</span><span class="nc">Opal.Tool.SubAgent</span><span class="p" data-group-id="6180071921-1">]</span></code></pre><p>No runtime depth counter needed. The sub-agent literally does not have the tool
available, so the LLM cannot request it. Clean, declarative, zero overhead.</p><h3 id="tool-sharing" class="section-heading"><a href="#tool-sharing" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Tool Sharing</span></h3><p>Sub-agents share the parent's <a href="https://hexdocs.pm/elixir/Task.Supervisor.html"><code class="inline">Task.Supervisor</code></a> for tool execution. This means:</p><ul><li>Tool tasks from both the parent and sub-agents run under the same supervisor</li><li>Terminating the session cleans up <em>all</em> tool tasks (parent + sub-agents)</li><li>No need for sub-agents to have their own <a href="https://hexdocs.pm/elixir/Task.Supervisor.html"><code class="inline">Task.Supervisor</code></a></li></ul><h3 id="lifecycle" class="section-heading"><a href="#lifecycle" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Lifecycle</span></h3><pre><code class="mermaid">sequenceDiagram
    participant Parent as Parent Agent
    participant SubAgent as Sub-Agent

    Parent-&gt;&gt;SubAgent: spawn_from_state(state, %{})
    SubAgent--&gt;&gt;Parent: {:ok, sub_pid}

    Parent-&gt;&gt;SubAgent: Events.subscribe(sub_id)
    Parent-&gt;&gt;SubAgent: Agent.prompt(sub_pid, text)

    loop Streaming &amp; Tools
        SubAgent--&gt;&gt;Parent: {:opal_event, sub_id, ...}
        Note over Parent: forward to parent session
    end

    SubAgent--&gt;&gt;Parent: {:opal_event, sub_id, {:agent_end, _}}
    Parent-&gt;&gt;SubAgent: SubAgent.stop(sub_pid)
    Note over SubAgent: ✗ terminated
    Note over Parent: return {:ok, result}</code></pre><hr class="thin"/><h2 id="failure-domains-isolation" class="section-heading"><a href="#failure-domains-isolation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Failure Domains &amp; Isolation</span></h2><h3 id="session-isolation" class="section-heading"><a href="#session-isolation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Session Isolation</span></h3><p>Each session is a self-contained subtree. Failures in one session cannot
propagate to another:</p><table><thead><tr><th style="text-align: left;">Failure</th><th style="text-align: left;">Impact</th></tr></thead><tbody><tr><td style="text-align: left;">Tool task crashes</td><td style="text-align: left;">Error result to LLM, agent continues</td></tr><tr><td style="text-align: left;">Sub-agent crashes</td><td style="text-align: left;">Tool returns error, parent continues</td></tr><tr><td style="text-align: left;">Agent GenServer crashes</td><td style="text-align: left;">SessionServer restarts it (<code class="inline">:rest_for_one</code>)</td></tr><tr><td style="text-align: left;">Task.Supervisor crashes</td><td style="text-align: left;">Agent restarts too (<code class="inline">:rest_for_one</code>)</td></tr><tr><td style="text-align: left;">Entire SessionServer crashes</td><td style="text-align: left;">Only that session is lost</td></tr><tr><td style="text-align: left;"><code class="inline">Events.Registry</code> crashes</td><td style="text-align: left;">All sessions lose pubsub temporarily</td></tr></tbody></table><h3 id="rest_for_one-strategy" class="section-heading"><a href="#rest_for_one-strategy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text"><code class="inline">:rest_for_one</code> Strategy</span></h3><p>The SessionServer uses <code class="inline">:rest_for_one</code> — if a child crashes, all children
started <em>after</em> it are restarted. The child order is:</p><pre><code class="mermaid">flowchart TD
    A[&quot;1. Task.Supervisor&quot;] --&gt;|&quot;if this crashes...&quot;| B[&quot;2. DynamicSupervisor&quot;]
    B --&gt;|&quot;...this restarts...&quot;| C[&quot;3. Session (optional)&quot;]
    C --&gt;|&quot;...this restarts...&quot;| D[&quot;4. Agent&quot;]

    style A fill:#f9f,stroke:#333
    style D fill:#bbf,stroke:#333</code></pre><p>This guarantees the Agent never runs without a working <a href="https://hexdocs.pm/elixir/Task.Supervisor.html"><code class="inline">Task.Supervisor</code></a>. But
if the Agent crashes, the supervisors and session store remain intact.</p><h3 id="deadlock-prevention" class="section-heading"><a href="#deadlock-prevention" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Deadlock Prevention</span></h3><p>The Agent loop is a GenServer that blocks during tool execution (waiting for
<code class="inline">async_stream_nolink</code> results). Any <code class="inline">GenServer.call</code> to the Agent from a tool
task would deadlock with a 5-second timeout.</p><p><strong>Solution:</strong> Before dispatching tool tasks, the Agent snapshots its entire
state into the execution context:</p><pre><code class="makeup elixir" translate="no"><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2114198798-1">%{</span><span class="w">
  </span><span class="ss">working_dir</span><span class="p">:</span><span class="w"> </span><span class="n">state</span><span class="o">.</span><span class="n">working_dir</span><span class="p">,</span><span class="w">
  </span><span class="ss">session_id</span><span class="p">:</span><span class="w"> </span><span class="n">state</span><span class="o">.</span><span class="n">session_id</span><span class="p">,</span><span class="w">
  </span><span class="ss">config</span><span class="p">:</span><span class="w"> </span><span class="n">state</span><span class="o">.</span><span class="n">config</span><span class="p">,</span><span class="w">
  </span><span class="ss">agent_pid</span><span class="p">:</span><span class="w"> </span><span class="n">self</span><span class="p" data-group-id="2114198798-2">(</span><span class="p" data-group-id="2114198798-2">)</span><span class="p">,</span><span class="w">          </span><span class="c1"># for reference only, never call into it</span><span class="w">
  </span><span class="ss">agent_state</span><span class="p">:</span><span class="w"> </span><span class="n">state</span><span class="w">          </span><span class="c1"># snapshot — tools read from this</span><span class="w">
</span><span class="p" data-group-id="2114198798-1">}</span></code></pre><p>Tools (including <code class="inline">SubAgent</code>) use <code class="inline">context.agent_state</code> instead of calling back
to the Agent. The <code class="inline">SubAgent</code> tool uses <code class="inline">spawn_from_state/2</code> (takes a state
struct) rather than <code class="inline">spawn/2</code> (takes a pid and calls <code class="inline">get_state</code>).</p><hr class="thin"/><h2 id="design-rationale" class="section-heading"><a href="#design-rationale" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Design Rationale</span></h2><h3 id="why-per-session-supervision-trees" class="section-heading"><a href="#why-per-session-supervision-trees" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Why per-session supervision trees?</span></h3><p><strong>Before:</strong> A single global <a href="https://hexdocs.pm/elixir/Task.Supervisor.html"><code class="inline">Task.Supervisor</code></a> handled all tool execution across
all sessions. This had several problems:</p><ul><li>No isolation between sessions</li><li>No way to cleanly shut down one session's tasks without affecting others</li><li>No way to inspect what a specific session is doing</li><li>Cleanup required manual tracking</li></ul><p><strong>After:</strong> Each session owns its entire process tree. <code class="inline">stop_session/1</code> is a
single <a href="https://hexdocs.pm/elixir/DynamicSupervisor.html#terminate_child/2"><code class="inline">DynamicSupervisor.terminate_child/2</code></a> call that cleanly shuts down
everything.</p><h3 id="why-registry-based-pubsub" class="section-heading"><a href="#why-registry-based-pubsub" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Why Registry-based pubsub?</span></h3><ul><li><strong>No external dependencies</strong> — built into OTP</li><li><strong>No serialization</strong> — events are plain Erlang terms, delivered via <a href="https://hexdocs.pm/elixir/Kernel.html#send/2"><code class="inline">send/2</code></a></li><li><strong>Duplicate keys</strong> — multiple subscribers per session ID</li><li><strong>Process-native</strong> — subscribers just use <code class="inline">receive</code>, no callback modules</li><li><strong>Automatic cleanup</strong> — when a subscriber process dies, its registrations
are removed</li></ul><h3 id="why-async_stream_nolink-for-tools" class="section-heading"><a href="#why-async_stream_nolink-for-tools" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Why <code class="inline">async_stream_nolink</code> for tools?</span></h3><ul><li><strong>Concurrent execution</strong> — multiple tools run in parallel automatically</li><li><strong>Fault isolation</strong> — one crashing tool doesn't take down the agent</li><li><strong>Ordered results</strong> — results come back in the same order as the input,
making it easy to match results with their original tool calls</li><li><strong>Back-pressure</strong> — the Agent blocks until all tools complete before
starting the next LLM turn (required for correct conversation flow)</li></ul><h3 id="why-sub-agents-share-the-parent-s-task-supervisor" class="section-heading"><a href="#why-sub-agents-share-the-parent-s-task-supervisor" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Why sub-agents share the parent's Task.Supervisor?</span></h3><ul><li><strong>Simplicity</strong> — fewer processes to manage</li><li><strong>Unified cleanup</strong> — one supervisor termination kills everything</li><li><strong>Resource sharing</strong> — sub-agent tool tasks are supervised identically to
parent tool tasks</li><li><strong>No nesting complexity</strong> — sub-agents don't need their own SessionServer</li></ul><h3 id="why-depth-1-sub-agents-only" class="section-heading"><a href="#why-depth-1-sub-agents-only" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Why depth-1 sub-agents only?</span></h3><ul><li><strong>Predictability</strong> — recursive agent spawning can lead to unbounded resource
consumption</li><li><strong>Debuggability</strong> — a flat parent→child relationship is easy to observe and
reason about</li><li><strong>Cost control</strong> — each sub-agent gets its own LLM conversation, so costs
multiply. One level is sufficient for task delegation patterns (e.g., &quot;read
these 5 files in parallel&quot;) without enabling runaway recursion</li></ul>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="rpc-research.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
RPC Research
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

  </div>
</div>
    <footer class="footer">

        <p>

            <span class="line">
              <a href="https://hex.pm/packages/opal/0.1.0">Hex Package</a>

              <a href="https://preview.hex.pm/preview/opal/0.1.0">Hex Preview</a>

                (<a href="https://preview.hex.pm/preview/opal/0.1.0/show/../docs/supervision.md">current file</a>)

            </span>

          <span class="line">
            <button class="a-main footer-button display-quick-switch" title="Go to package docs">
              Go to package docs
            </button>

              <a href="llms.txt" target="_blank">
                View llms.txt
              </a>


              <a href="Opal.epub">
                Download ePub version
              </a>

          </span>
        </p>

        <p class="built-using">
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.40.1) for the

            <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

        </p>


    </footer>
  </div>
</main>
</div>

  </body>
</html>
