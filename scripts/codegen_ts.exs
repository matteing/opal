# scripts/codegen_ts.exs
#
# Generates cli/src/sdk/protocol.ts from priv/rpc_schema.json.
#
# The schema is the intermediate artifact — this script does NOT depend
# on the Elixir compilation of Opal.RPC.Protocol. To update the schema,
# run: mix opal.gen.json_schema
#
# Emits plain TypeScript types — no runtime dependencies.
#
# Usage:
#   mix run scripts/codegen_ts.exs [--check]
#

defmodule Codegen.TS do
  @output_path "../cli/src/sdk/protocol.ts"
  @schema_path "priv/rpc_schema.json"

  def run(args) do
    schema = @schema_path |> File.read!() |> Jason.decode!()
    ts = generate(schema) |> prettier()

    if "--check" in args do
      existing = File.read!(@output_path)

      if existing != ts do
        IO.puts(
          :stderr,
          "protocol.ts is out of date. Run: mix run scripts/codegen_ts.exs"
        )

        System.halt(1)
      else
        IO.puts("protocol.ts is up to date.")
      end
    else
      File.write!(@output_path, ts)
      IO.puts("Wrote #{@output_path}")
    end
  end

  defp prettier(code) do
    tmp = Path.join(System.tmp_dir!(), "codegen_protocol.ts")
    File.write!(tmp, code)
    {_output, 0} = System.cmd("npx", ["prettier", "--write", tmp], stderr_to_stdout: true)
    result = File.read!(tmp)
    File.rm!(tmp)
    result
  end

  defp generate(schema) do
    defs = schema["definitions"]
    methods = parse_methods(defs["methods"] || %{})
    server_requests = parse_methods(defs["server_requests"] || %{})
    event_types = parse_events(defs["events"] || %{})

    [
      "// AUTO-GENERATED by scripts/codegen_ts.exs — DO NOT EDIT\n",
      "// Source: priv/rpc_schema.json (version #{schema["version"]})\n\n",
      "// --- Method param/result types ---\n\n",
      Enum.map(methods, &method_types/1),
      Enum.map(server_requests, &method_types/1),
      "// --- Agent event types ---\n\n",
      Enum.map(event_types, &event_type/1),
      agent_event_union(event_types),
      "\n// --- Method constants ---\n\n",
      method_constants(methods, server_requests),
      "\n// --- Helper types ---\n\n",
      helper_types(),
      "\n// --- Method type mapping ---\n\n",
      method_type_map(methods, server_requests)
    ]
    |> IO.iodata_to_binary()
  end

  # -- JSON Schema → internal representation --

  defp parse_methods(methods_map) do
    methods_map
    |> Enum.map(fn {method_name, spec} ->
      params = parse_params(spec["params"])
      result = parse_result(spec["result"])
      %{method: method_name, params: params, result: result}
    end)
    |> Enum.sort_by(& &1.method)
  end

  defp parse_params(%{"properties" => props} = schema) when map_size(props) > 0 do
    required = MapSet.new(schema["required"] || [])

    props
    |> Enum.map(fn {name, field_schema} ->
      %{
        name: name,
        type: json_schema_to_type(field_schema),
        required: MapSet.member?(required, name),
        description: field_schema["description"] || ""
      }
    end)
    |> Enum.sort_by(& &1.name)
  end

  defp parse_params(_), do: []

  defp parse_result(%{"properties" => props} = schema) when map_size(props) > 0 do
    required = MapSet.new(schema["required"] || [])

    props
    |> Enum.map(fn {name, field_schema} ->
      %{
        name: name,
        type: json_schema_to_type(field_schema),
        required: MapSet.member?(required, name),
        description: field_schema["description"] || ""
      }
    end)
    |> Enum.sort_by(& &1.name)
  end

  defp parse_result(_), do: []

  defp parse_events(events_map) do
    events_map
    |> Enum.map(fn {event_type, spec} ->
      # Exclude synthetic "type" and "session_id" fields — they're always present
      fields =
        (spec["properties"] || %{})
        |> Enum.reject(fn {name, _} -> name in ["type", "session_id"] end)
        |> Enum.map(fn {name, field_schema} ->
          required_fields = MapSet.new(spec["required"] || [])

          %{
            name: name,
            type: json_schema_to_type(field_schema),
            description: field_schema["description"] || "",
            required: MapSet.member?(required_fields, name)
          }
        end)
        |> Enum.sort_by(& &1.name)

      %{type: event_type, fields: fields}
    end)
    |> Enum.sort_by(& &1.type)
  end

  defp json_schema_to_type(%{"type" => "string", "const" => val}), do: {:literal, val}
  defp json_schema_to_type(%{"type" => "string"}), do: :string
  defp json_schema_to_type(%{"type" => "boolean"}), do: :boolean
  defp json_schema_to_type(%{"type" => "integer"}), do: :integer
  defp json_schema_to_type(%{"type" => "number"}), do: :integer

  defp json_schema_to_type(%{"type" => "array", "items" => items}) do
    {:array, json_schema_to_type(items)}
  end

  defp json_schema_to_type(%{"type" => "object", "properties" => props} = schema)
       when map_size(props) > 0 do
    required = MapSet.new(schema["required"] || [])

    fields =
      Map.new(props, fn {name, field_schema} ->
        {name, json_schema_to_type(field_schema)}
      end)

    {:object, fields, required}
  end

  defp json_schema_to_type(%{"type" => "object"}), do: :object
  defp json_schema_to_type(_), do: :object

  # -- TypeScript type generation --

  defp method_types(%{method: method, params: params, result: result}) do
    base = method_to_type_name(method)

    params_block =
      if params == [] do
        "export type #{base}Params = Record<string, never>;\n\n"
      else
        fields = Enum.map_join(params, "\n", &ts_field/1)
        "export type #{base}Params = {\n#{fields}\n};\n\n"
      end

    result_block =
      if result == [] do
        "export type #{base}Result = Record<string, never>;\n\n"
      else
        fields = Enum.map_join(result, "\n", &ts_field/1)
        "export type #{base}Result = {\n#{fields}\n};\n\n"
      end

    params_block <> result_block
  end

  defp event_type(%{type: type, fields: fields}) do
    name = snake_to_pascal(type)
    camel_type = snake_to_camel(type)
    type_field = "  /** Event type discriminator. */\n  readonly type: \"#{camel_type}\";"

    if fields == [] do
      "export type #{name}Event = {\n#{type_field}\n};\n\n"
    else
      field_lines = Enum.map_join(fields, "\n", &ts_field/1)
      "export type #{name}Event = {\n#{type_field}\n#{field_lines}\n};\n\n"
    end
  end

  defp agent_event_union(event_types) do
    type_names =
      Enum.map_join(event_types, "\n  | ", fn %{type: t} -> "#{snake_to_pascal(t)}Event" end)

    """

    export type AgentEvent =
      | #{type_names};
    """
  end

  defp method_constants(methods, server_requests) do
    method_lines =
      Enum.map_join(methods, "\n", fn %{method: m} ->
        const = method_to_const(m)
        "  #{const}: \"#{m}\" as const,"
      end)

    sr_lines =
      Enum.map_join(server_requests, "\n", fn %{method: m} ->
        const = method_to_const(m)
        "  #{const}: \"#{m}\" as const,"
      end)

    "export const Methods = {\n#{method_lines}\n#{sr_lines}\n} as const;\n"
  end

  defp helper_types do
    """
    export type TokenUsage = {
      promptTokens: number;
      completionTokens: number;
      totalTokens: number;
      contextWindow: number;
      currentContextTokens: number;
    };

    export type ToolResult = {
      ok: boolean;
      output?: unknown;
      error?: string;
    };

    export type ConfirmRequest = {
      sessionId: string;
      title: string;
      message: string;
      actions: string[];
    };

    export type InputRequest = {
      sessionId: string;
      prompt: string;
      sensitive?: boolean;
    };
    """
  end

  defp method_type_map(methods, server_requests) do
    entries =
      (methods ++ server_requests)
      |> Enum.map_join("\n", fn %{method: m} ->
        base = method_to_type_name(m)
        "  \"#{m}\": { params: #{base}Params; result: #{base}Result };"
      end)

    "export interface MethodTypes {\n#{entries}\n}\n"
  end

  # --- TypeScript field rendering ---

  defp ts_field(%{name: name, type: type, required: req, description: desc}) do
    ts_name = snake_to_camel(name)
    ts_type = type_to_ts(type)
    optional = if req, do: "", else: "?"
    "  /** #{desc} */\n  #{ts_name}#{optional}: #{ts_type};"
  end

  # --- TypeScript type conversion ---

  defp type_to_ts(:string), do: "string"
  defp type_to_ts(:boolean), do: "boolean"
  defp type_to_ts(:integer), do: "number"
  defp type_to_ts(:object), do: "Record<string, unknown>"
  defp type_to_ts({:literal, val}), do: "\"#{val}\""

  defp type_to_ts({:array, inner}), do: "#{type_to_ts(inner)}[]"

  defp type_to_ts({:object, fields, required}) when is_map(fields) do
    entries =
      fields
      |> Enum.sort_by(&elem(&1, 0))
      |> Enum.map_join("; ", fn {k, v} ->
        ts = type_to_ts(v)
        optional = if MapSet.member?(required, k), do: "", else: "?"
        "#{snake_to_camel(k)}#{optional}: #{ts}"
      end)

    "{ #{entries} }"
  end

  defp type_to_ts({:object, fields}) when is_map(fields) do
    type_to_ts({:object, fields, MapSet.new(Map.keys(fields))})
  end

  # --- Naming helpers ---

  defp method_to_type_name(method) do
    method
    |> String.split("/")
    |> Enum.map(&capitalize/1)
    |> Enum.join()
  end

  defp method_to_const(method) do
    method
    |> String.replace("/", "_")
    |> String.upcase()
  end

  defp snake_to_camel(str) do
    [first | rest] = String.split(str, "_")
    first <> Enum.map_join(rest, &capitalize/1)
  end

  defp snake_to_pascal(str) do
    str |> String.split("_") |> Enum.map_join(&capitalize/1)
  end

  defp capitalize(<<first, rest::binary>>), do: String.upcase(<<first>>) <> rest
  defp capitalize(""), do: ""
end

Codegen.TS.run(System.argv())
