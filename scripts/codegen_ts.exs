# scripts/codegen_ts.exs
#
# Generates cli/src/protocol.ts from Opal.RPC.Protocol.spec().
#
# Usage:
#   cd core && mix run ../scripts/codegen_ts.exs [--check]
#

defmodule Codegen.TS do
  @output_path "../cli/src/sdk/protocol.ts"

  def run(args) do
    spec = Opal.RPC.Protocol.spec()
    ts = generate(spec) |> prettier()

    if "--check" in args do
      existing = File.read!(@output_path)

      if existing != ts do
        IO.puts(
          :stderr,
          "protocol.ts is out of date. Run: cd core && mix run ../scripts/codegen_ts.exs"
        )

        System.halt(1)
      else
        IO.puts("protocol.ts is up to date.")
      end
    else
      File.write!(@output_path, ts)
      IO.puts("Wrote #{@output_path}")
    end
  end

  defp prettier(code) do
    tmp = Path.join(System.tmp_dir!(), "codegen_protocol.ts")
    File.write!(tmp, code)
    {_output, 0} = System.cmd("npx", ["prettier", "--write", tmp], stderr_to_stdout: true)
    result = File.read!(tmp)
    File.rm!(tmp)
    result
  end

  defp generate(spec) do
    methods = spec.methods
    server_requests = spec.server_requests
    event_types = spec.event_types

    [
      "// AUTO-GENERATED by scripts/codegen_ts.exs â€” DO NOT EDIT\n\n",
      "// --- Method param/result interfaces ---\n\n",
      Enum.map(methods, &method_interfaces/1),
      Enum.map(server_requests, &method_interfaces/1),
      "// --- Agent event types ---\n\n",
      Enum.map(event_types, &event_interface/1),
      agent_event_union(event_types),
      "\n// --- Method constants ---\n\n",
      method_constants(methods, server_requests),
      "\n// --- Helper types ---\n\n",
      helper_types(),
      "\n// --- Method type mapping ---\n\n",
      method_type_map(methods, server_requests)
    ]
    |> IO.iodata_to_binary()
  end

  defp method_interfaces(%{method: method, params: params, result: result}) do
    base = method_to_type_name(method)

    params_block =
      if params == [] do
        "export type #{base}Params = Record<string, never>;\n\n"
      else
        fields = Enum.map_join(params, "\n", &param_field/1)
        "export interface #{base}Params {\n#{fields}\n}\n\n"
      end

    result_block =
      if result == [] do
        "export type #{base}Result = Record<string, never>;\n\n"
      else
        fields = Enum.map_join(result, "\n", &result_field/1)
        "export interface #{base}Result {\n#{fields}\n}\n\n"
      end

    params_block <> result_block
  end

  defp event_interface(%{type: type, fields: fields}) do
    name = snake_to_pascal(type)

    if fields == [] do
      "export interface #{name}Event {\n  type: \"#{snake_to_camel(type)}\";\n}\n\n"
    else
      field_lines = Enum.map_join(fields, "\n", &event_field/1)

      "export interface #{name}Event {\n  type: \"#{snake_to_camel(type)}\";\n#{field_lines}\n}\n\n"
    end
  end

  defp agent_event_union(event_types) do
    names =
      Enum.map_join(event_types, "\n  | ", fn %{type: t} -> "#{snake_to_pascal(t)}Event" end)

    "\nexport type AgentEvent =\n  | #{names};\n"
  end

  defp method_constants(methods, server_requests) do
    method_lines =
      Enum.map_join(methods, "\n", fn %{method: m} ->
        const = method_to_const(m)
        "  #{const}: \"#{m}\" as const,"
      end)

    sr_lines =
      Enum.map_join(server_requests, "\n", fn %{method: m} ->
        const = method_to_const(m)
        "  #{const}: \"#{m}\" as const,"
      end)

    "export const Methods = {\n#{method_lines}\n#{sr_lines}\n} as const;\n"
  end

  defp helper_types do
    """
    export interface TokenUsage {
      promptTokens: number;
      completionTokens: number;
      totalTokens: number;
      contextWindow: number;
      currentContextTokens: number;
    }

    export interface ToolResult {
      ok: boolean;
      output?: unknown;
      error?: string;
    }

    export interface ConfirmRequest {
      sessionId: string;
      title: string;
      message: string;
      actions: string[];
    }

    export interface InputRequest {
      sessionId: string;
      prompt: string;
      sensitive?: boolean;
    }
    """
  end

  defp method_type_map(methods, server_requests) do
    entries =
      (methods ++ server_requests)
      |> Enum.map_join("\n", fn %{method: m} ->
        base = method_to_type_name(m)
        "  \"#{m}\": { params: #{base}Params; result: #{base}Result };"
      end)

    "export interface MethodTypes {\n#{entries}\n}\n"
  end

  # --- Field rendering ---

  defp param_field(%{name: name, type: type, required: req, description: desc}) do
    ts_name = snake_to_camel(name)
    opt = if req, do: "", else: "?"
    "  /** #{desc} */\n  #{ts_name}#{opt}: #{type_to_ts(type)};"
  end

  defp result_field(%{name: name, type: type, description: desc}) do
    ts_name = snake_to_camel(name)
    "  /** #{desc} */\n  #{ts_name}: #{type_to_ts(type)};"
  end

  defp event_field(%{name: name, type: type, description: desc} = field) do
    ts_name = snake_to_camel(name)
    opt = if Map.get(field, :required) == false, do: "?", else: ""
    "  /** #{desc} */\n  #{ts_name}#{opt}: #{type_to_ts(type)};"
  end

  # --- Type conversion ---

  defp type_to_ts(:string), do: "string"
  defp type_to_ts(:boolean), do: "boolean"
  defp type_to_ts(:integer), do: "number"
  defp type_to_ts(:object), do: "Record<string, unknown>"
  defp type_to_ts({:array, inner}), do: "#{type_to_ts(inner)}[]"

  defp type_to_ts({:object, fields}) when is_map(fields) do
    entries =
      fields
      |> Enum.sort_by(&elem(&1, 0))
      |> Enum.map_join("; ", fn {k, v} -> "#{snake_to_camel(k)}: #{type_to_ts(v)}" end)

    "{ #{entries} }"
  end

  # --- Naming helpers ---

  defp method_to_type_name(method) do
    method
    |> String.split("/")
    |> Enum.map(&capitalize/1)
    |> Enum.join()
  end

  defp method_to_const(method) do
    method
    |> String.replace("/", "_")
    |> String.upcase()
  end

  defp snake_to_camel(str) do
    [first | rest] = String.split(str, "_")
    first <> Enum.map_join(rest, &capitalize/1)
  end

  defp snake_to_pascal(str) do
    str |> String.split("_") |> Enum.map_join(&capitalize/1)
  end

  defp capitalize(<<first, rest::binary>>), do: String.upcase(<<first>>) <> rest
  defp capitalize(""), do: ""
end

Codegen.TS.run(System.argv())
