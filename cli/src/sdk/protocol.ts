// AUTO-GENERATED by scripts/codegen_ts.exs â€” DO NOT EDIT
// Source: priv/rpc_schema.json (version 0.1.0)

// --- Method param/result types ---

export type AgentAbortParams = {
  /** Target session ID. */
  sessionId: string;
};

export type AgentAbortResult = Record<string, never>;

export type AgentPromptParams = {
  /** Target session ID. */
  sessionId: string;
  /** The user's prompt text. */
  text: string;
};

export type AgentPromptResult = {
  /** True when the agent was busy and the message was queued. */
  queued: boolean;
};

export type AgentStateParams = {
  /** Target session ID. */
  sessionId: string;
};

export type AgentStateResult = {
  /** Number of messages in history. */
  messageCount: number;
  /** Current model. */
  model: { id: string; provider: string; thinkingLevel: string };
  /** Session ID. */
  sessionId: string;
  /** One of: idle, running, streaming. */
  status: string;
  /** Active tool names. */
  tools: string[];
};

export type AuthLoginParams = Record<string, never>;

export type AuthLoginResult = {
  /** Device code for polling. */
  deviceCode: string;
  /** Polling interval in seconds. */
  interval: number;
  /** Code for the user to enter. */
  userCode: string;
  /** URL to visit. */
  verificationUri: string;
};

export type AuthPollParams = {
  /** Device code from auth/login. */
  deviceCode: string;
  /** Polling interval in seconds. */
  interval: number;
};

export type AuthPollResult = {
  /** True once the user has authorized. */
  authenticated: boolean;
};

export type AuthStatusParams = Record<string, never>;

export type AuthStatusResult = {
  /** Probe result: status is 'ready' or 'setup_required', provider is 'copilot' or null. */
  auth: { provider: string; status: string };
  /** True if Copilot credentials are available. */
  authenticated: boolean;
};

export type CliHistoryGetParams = Record<string, never>;

export type CliHistoryGetResult = {
  /** Array of command history entries. */
  commands: { text: string; timestamp: string }[];
  /** Maximum number of history entries. */
  maxSize: number;
  /** History format version. */
  version: number;
};

export type CliStateGetParams = Record<string, never>;

export type CliStateGetResult = {
  /** Last used model configuration. */
  lastModel: Record<string, unknown>;
  /** CLI user preferences. */
  preferences: { autoConfirm: boolean; verbose: boolean };
  /** CLI state format version. */
  version: number;
};

export type CliStateSetParams = {
  /** Model configuration to save. */
  lastModel?: Record<string, unknown>;
  /** Preferences to update. */
  preferences?: Record<string, unknown>;
};

export type CliStateSetResult = {
  /** Last used model configuration. */
  lastModel: Record<string, unknown>;
  /** CLI user preferences. */
  preferences: { autoConfirm: boolean; verbose: boolean };
  /** CLI state format version. */
  version: number;
};

export type ModelSetParams = {
  /** Model ID to switch to. */
  modelId: string;
  /** Target session ID. */
  sessionId: string;
  /** Reasoning effort: off, low, medium, high. */
  thinkingLevel?: string;
};

export type ModelSetResult = {
  /** The new active model. */
  model: { id: string; provider: string; thinkingLevel: string };
};

export type ModelsListParams = Record<string, never>;

export type ModelsListResult = {
  /** Array of {id, name, provider, supports_thinking}. */
  models: Record<string, unknown>[];
};

export type OpalConfigGetParams = {
  /** Target session ID. */
  sessionId: string;
};

export type OpalConfigGetResult = {
  /** Erlang distribution info if active (node name and cookie), or null if not distributed. */
  distribution: { cookie: string; node: string } | null;
  /** Current runtime feature flags. */
  features: {
    debug: boolean;
    mcp: boolean;
    skills: boolean;
    subAgents: boolean;
  };
  /** Tool availability for the session. */
  tools: { all: string[]; disabled: string[]; enabled: string[] };
};

export type OpalConfigSetParams = {
  /** Start or stop Erlang distribution. Pass {name, cookie?} to start, null to stop. */
  distribution?: { cookie?: string; name: string } | null;
  /** Feature flags to update. */
  features?: {
    debug: boolean;
    mcp: boolean;
    skills: boolean;
    subAgents: boolean;
  };
  /** Target session ID. */
  sessionId: string;
  /** Exact list of enabled tool names. */
  tools?: string[];
};

export type OpalConfigSetResult = {
  /** Erlang distribution info if active (node name and cookie), or null if not distributed. */
  distribution: { cookie: string; node: string } | null;
  /** Current runtime feature flags. */
  features: {
    debug: boolean;
    mcp: boolean;
    skills: boolean;
    subAgents: boolean;
  };
  /** Tool availability for the session. */
  tools: { all: string[]; disabled: string[]; enabled: string[] };
};

export type OpalPingParams = Record<string, never>;

export type OpalPingResult = Record<string, never>;

export type OpalVersionParams = Record<string, never>;

export type OpalVersionResult = {
  /** RPC protocol version (e.g. 0.1.0). */
  protocolVersion: string;
  /** Opal server version (e.g. 0.1.10). */
  serverVersion: string;
};

export type SessionBranchParams = {
  /** Message ID to branch from. */
  entryId: string;
  /** Target session ID. */
  sessionId: string;
};

export type SessionBranchResult = Record<string, never>;

export type SessionCompactParams = {
  /** Number of recent messages to keep. Default: 10. */
  keepRecent?: number;
  /** Target session ID. */
  sessionId: string;
};

export type SessionCompactResult = Record<string, never>;

export type SessionDeleteParams = {
  /** ID of the session to delete. */
  sessionId: string;
};

export type SessionDeleteResult = {
  /** True if deleted successfully. */
  ok: boolean;
};

export type SessionHistoryParams = {
  /** Target session ID. */
  sessionId: string;
};

export type SessionHistoryResult = {
  /** Ordered list of messages from root to current leaf. Each message has id, role, content, thinking, tool_calls, call_id, name, is_error, and metadata. */
  messages: Record<string, unknown>[];
};

export type SessionListParams = Record<string, never>;

export type SessionListResult = {
  /** Array of {id, title, modified}. */
  sessions: Record<string, unknown>[];
};

export type SessionStartParams = {
  /** Boot-time feature toggles. */
  features?: {
    debug: boolean;
    mcp: boolean;
    skills: boolean;
    subAgents: boolean;
  };
  /** MCP server configurations. */
  mcpServers?: Record<string, unknown>[];
  /** Model to use. Defaults to config default. */
  model?: { id: string; provider: string; thinkingLevel?: string };
  /** If true, enable session persistence. */
  session?: boolean;
  /** Resume an existing session by ID. Implies session=true. The session is loaded from disk. */
  sessionId?: string;
  /** System prompt for the agent. */
  systemPrompt?: string;
  /** Working directory. Defaults to server cwd. */
  workingDir?: string;
};

export type SessionStartResult = {
  /** Auth probe result: status is 'ready' or 'setup_required', provider is 'copilot' or null. */
  auth: { provider: string; status: string };
  /** Names of discovered skills (not yet loaded). */
  availableSkills: string[];
  /** Paths of loaded context files. */
  contextFiles: string[];
  /** Names of connected MCP servers. */
  mcpServers: string[];
  /** Erlang node name of the server (for debugging). */
  nodeName: string;
  /** Filesystem path to the session's data directory. */
  sessionDir: string;
  /** The new session's unique ID. */
  sessionId: string;
};

export type SettingsGetParams = Record<string, never>;

export type SettingsGetResult = {
  /** Map of setting key-value pairs. */
  settings: Record<string, unknown>;
};

export type SettingsSaveParams = {
  /** Map of setting key-value pairs to save. */
  settings: Record<string, unknown>;
};

export type SettingsSaveResult = {
  /** The full settings after merge. */
  settings: Record<string, unknown>;
};

export type TasksListParams = {
  /** Target session ID. */
  sessionId: string;
};

export type TasksListResult = {
  /** Array of task objects. */
  tasks: Record<string, unknown>[];
};

export type ThinkingSetParams = {
  /** Reasoning effort: off, low, medium, high. */
  level: string;
  /** Target session ID. */
  sessionId: string;
};

export type ThinkingSetResult = {
  /** The new thinking level. */
  thinkingLevel: string;
};

export type ClientAsk_userParams = {
  /** Optional multiple-choice options. */
  choices?: string[];
  /** The question to display. */
  question: string;
  /** Session this question belongs to. */
  sessionId: string;
};

export type ClientAsk_userResult = {
  /** The user's response text. */
  answer: string;
};

export type ClientConfirmParams = {
  /** Available actions (e.g., ["allow", "deny", "allow_session"]). */
  actions: string[];
  /** Detailed message to show. */
  message: string;
  /** Session this confirmation belongs to. */
  sessionId: string;
  /** Short title for the confirmation dialog. */
  title: string;
};

export type ClientConfirmResult = {
  /** The user's chosen action. */
  action: string;
};

export type ClientInputParams = {
  /** Prompt to display to the user. */
  prompt: string;
  /** If true, input should be masked (e.g., API keys). */
  sensitive?: boolean;
  /** Session this input request belongs to. */
  sessionId: string;
};

export type ClientInputResult = {
  /** The user's input. */
  text: string;
};

// --- Agent event types ---

export type AgentAbortEvent = {
  /** Event type discriminator. */
  readonly type: "agentAbort";
};

export type AgentEndEvent = {
  /** Event type discriminator. */
  readonly type: "agentEnd";
  /** Cumulative token usage for the session. */
  usage?: {
    completionTokens: number;
    contextWindow: number;
    currentContextTokens: number;
    promptTokens: number;
    totalTokens: number;
  };
};

export type AgentRecoveredEvent = {
  /** Event type discriminator. */
  readonly type: "agentRecovered";
};

export type AgentStartEvent = {
  /** Event type discriminator. */
  readonly type: "agentStart";
};

export type ContextDiscoveredEvent = {
  /** Event type discriminator. */
  readonly type: "contextDiscovered";
  /** Paths of discovered context files. */
  files: string[];
};

export type ErrorEvent = {
  /** Event type discriminator. */
  readonly type: "error";
  /** Error description. */
  reason: string;
};

export type MessageAppliedEvent = {
  /** Event type discriminator. */
  readonly type: "messageApplied";
  /** The message text. */
  text: string;
};

export type MessageDeltaEvent = {
  /** Event type discriminator. */
  readonly type: "messageDelta";
  /** The text fragment. */
  delta: string;
};

export type MessageQueuedEvent = {
  /** Event type discriminator. */
  readonly type: "messageQueued";
  /** The queued message text. */
  text: string;
};

export type MessageStartEvent = {
  /** Event type discriminator. */
  readonly type: "messageStart";
};

export type SkillLoadedEvent = {
  /** Event type discriminator. */
  readonly type: "skillLoaded";
  /** Skill description. */
  description: string;
  /** Skill name. */
  name: string;
};

export type StatusUpdateEvent = {
  /** Event type discriminator. */
  readonly type: "statusUpdate";
  /** Brief human-readable status. */
  message: string;
};

export type SubAgentEventEvent = {
  /** Event type discriminator. */
  readonly type: "subAgentEvent";
  /** The wrapped agent event from the sub-agent (contains a type field and event-specific data). */
  inner: Record<string, unknown>;
  /** The call_id of the parent sub_agent tool invocation. */
  parentCallId: string;
  /** The sub-agent's session ID. */
  subSessionId: string;
};

export type ThinkingDeltaEvent = {
  /** Event type discriminator. */
  readonly type: "thinkingDelta";
  /** The thinking text fragment. */
  delta: string;
};

export type ThinkingStartEvent = {
  /** Event type discriminator. */
  readonly type: "thinkingStart";
};

export type ToolExecutionEndEvent = {
  /** Event type discriminator. */
  readonly type: "toolExecutionEnd";
  /** Unique call identifier. */
  callId: string;
  /** Tool execution result object. Includes ok plus tool-specific payload fields. May optionally include a meta field with tool-specific structured data (e.g., diffs). */
  result: Record<string, unknown>;
  /** Tool name. */
  tool: string;
};

export type ToolExecutionStartEvent = {
  /** Event type discriminator. */
  readonly type: "toolExecutionStart";
  /** Tool arguments. */
  args: Record<string, unknown>;
  /** Unique call identifier. */
  callId: string;
  /** Human-readable summary of the invocation. */
  meta: string;
  /** Tool name. */
  tool: string;
};

export type ToolOutputEvent = {
  /** Event type discriminator. */
  readonly type: "toolOutput";
  /** Unique call identifier. */
  callId: string;
  /** Output chunk. */
  chunk: string;
  /** Tool name. */
  tool: string;
};

export type TurnEndEvent = {
  /** Event type discriminator. */
  readonly type: "turnEnd";
  /** The assistant's message text. */
  message: string;
};

export type UsageUpdateEvent = {
  /** Event type discriminator. */
  readonly type: "usageUpdate";
  /** Current token usage snapshot. */
  usage: {
    completionTokens: number;
    contextWindow: number;
    currentContextTokens: number;
    promptTokens: number;
    totalTokens: number;
  };
};

export type AgentEvent =
  | AgentAbortEvent
  | AgentEndEvent
  | AgentRecoveredEvent
  | AgentStartEvent
  | ContextDiscoveredEvent
  | ErrorEvent
  | MessageAppliedEvent
  | MessageDeltaEvent
  | MessageQueuedEvent
  | MessageStartEvent
  | SkillLoadedEvent
  | StatusUpdateEvent
  | SubAgentEventEvent
  | ThinkingDeltaEvent
  | ThinkingStartEvent
  | ToolExecutionEndEvent
  | ToolExecutionStartEvent
  | ToolOutputEvent
  | TurnEndEvent
  | UsageUpdateEvent;

// --- Method constants ---

export const Methods = {
  AGENT_ABORT: "agent/abort" as const,
  AGENT_PROMPT: "agent/prompt" as const,
  AGENT_STATE: "agent/state" as const,
  AUTH_LOGIN: "auth/login" as const,
  AUTH_POLL: "auth/poll" as const,
  AUTH_STATUS: "auth/status" as const,
  CLI_HISTORY_GET: "cli/history/get" as const,
  CLI_STATE_GET: "cli/state/get" as const,
  CLI_STATE_SET: "cli/state/set" as const,
  MODEL_SET: "model/set" as const,
  MODELS_LIST: "models/list" as const,
  OPAL_CONFIG_GET: "opal/config/get" as const,
  OPAL_CONFIG_SET: "opal/config/set" as const,
  OPAL_PING: "opal/ping" as const,
  OPAL_VERSION: "opal/version" as const,
  SESSION_BRANCH: "session/branch" as const,
  SESSION_COMPACT: "session/compact" as const,
  SESSION_DELETE: "session/delete" as const,
  SESSION_HISTORY: "session/history" as const,
  SESSION_LIST: "session/list" as const,
  SESSION_START: "session/start" as const,
  SETTINGS_GET: "settings/get" as const,
  SETTINGS_SAVE: "settings/save" as const,
  TASKS_LIST: "tasks/list" as const,
  THINKING_SET: "thinking/set" as const,
  CLIENT_ASK_USER: "client/ask_user" as const,
  CLIENT_CONFIRM: "client/confirm" as const,
  CLIENT_INPUT: "client/input" as const,
} as const;

// --- Helper types ---

export type TokenUsage = {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
  contextWindow: number;
  currentContextTokens: number;
};

export type ToolResult = {
  ok: boolean;
  output?: unknown;
  error?: string;
};

export type ConfirmRequest = {
  sessionId: string;
  title: string;
  message: string;
  actions: string[];
};

export type InputRequest = {
  sessionId: string;
  prompt: string;
  sensitive?: boolean;
};

// --- Method type mapping ---

export interface MethodTypes {
  "agent/abort": { params: AgentAbortParams; result: AgentAbortResult };
  "agent/prompt": { params: AgentPromptParams; result: AgentPromptResult };
  "agent/state": { params: AgentStateParams; result: AgentStateResult };
  "auth/login": { params: AuthLoginParams; result: AuthLoginResult };
  "auth/poll": { params: AuthPollParams; result: AuthPollResult };
  "auth/status": { params: AuthStatusParams; result: AuthStatusResult };
  "cli/history/get": {
    params: CliHistoryGetParams;
    result: CliHistoryGetResult;
  };
  "cli/state/get": { params: CliStateGetParams; result: CliStateGetResult };
  "cli/state/set": { params: CliStateSetParams; result: CliStateSetResult };
  "model/set": { params: ModelSetParams; result: ModelSetResult };
  "models/list": { params: ModelsListParams; result: ModelsListResult };
  "opal/config/get": {
    params: OpalConfigGetParams;
    result: OpalConfigGetResult;
  };
  "opal/config/set": {
    params: OpalConfigSetParams;
    result: OpalConfigSetResult;
  };
  "opal/ping": { params: OpalPingParams; result: OpalPingResult };
  "opal/version": { params: OpalVersionParams; result: OpalVersionResult };
  "session/branch": {
    params: SessionBranchParams;
    result: SessionBranchResult;
  };
  "session/compact": {
    params: SessionCompactParams;
    result: SessionCompactResult;
  };
  "session/delete": {
    params: SessionDeleteParams;
    result: SessionDeleteResult;
  };
  "session/history": {
    params: SessionHistoryParams;
    result: SessionHistoryResult;
  };
  "session/list": { params: SessionListParams; result: SessionListResult };
  "session/start": { params: SessionStartParams; result: SessionStartResult };
  "settings/get": { params: SettingsGetParams; result: SettingsGetResult };
  "settings/save": { params: SettingsSaveParams; result: SettingsSaveResult };
  "tasks/list": { params: TasksListParams; result: TasksListResult };
  "thinking/set": { params: ThinkingSetParams; result: ThinkingSetResult };
  "client/ask_user": {
    params: ClientAsk_userParams;
    result: ClientAsk_userResult;
  };
  "client/confirm": {
    params: ClientConfirmParams;
    result: ClientConfirmResult;
  };
  "client/input": { params: ClientInputParams; result: ClientInputResult };
}
