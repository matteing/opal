// AUTO-GENERATED by scripts/codegen_ts.exs â€” DO NOT EDIT
// Source: priv/rpc_schema.json (version 0.1.0)

// --- Method param/result interfaces ---

export interface AgentAbortParams {
  /** Target session ID. */
  sessionId: string;
}

export type AgentAbortResult = Record<string, never>;

export interface AgentPromptParams {
  /** Target session ID. */
  sessionId: string;
  /** The user's prompt text. */
  text: string;
}

export interface AgentPromptResult {
  /** True when the agent was busy and the message was queued. */
  queued: boolean;
}

export interface AgentStateParams {
  /** Target session ID. */
  sessionId: string;
}

export interface AgentStateResult {
  /** Number of messages in history. */
  messageCount: number;
  /** Current model. */
  model: { id: string; provider: string; thinkingLevel: string };
  /** Session ID. */
  sessionId: string;
  /** One of: idle, running, streaming. */
  status: string;
  /** Active tool names. */
  tools: string[];
}

export type AuthLoginParams = Record<string, never>;

export interface AuthLoginResult {
  /** Device code for polling. */
  deviceCode: string;
  /** Polling interval in seconds. */
  interval: number;
  /** Code for the user to enter. */
  userCode: string;
  /** URL to visit. */
  verificationUri: string;
}

export interface AuthPollParams {
  /** Device code from auth/login. */
  deviceCode: string;
  /** Polling interval in seconds. */
  interval: number;
}

export interface AuthPollResult {
  /** True once the user has authorized. */
  authenticated: boolean;
}

export interface AuthSet_keyParams {
  /** The API key to save. */
  apiKey: string;
  /** Provider ID (e.g. 'anthropic', 'openai'). */
  provider: string;
}

export interface AuthSet_keyResult {
  /** True if the key was saved. */
  ok: boolean;
}

export type AuthStatusParams = Record<string, never>;

export interface AuthStatusResult {
  /** Full probe result with provider list and readiness. */
  auth: {
    provider: string;
    providers: Record<string, unknown>[];
    status: string;
  };
  /** True if any provider has credentials. */
  authenticated: boolean;
}

export interface ModelSetParams {
  /** Model ID to switch to. */
  modelId: string;
  /** Target session ID. */
  sessionId: string;
  /** Reasoning effort: off, low, medium, high. */
  thinkingLevel?: string;
}

export interface ModelSetResult {
  /** The new active model. */
  model: { id: string; provider: string; thinkingLevel: string };
}

export interface ModelsListParams {
  /** Optional list of direct providers to include (e.g. ["anthropic", "openai"]). */
  providers?: string[];
}

export interface ModelsListResult {
  /** Array of {id, name, provider, supports_thinking}. */
  models: Record<string, unknown>[];
}

export interface OpalConfigGetParams {
  /** Target session ID. */
  sessionId: string;
}

export interface OpalConfigGetResult {
  /** Current runtime feature flags. */
  features: {
    debug: boolean;
    mcp: boolean;
    skills: boolean;
    subAgents: boolean;
  };
  /** Tool availability for the session. */
  tools: { all: string[]; disabled: string[]; enabled: string[] };
}

export interface OpalConfigSetParams {
  /** Feature flags to update. */
  features?: {
    debug: boolean;
    mcp: boolean;
    skills: boolean;
    subAgents: boolean;
  };
  /** Target session ID. */
  sessionId: string;
  /** Exact list of enabled tool names. */
  tools?: string[];
}

export interface OpalConfigSetResult {
  /** Current runtime feature flags. */
  features: {
    debug: boolean;
    mcp: boolean;
    skills: boolean;
    subAgents: boolean;
  };
  /** Tool availability for the session. */
  tools: { all: string[]; disabled: string[]; enabled: string[] };
}

export type OpalPingParams = Record<string, never>;

export type OpalPingResult = Record<string, never>;

export type OpalVersionParams = Record<string, never>;

export interface OpalVersionResult {
  /** RPC protocol version (e.g. 0.1.0). */
  protocolVersion: string;
  /** Opal server version (e.g. 0.1.10). */
  serverVersion: string;
}

export interface SessionBranchParams {
  /** Message ID to branch from. */
  entryId: string;
  /** Target session ID. */
  sessionId: string;
}

export type SessionBranchResult = Record<string, never>;

export interface SessionCompactParams {
  /** Number of recent messages to keep. Default: 10. */
  keepRecent?: number;
  /** Target session ID. */
  sessionId: string;
}

export type SessionCompactResult = Record<string, never>;

export interface SessionDeleteParams {
  /** ID of the session to delete. */
  sessionId: string;
}

export interface SessionDeleteResult {
  /** True if deleted successfully. */
  ok: boolean;
}

export type SessionListParams = Record<string, never>;

export interface SessionListResult {
  /** Array of {id, title, modified}. */
  sessions: Record<string, unknown>[];
}

export interface SessionStartParams {
  /** Boot-time feature toggles. */
  features?: {
    debug: boolean;
    mcp: boolean;
    skills: boolean;
    subAgents: boolean;
  };
  /** MCP server configurations. */
  mcpServers?: Record<string, unknown>[];
  /** Model to use. Defaults to config default. */
  model?: { id: string; provider: string };
  /** If true, enable session persistence. */
  session?: boolean;
  /** Resume an existing session by ID. Implies session=true. The session is loaded from disk. */
  sessionId?: string;
  /** System prompt for the agent. */
  systemPrompt?: string;
  /** Tool names to enable. */
  tools?: string[];
  /** Working directory. Defaults to server cwd. */
  workingDir?: string;
}

export interface SessionStartResult {
  /** Auth probe result: status is 'ready' or 'setup_required', provider is auto-selected ID or null, providers lists all known options with readiness. */
  auth: {
    provider: string;
    providers: Record<string, unknown>[];
    status: string;
  };
  /** Names of discovered skills (not yet loaded). */
  availableSkills: string[];
  /** Paths of loaded context files. */
  contextFiles: string[];
  /** Names of connected MCP servers. */
  mcpServers: string[];
  /** Erlang node name of the server (for debugging). */
  nodeName: string;
  /** Filesystem path to the session's data directory. */
  sessionDir: string;
  /** The new session's unique ID. */
  sessionId: string;
}

export type SettingsGetParams = Record<string, never>;

export interface SettingsGetResult {
  /** Map of setting key-value pairs. */
  settings: Record<string, unknown>;
}

export interface SettingsSaveParams {
  /** Map of setting key-value pairs to save. */
  settings: Record<string, unknown>;
}

export interface SettingsSaveResult {
  /** The full settings after merge. */
  settings: Record<string, unknown>;
}

export interface TasksListParams {
  /** Target session ID. */
  sessionId: string;
}

export interface TasksListResult {
  /** Array of task objects. */
  tasks: Record<string, unknown>[];
}

export interface ThinkingSetParams {
  /** Reasoning effort: off, low, medium, high. */
  level: string;
  /** Target session ID. */
  sessionId: string;
}

export interface ThinkingSetResult {
  /** The new thinking level. */
  thinkingLevel: string;
}

export interface ClientAsk_userParams {
  /** Optional multiple-choice options. */
  choices?: string[];
  /** The question to display. */
  question: string;
  /** Session this question belongs to. */
  sessionId: string;
}

export interface ClientAsk_userResult {
  /** The user's response text. */
  answer: string;
}

export interface ClientConfirmParams {
  /** Available actions (e.g., ["allow", "deny", "allow_session"]). */
  actions: string[];
  /** Detailed message to show. */
  message: string;
  /** Session this confirmation belongs to. */
  sessionId: string;
  /** Short title for the confirmation dialog. */
  title: string;
}

export interface ClientConfirmResult {
  /** The user's chosen action. */
  action: string;
}

export interface ClientInputParams {
  /** Prompt to display to the user. */
  prompt: string;
  /** If true, input should be masked (e.g., API keys). */
  sensitive?: boolean;
  /** Session this input request belongs to. */
  sessionId: string;
}

export interface ClientInputResult {
  /** The user's input. */
  text: string;
}

// --- Agent event types ---

export interface AgentAbortEvent {
  type: "agentAbort";
}

export interface AgentEndEvent {
  type: "agentEnd";
  /** Cumulative token usage for the session. */
  usage?: {
    completionTokens: number;
    contextWindow: number;
    currentContextTokens: number;
    promptTokens: number;
    totalTokens: number;
  };
}

export interface AgentRecoveredEvent {
  type: "agentRecovered";
}

export interface AgentStartEvent {
  type: "agentStart";
}

export interface ContextDiscoveredEvent {
  type: "contextDiscovered";
  /** Paths of discovered context files. */
  files: string[];
}

export interface ErrorEvent {
  type: "error";
  /** Error description. */
  reason: string;
}

export interface MessageAppliedEvent {
  type: "messageApplied";
  /** The message text. */
  text: string;
}

export interface MessageDeltaEvent {
  type: "messageDelta";
  /** The text fragment. */
  delta: string;
}

export interface MessageQueuedEvent {
  type: "messageQueued";
  /** The queued message text. */
  text: string;
}

export interface MessageStartEvent {
  type: "messageStart";
}

export interface SkillLoadedEvent {
  type: "skillLoaded";
  /** Skill description. */
  description: string;
  /** Skill name. */
  name: string;
}

export interface StatusUpdateEvent {
  type: "statusUpdate";
  /** Brief human-readable status. */
  message: string;
}

export interface SubAgentEventEvent {
  type: "subAgentEvent";
  /** The wrapped agent event from the sub-agent (contains a type field and event-specific data). */
  inner: Record<string, unknown>;
  /** The call_id of the parent sub_agent tool invocation. */
  parentCallId: string;
  /** The sub-agent's session ID. */
  subSessionId: string;
}

export interface ThinkingDeltaEvent {
  type: "thinkingDelta";
  /** The thinking text fragment. */
  delta: string;
}

export interface ThinkingStartEvent {
  type: "thinkingStart";
}

export interface ToolExecutionEndEvent {
  type: "toolExecutionEnd";
  /** Unique call identifier. */
  callId: string;
  /** Tool execution result object. Includes ok plus tool-specific payload fields. */
  result: Record<string, unknown>;
  /** Tool name. */
  tool: string;
}

export interface ToolExecutionStartEvent {
  type: "toolExecutionStart";
  /** Tool arguments. */
  args: Record<string, unknown>;
  /** Unique call identifier. */
  callId: string;
  /** Human-readable summary of the invocation. */
  meta: string;
  /** Tool name. */
  tool: string;
}

export interface TurnEndEvent {
  type: "turnEnd";
  /** The assistant's message text. */
  message: string;
}

export interface UsageUpdateEvent {
  type: "usageUpdate";
  /** Current token usage snapshot. */
  usage: {
    completionTokens: number;
    contextWindow: number;
    currentContextTokens: number;
    promptTokens: number;
    totalTokens: number;
  };
}

export type AgentEvent =
  | AgentAbortEvent
  | AgentEndEvent
  | AgentRecoveredEvent
  | AgentStartEvent
  | ContextDiscoveredEvent
  | ErrorEvent
  | MessageAppliedEvent
  | MessageDeltaEvent
  | MessageQueuedEvent
  | MessageStartEvent
  | SkillLoadedEvent
  | StatusUpdateEvent
  | SubAgentEventEvent
  | ThinkingDeltaEvent
  | ThinkingStartEvent
  | ToolExecutionEndEvent
  | ToolExecutionStartEvent
  | TurnEndEvent
  | UsageUpdateEvent;

// --- Method constants ---

export const Methods = {
  AGENT_ABORT: "agent/abort" as const,
  AGENT_PROMPT: "agent/prompt" as const,
  AGENT_STATE: "agent/state" as const,
  AUTH_LOGIN: "auth/login" as const,
  AUTH_POLL: "auth/poll" as const,
  AUTH_SET_KEY: "auth/set_key" as const,
  AUTH_STATUS: "auth/status" as const,
  MODEL_SET: "model/set" as const,
  MODELS_LIST: "models/list" as const,
  OPAL_CONFIG_GET: "opal/config/get" as const,
  OPAL_CONFIG_SET: "opal/config/set" as const,
  OPAL_PING: "opal/ping" as const,
  OPAL_VERSION: "opal/version" as const,
  SESSION_BRANCH: "session/branch" as const,
  SESSION_COMPACT: "session/compact" as const,
  SESSION_DELETE: "session/delete" as const,
  SESSION_LIST: "session/list" as const,
  SESSION_START: "session/start" as const,
  SETTINGS_GET: "settings/get" as const,
  SETTINGS_SAVE: "settings/save" as const,
  TASKS_LIST: "tasks/list" as const,
  THINKING_SET: "thinking/set" as const,
  CLIENT_ASK_USER: "client/ask_user" as const,
  CLIENT_CONFIRM: "client/confirm" as const,
  CLIENT_INPUT: "client/input" as const,
} as const;

// --- Helper types ---

export interface TokenUsage {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
  contextWindow: number;
  currentContextTokens: number;
}

export interface ToolResult {
  ok: boolean;
  output?: unknown;
  error?: string;
}

export interface ConfirmRequest {
  sessionId: string;
  title: string;
  message: string;
  actions: string[];
}

export interface InputRequest {
  sessionId: string;
  prompt: string;
  sensitive?: boolean;
}

// --- Method type mapping ---

export interface MethodTypes {
  "agent/abort": { params: AgentAbortParams; result: AgentAbortResult };
  "agent/prompt": { params: AgentPromptParams; result: AgentPromptResult };
  "agent/state": { params: AgentStateParams; result: AgentStateResult };
  "auth/login": { params: AuthLoginParams; result: AuthLoginResult };
  "auth/poll": { params: AuthPollParams; result: AuthPollResult };
  "auth/set_key": { params: AuthSet_keyParams; result: AuthSet_keyResult };
  "auth/status": { params: AuthStatusParams; result: AuthStatusResult };
  "model/set": { params: ModelSetParams; result: ModelSetResult };
  "models/list": { params: ModelsListParams; result: ModelsListResult };
  "opal/config/get": {
    params: OpalConfigGetParams;
    result: OpalConfigGetResult;
  };
  "opal/config/set": {
    params: OpalConfigSetParams;
    result: OpalConfigSetResult;
  };
  "opal/ping": { params: OpalPingParams; result: OpalPingResult };
  "opal/version": { params: OpalVersionParams; result: OpalVersionResult };
  "session/branch": {
    params: SessionBranchParams;
    result: SessionBranchResult;
  };
  "session/compact": {
    params: SessionCompactParams;
    result: SessionCompactResult;
  };
  "session/delete": {
    params: SessionDeleteParams;
    result: SessionDeleteResult;
  };
  "session/list": { params: SessionListParams; result: SessionListResult };
  "session/start": { params: SessionStartParams; result: SessionStartResult };
  "settings/get": { params: SettingsGetParams; result: SettingsGetResult };
  "settings/save": { params: SettingsSaveParams; result: SettingsSaveResult };
  "tasks/list": { params: TasksListParams; result: TasksListResult };
  "thinking/set": { params: ThinkingSetParams; result: ThinkingSetResult };
  "client/ask_user": {
    params: ClientAsk_userParams;
    result: ClientAsk_userResult;
  };
  "client/confirm": {
    params: ClientConfirmParams;
    result: ClientConfirmResult;
  };
  "client/input": { params: ClientInputParams; result: ClientInputResult };
}
